! function(i) {
    function s(t) {
        if (n[t]) return n[t].exports;
        var e = n[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return i[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports
    }
    var n = {};
    s.m = i, s.c = n, s.d = function(t, e, i) {
        s.o(t, e) || Object.defineProperty(t, e, {
            configurable: !1,
            enumerable: !0,
            get: i
        })
    }, s.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return s.d(e, "a", e), e
    }, s.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, s.p = "", s(s.s = 54)
}([function(e, t, i) {
    (function(t) {
        e.exports = t.Phaser = i(58)
    }).call(t, i(27))
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(34);
    e.Images = s.default;
    s = i(35);
    e.Constants = s.default;
    s = i(36);
    e.Atlases = s.default;
    s = i(63);
    e.Sounds = s.default;
    i = i(64);
    e.JSONData = i.default
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(65);
    e.GameCore = s.GameCore;
    s = i(13);
    e.MainGameCore = s.MainGameCore;
    s = i(43);
    e.GameObject = s.GameObject;
    s = i(77);
    e.IDisposed = s.IDisposed;
    s = i(78);
    e.IUpdated = s.IUpdated;
    s = i(79);
    e.IRestarted = s.IRestarted;
    s = i(28);
    e.GamePhysics = s.GamePhysics;
    s = i(22);
    e.NapePhysics = s.NapePhysics;
    s = i(44);
    e.GameBuilder = s.GameBuilder;
    s = i(20);
    e.MyRand = s.MyRand;
    s = i(23);
    e.NapeUtil = s.NapeUtil;
    s = i(38);
    e.GameView = s.GameView;
    s = i(24);
    e.Inventory = s.Inventory;
    s = i(82);
    e.CbTypes = s.CbTypes;
    s = i(83);
    e.Filters = s.Filters;
    s = i(84);
    e.Materials = s.Materials;
    s = i(85);
    e.PlayerObject = s.PlayerObject;
    s = i(88);
    e.AIController = s.AIController;
    s = i(92);
    e.AIController2 = s.AIController2;
    s = i(25);
    e.BaseController = s.BaseController;
    s = i(93);
    e.PlayerController = s.PlayerController;
    s = i(94);
    e.PlayerController2 = s.PlayerController2;
    s = i(95);
    e.PlayerControllerGeneral = s.PlayerControllerGeneral;
    s = i(96);
    e.Teleport = s.Teleport;
    s = i(45);
    e.BallObject = s.BallObject;
    s = i(39);
    e.TimerObject = s.TimerObject;
    s = i(97);
    e.CountDownObject = s.CountDownObject;
    s = i(98);
    e.EnergyBar = s.EnergyBar;
    s = i(99);
    e.MessageInfo = s.MessageInfo;
    s = i(19);
    e.ObjectsType = s.ObjectsType;
    s = i(100);
    e.BallTrail = s.BallTrail;
    s = i(29);
    e.ObjectsData = s.ObjectsData;
    i = i(101);
    e.PlayersData = i.PlayersData
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(1),
        r = i(7),
        h = i(9),
        l = i(10),
        c = i(4),
        u = i(0),
        d = i(37),
        p = i(2),
        f = i(12),
        g = i(11),
        m = i(5),
        n = (a = Phaser.State, n(y, a), y.prototype.preload = function() {
            var e = this;
            a.prototype.preload.call(this), this.game.sound.muteOnPause = !0, this.game.load.onFileComplete.add(this.fileComplete, this);
            var i = "x" + o.Constants.GAME_SCALE + "/";
            this.game.load.script("BlurX", "https://cdn.rawgit.com/photonstorm/phaser-ce/master/filters/BlurX.js"), this.game.load.script("BlurY", "https://cdn.rawgit.com/photonstorm/phaser-ce/master/filters/BlurY.js"), o.JSONData.list.forEach(function(t) {
                e.game.load.json(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/data/" + t + ".json")
            }), o.Images.list.forEach(function(t) {
                e.game.load.image(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/images/" + i + t + ".png")
            }), o.Atlases.list.forEach(function(t) {
                e.game.load.atlas(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/" + i + t + ".png", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/" + i + t + ".json")
            }), o.Sounds.list.forEach(function(t) {
                e.game.device.iOS ? e.game.load.audio(t, ["https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sound/" + t + ".m4a"]) : e.game.load.audio(t, ["https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sound/" + t + ".ogg", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sound/" + t + ".mp3"])
            }), this.game.scale.onSizeChange.add(function() {
                e.game.state.getCurrentState().resize()
            }, this)
        }, y.prototype.init = function() {
            this.game.world.removeAll(), this.backgroundBase = this.game.add.sprite(0, 0, o.Atlases.Preloader, h.default.getBG()), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill();
            var t = this.game.add.group(),
                e = this.game.add.group();
            this.backgroundBase.addChild(t), this.backgroundBase.addChild(e);
            this.ccc = new l.default(this.game, 100, 300, "MADPUFFERS 2019Â©", {
                font: "16px Impact2",
                fill: "#FFFFFF"
            }), this.ccc.anchor.set(.5), this.mainParent = this.game.add.group(), this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2, this.setPauseViewCar(this.mainParent), this.wait2 = this.game.add.text(this.game.width / 2, .75 * this.game.height, "LOADING...", o.Constants.styleLoading), this.wait2.anchor.set(.5), this.wait2.stroke = "#FFFFFF", this.wait2.strokeThickness = 5, this.wait = this.game.add.text(this.game.width / 2, .75 * this.game.height, "", o.Constants.styleLoading), this.wait.anchor.set(.5), this.wait.stroke = "#000000", this.wait.strokeThickness = 7, this.wait.mask = this.backgroundBaseMask, this.wait2.mask = this.backgroundBaseMask, this.ccc.mask = this.backgroundBaseMask, this.branding2.mask = this.backgroundBaseMask, this.inited = !0, this.resize()
        }, y.prototype.setPauseViewCar = function(t) {
            null !== this.bike && this.bike.destroy(), this.bike = this.game.add.group(t);
            var e = null;
            (e = this.game.add.image(0, 0, o.Atlases.Preloader, "logo0000")).anchor.set(.5), this.branding2 = new r.default(this.game, "", null, null, null, o.Atlases.Preloader), this.branding2.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.world.addChild(this.branding2), t.addChild(e)
        }, y.prototype.create = function() {
            a.prototype.create.call(this), this.resize()
        }, y.prototype.hide = function() {
            var t = this.game.add.tween(this.wait);
            t.to({
                y: 800
            }, c.default.PRELOADER_TIME, u.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.wait2)).to({
                y: 800
            }, c.default.PRELOADER_TIME, u.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                y: 800
            }, c.default.PRELOADER_TIME, u.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.ccc)).to({
                y: 800
            }, c.default.PRELOADER_TIME, u.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.mainParent)).to({
                y: -800
            }, c.default.PRELOADER_TIME, u.Easing.Linear.None), t.start()
        }, y.prototype.update = function() {
            a.prototype.update.call(this), this.loadComplete && (this.loadComplete = !1, y.game = this.game, this.startLocalGame())
        }, y.prototype.startLocalGame = function() {
            g.default.getInstance(this.game, this.onLoadSfx, this)
        }, y.prototype.onLoadSfx = function() {
            m.default.getInstance(this.game).playMusic(o.Sounds.MenuMusic), d.default.getInstance(this.game, this.onSaveGameLoad, this)
        }, y.prototype.onSaveGameLoad = function() {
            p.Inventory.instance.initManagers(), new h.default(this.game, this, f.Menu.Name)
        }, y.prototype.fileComplete = function(t, e, i, s, n) {
            this.wait2.setText("Loading " + t + "%")
        }, y.prototype.resize = function() {
            var t;
            this.inited && (t = (t = 1) < (t = this.game.width / o.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, this.bike.scale.set(t), this.mainParent.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.wait.alignIn(this.backgroundBase, Phaser.BOTTOM_CENTER, 0, -40), this.wait2.position.set(this.wait.x, this.wait.y), this.branding2.scale.set(t), this.branding2.alignIn(this.backgroundBase, Phaser.BOTTOM_RIGHT, -310, -10), this.ccc.scale.set(t), this.ccc.alignIn(this.backgroundBase, Phaser.BOTTOM_CENTER)), a.prototype.resize.call(this)
        }, y.prototype.shutdown = function() {
            this.mainParent = null, this.backgroundBase = null, this.wait = null, this.wait2 = null, this.branding2 = null, this.bike = null, a.prototype.shutdown.call(this)
        }, y.Name = "preloader", y.game = null, y);

    function y() {
        var t = a.call(this) || this;
        return t.name = y.Name, t.loadComplete = !0, t.bike = null, t.wait = null, t.wait2 = null, t.ccc = null, t.mainParent = null, t.backgroundBase = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.WIDTH = 800, n.WIDTH2 = 400, n.GAME_W = 1066, n.GAME_H = 640, n.GAME_W2 = 400, n.GAME_H2 = 240, n.DISPLAY_W = 1066, n.DISPLAY_H = 640, n.DISPLAY_W2 = 533, n.DISPLAY_H2 = 320, n.PRELOADER_TIME = 325, n.PRELOADER_TIME_HALF = 325, n.STEP = .025, n.MATCH_TIME = 60, n.OVERTIME_TIME = 15, n.LIMITS_FOR_ACHIEVS = [20, 50, 5, 5, 20, 50, 500, 25, 25, 150, 150], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(11),
        i = (n.getInstance = function(t) {
            if (null === n.instance) {
                if (!t) throw new Error("Cant create a new instance without a game");
                n.instance = new n(t)
            }
            return n.instance
        }, n.prototype.play = function(t, e, i) {
            return void 0 === e && (e = 1), void 0 === i && (i = !1), this.audioInstances.hasOwnProperty(t) || (this.audioInstances[t] = this.sound.add(t)), s.default.getInstance().sfx ? (this.audioInstances[t].play(void 0, void 0, e, i, !0), this.audioInstances[t]) : this.audioInstances[t].play(void 0, void 0, 0, i, !0)
        }, n.prototype.stop = function(t) {
            this.audioInstances.hasOwnProperty(t) && this.audioInstances[t].stop()
        }, n.prototype.playMusic = function(t) {
            if (!s.default.getInstance().music) return this.music = this.sound.play(t, .5, !0), void this.music.stop();
            null !== this.music && this.music.name === t || (null !== this.music && this.music.name !== t && this.music.stop(), this.music = this.sound.play(t, .5, !0))
        }, n.prototype.fadeMusicVolume = function(t, e) {
            this.music && this.music.fadeTo(t, e)
        }, n.prototype.stopMusic = function() {
            null !== this.music && this.music.isPlaying && this.music.stop()
        }, n.prototype.toggleSfx = function() {
            s.default.getInstance().sfx = !s.default.getInstance().sfx
        }, n.prototype.toggleMusic = function() {
            s.default.getInstance().music = !s.default.getInstance().music, s.default.getInstance().music ? this.music && this.music.play(void 0, void 0, 1, !0) : this.music && this.music.isPlaying && this.stopMusic()
        }, n.instance = null, n);

    function n(t) {
        this.music = null, this.audioInstances = {}, this.sound = t.sound
    }
    e.default = i
}, function(e, t, i) {
    (function(t) {
        e.exports = t.PIXI = i(57)
    }).call(t, i(27))
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var o, r = i(10),
        n = (o = Phaser.Group, n(a, o), Object.defineProperty(a.prototype, "labelState", {
            get: function() {
                return this._labelState
            },
            set: function(t) {
                this._labelState = t, this._texts.addChild(t), this._labelState.anchor.set(.5)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(a.prototype, "sScale", {
            set: function(t) {
                this._sScale = t, this._graphics.scale.set(this._sScale)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(a.prototype, "sLabelScale", {
            set: function(t) {
                this._sLabelScale = t, this._texts.scale.set(this._sLabelScale)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(a.prototype, "dynamicScaleDown", {
            set: function(t) {
                this._dynamicScaleDown = t
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(a.prototype, "dynamicScaleUp", {
            set: function(t) {
                this._dynamicScaleUp = t
            },
            enumerable: !0,
            configurable: !0
        }), a.prototype.onOver = function() {
            this._graphics.scale.set(this._sScale * this._dynamicScaleUp), this._texts.scale.set(this._sLabelScale * this._dynamicScaleUp)
        }, a.prototype.onDownLabel = function() {
            this._graphics.scale.set(this._sScale * this._dynamicScaleDown), this._texts.scale.set(this._sLabelScale * this._dynamicScaleDown)
        }, a.prototype.onOut = function() {
            this._graphics.scale.set(this._sScale), this._texts.scale.set(this._sLabelScale)
        }, a.prototype.setText = function(t) {
            this.label.setText(t)
        }, a.prototype.setFrames = function(t, e, i, s) {
            this.btn.setFrames(t, e, i, s)
        }, a.prototype.destroy = function(t) {
            this.id = null, this.label = null, this.btn = null, this._graphics = null, this._texts = null, this._labelState = null, o.prototype.destroy.call(this, t)
        }, Object.defineProperty(a.prototype, "enable", {
            get: function() {
                return this._enable
            },
            set: function(t) {
                this._enable !== t && (this._enable = t, this.btn.inputEnabled = this._enable, this._enable ? (this.btn.tint = 16777215, this.label.tint = 16777215) : (this.btn.tint = 10066329, this.label.tint = 10066329))
            },
            enumerable: !0,
            configurable: !0
        }), a);

    function a(t, e, i, s, n, a) {
        void 0 === a && (a = null);
        t = o.call(this, t) || this;
        return t._labelState = null, t._enable = !0, t._graphics = null, t._texts = null, t._dynamicScaleUp = 1.1, t._dynamicScaleDown = .9, t._sScale = 1, t._sLabelScale = 1, t.inputEnableChildren = !0, t._graphics = t.game.add.group(t), t._texts = t.game.add.group(t), t.btn = t.game.add.button(0, 0, a, s, n), t.btn.anchor.set(.5), t._graphics.addChild(t.btn), t.label = new r.default(t.game, 0, 2, e, i, 70, 40), t.label.anchor.set(.5), t._texts.addChild(t.label), null !== s && null !== n ? (t.label.inputEnabled = !0, t.label.events.onInputDown.add(s, n), t._graphics.inputEnableChildren = !0, t._graphics.onChildInputOver.add(t.onOver, t), t._graphics.onChildInputDown.add(t.onDownLabel, t), t._graphics.onChildInputOut.add(t.onOut, t), t._graphics.onChildInputUp.add(t.onOut, t), t._texts.inputEnableChildren = !0, t._texts.onChildInputOver.add(t.onOver, t), t._texts.onChildInputDown.add(t.onDownLabel, t), t._texts.onChildInputOut.add(t.onOut, t)) : (t._graphics.inputEnableChildren = !1, t._texts.inputEnableChildren = !1, t.btn.inputEnabled = !1), t.game.add.existing(t), t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var r, h = i(10),
        l = i(7),
        n = (r = Phaser.Group, n(a, r), a.prototype.drawRectHit = function() {
            var t = this.game.make.graphics();
            t.beginFill(16711680, 0), t.drawRect(+this.width / -2, +this.height / -2, +this.width, +this.height), t.endFill(), t.inputEnabled = !0, this.btn.label.parent.inputEnableChildren = !0, this.btn.label.parent.onChildInputDown.add(this._callback, this._context), this.btn.label.parent.addChild(t)
        }, a.prototype.setProp = function(t, e, i, s) {
            void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), null !== t && (this._colorFront = t), null !== i && (this._colorBack = i), null !== s && (this._thickBack = s), null !== e && (this._thickFront = e), this.btn.label.stroke = this._colorFront, this.btn.label.strokeThickness = this._thickFront, this.label.stroke = this._colorBack, this.label.strokeThickness = this._thickBack, null !== this._callback && null !== this._context && this.drawRectHit()
        }, a.prototype.setText = function(t) {
            this.label.setText(t), this.btn.setText(t)
        }, a.prototype.setFrames = function(t, e, i, s) {
            this.btn.setFrames(t, e, i, s)
        }, a.prototype.destroy = function(t) {
            this.btn = null, this.label = null, this._callback = null, this._context = null, r.prototype.destroy.call(this, t)
        }, Object.defineProperty(a.prototype, "enable", {
            get: function() {
                return this.btn.enable
            },
            set: function(t) {
                this.btn.enable = t
            },
            enumerable: !0,
            configurable: !0
        }), a);

    function a(t, e, i, s, n, a) {
        void 0 === a && (a = null);
        var o = r.call(this, t) || this;
        return o._colorFront = "#000000", o._thickFront = 7, o._colorBack = "#FFFFFF", o._thickBack = 15, o._callback = null, o._context = null, o.inputEnableChildren = !0, o.btn = new l.default(t, e, i, s, n, a), o.label = new h.default(o.game, 0, 2, e, i), o.label.anchor.set(.5), null !== s && null !== n && (o.label.inputEnabled = !0, o.btn.label.inputEnabled = !0, o.btn.label.input.useHandCursor = !0, o._callback = s, o._context = n), o.addChild(o.btn), o.btn.label.parent.addChildAt(o.label, 0), o.game.add.existing(o), o
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var r, h = i(4),
        l = i(1),
        c = i(0),
        n = (r = Phaser.Graphics, n(u, r), u.getBG = function() {
            return this.BASE_BG[this.INDEX_BG] + "0000"
        }, u.prototype.startTransition = function(t, e, i, s) {
            var n = this;
            t.hide && t.hide();
            e = this.game.add.tween(e);
            e.to({
                alpha: .5
            }, h.default.PRELOADER_TIME_HALF, c.Easing.Linear.None), e.onComplete.add(function() {
                n.game.state.start(i, !0, !1, s)
            }), e.start()
        }, u.prevState = [], u.INDEX_BG = 0, u.BASE_BG = ["bg1", "bg2blue", "bg1red"], u);

    function u(t, e, i, s) {
        var n, a, o = r.call(this, t) || this;
        return 2 === u.prevState.length && u.prevState.shift(), u.prevState.push(i + ""), t.add.existing(o), e.backgroundBase ? (n = o.game.make.sprite(0, 0, l.Atlases.Preloader, u.BASE_BG[u.INDEX_BG + 1 === 3 ? 0 : u.INDEX_BG + 1] + "0000"), e.backgroundBase.addChildAt(n, 1), n.alpha = .03, e.popup ? ((a = o.game.add.tween(e.popup)).to({
            alpha: 0
        }, h.default.PRELOADER_TIME_HALF, c.Easing.Linear.None), a.onComplete.add(function() {
            o.startTransition(e, n, i, s)
        }, o), a.start()) : o.startTransition(e, n, i, s)) : t.state.start(i, !0, !1, s), o
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var r, n = (r = Phaser.Text, n(a, r), a.prototype.setText = function(t) {
        return r.prototype.setText.call(this, t), (this.maxWidth || this.maxHeight) && this.makeFontFit(), this
    }, a.prototype.setMaxSize = function(t, e) {
        this.maxWidth = t, this.maxHeight = e
    }, a.prototype.makeFontFit = function() {
        for (var t; this.width > this.maxWidth || this.height > this.maxHeight;) {
            if ((t = parseInt(this.fontSize.toString().replace("px", ""), 10) - 1) < 10) {
                t = 10, this.fontSize = t;
                break
            }
            this.fontSize = t
        }
    }, a);

    function a(t, e, i, s, n, a, o) {
        n = r.call(this, t, e, i, s, n) || this;
        return n.maxWidth = a, n.maxHeight = o, n.game.add.existing(n), n
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var a = i(1),
        i = (s.prototype.initFirstSave = function() {
            this.sfxOn = !0, this.musicOn = !0, this.save()
        }, s.getInstance = function(t, e, i) {
            return s.instance ? i && e.call(i) : s.instance = new s(t, e, i), s.instance
        }, Object.defineProperty(s.prototype, "music", {
            get: function() {
                return this.musicOn
            },
            set: function(t) {
                this.musicOn = t, this.save()
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(s.prototype, "sfx", {
            get: function() {
                return this.sfxOn
            },
            set: function(t) {
                this.sfxOn = t, this.save()
            },
            enumerable: !0,
            configurable: !0
        }), s.prototype.save = function() {
            var t = JSON.stringify({
                    m: this.musicOn,
                    sf: this.sfxOn
                }),
                e = this.hash(t);
            this.game.storage.setItem(a.Constants.STORAGE_KEY_SFX, t), this.game.storage.setItem(a.Constants.STORAGE_KEY_SFX + "h", e)
        }, s.prototype.restore = function() {
            var i, s, n = this,
                t = this.game.storage.getItem(a.Constants.STORAGE_KEY_SFX),
                e = this.game.storage.getItem(a.Constants.STORAGE_KEY_SFX + "h");
            Promise.all([t, e]).then(function(t) {
                if (i = t[0] || "", s = t[1] || "0", "" === i) return n.initFirstSave(), void(n.callback && n.callbackContext && n.callback.call(n.callbackContext));
                if (s !== n.hash(i)) return n.initFirstSave(), void(n.callback && n.callbackContext && n.callback.call(n.callbackContext));
                if (i && "" !== i) try {
                    var e = JSON.parse(i);
                    n.musicOn = e.m, n.sfxOn = e.sf
                } catch (t) {
                    n.initFirstSave()
                } else n.initFirstSave();
                n.callback && n.callbackContext && n.callback.call(n.callbackContext)
            })
        }, s.prototype.hash = function(t) {
            var e, i, s = 0;
            if (0 === t.length) return s.toString();
            for (e = 0, i = t.length; e < i; e++) s = (s << 5) - s + t.charCodeAt(e), s |= 0;
            return s.toString()
        }, s);

    function s(t, e, i) {
        var s = this;
        this.musicOn = !0, this.sfxOn = !0, this.game = t, this.callback = e, this.callbackContext = i, this.game.storage.getItem(a.Constants.STORAGE_KEY_SFX).then(function(t) {
            null == t ? (s.initFirstSave(), s.callback && s.callbackContext && s.callback.call(s.callbackContext)) : s.restore()
        })
    }
    e.default = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(61);
    e.Boot = s.default;
    s = i(31);
    e.Gameplay = s.default;
    s = i(32);
    e.Menu = s.default;
    s = i(26);
    e.RandomState = s.default;
    i = i(105);
    e.TournamentState = i.default
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = i(66),
        h = i(3),
        l = i(22),
        c = i(0),
        u = i(5),
        d = i(24),
        p = i(11),
        f = i(76),
        g = i(4),
        m = i(15),
        y = i(30),
        b = i(1),
        v = i(14),
        n = (a = o.GameCore, n(_, a), Object.defineProperty(_, "instance", {
            get: function() {
                return _._instance || (_._instance = new _), _._instance
            },
            enumerable: !0,
            configurable: !0
        }), _.prototype.init = function(t) {
            a.prototype.init.call(this, t), this.view = new r.MainGameView(h.default.game), this.physics = new l.NapePhysics, this.physics2 = new f.Physics2, this.playersLeft = [], this.playersRight = [], this.opponents = []
        }, _.prototype.start = function() {
            a.prototype.start.call(this), this.matchPreloader = this.view.matchPreloader, this.matchPreloader.setCallBacks(this.restart2, this.startPlay, this), m.Signals.MatchProcessorSignal.add(this.processMatchProcessor, this), m.Signals.EventSignal.add(this.processEvent, this), this.isTraining = 3 === d.Inventory.instance.gameMode, this.isTraining = this.isTraining;
            var t = 0 === d.Inventory.instance.matchData.matchMode;
            this.isSinglePlayer = t, this.infoPanel = this.view.infoPanel, this.timer = this.view.timer, this.infoPanel.start(d.Inventory.instance.matchData.teams, d.Inventory.instance.matchData.matchScore[0], d.Inventory.instance.matchData.matchScore[1]), this.winSnds = [], this.winSnds[0] = b.Sounds.m_win, this.winSnds[1] = d.Inventory.instance.isPvP() ? b.Sounds.m_win : b.Sounds.m_lost, this.startMatch(!0), this.isTraining || (this.m_tribune = u.default.getInstance().play(b.Sounds.m_tribune, p.default.getInstance().sfx ? 1 : 0, !0))
        }, _.prototype.startMatch = function(t) {
            void 0 === t && (t = !0), this.SIDE = this.isTraining ? 1 : 0, this.isPlaying = !1, this.isPaused = !1, this.isOvertime = !1, this.isEnd = !1, this.isWaiting = !1, this.matchTime = 0;
            var e = this.isTraining ? 250 : 500;
            this.matchPreloader.setTime(e), this.isTraining || (this.endTime = t ? g.default.MATCH_TIME : g.default.OVERTIME_TIME, this.countDown.activate()), t && d.Inventory.instance.matchData.resetScore(), this.infoPanel.updateScore(d.Inventory.instance.matchData.matchScore[0], d.Inventory.instance.matchData.matchScore[1]), this.timer.start(this.endTime), this.restart2(), 4 === d.Inventory.instance.gameMode ? d.Inventory.instance.firstRun2 && (d.Inventory.instance.firstRun2 = !1, y.default.instance.signalPause.dispatch(_.HELP)) : d.Inventory.instance.firstRun && (d.Inventory.instance.firstRun = !1, y.default.instance.signalPause.dispatch(_.HELP))
        }, _.prototype.startPlay = function() {
            this.isScored = !1
        }, _.prototype.restart2 = function() {
            this.restart(this.SIDE), this.matchPreloader.hide()
        }, _.prototype.getNextState = function() {
            return 0 === d.Inventory.instance.gameMode || 1 === d.Inventory.instance.gameMode || 3 === d.Inventory.instance.gameMode ? "GameMode" : "NumPlayers"
        }, _.prototype.processMatchProcessor = function(t, e, i, s) {
            var n;
            this.isEnd || (n = -1 === t ? 1 : 0, u.default.getInstance().play(this.winSnds[n]), d.Inventory.instance.matchData.matchScore[n] += e, this.timer.updateScore(t, d.Inventory.instance.matchData.matchScore[n]), this.view.shake(s), this.isTraining ? (this.matchPreloader.show(), this.setEmotions(0)) : (this.SIDE = t, this.isScored = !0, this.scoredByHuman = i, this.isWaiting || (this.processEvent(i, s), this.matchPreloader.show(), this.setEmotions(-t))))
        }, _.prototype.update = function(t) {
            this.isPaused ? this.m_tribune && (this.m_tribune.volume = 0) : (this.m_tribune && (this.m_tribune.volume = p.default.getInstance().sfx ? 1 : 0), this.isPlaying ? (this.isAlleyOop && this.physics2.update(t), a.prototype.update.call(this, t), this.isEnd ? (this.deltaEndTime += t, this.deltaEndTime > this.delayEndTime && (this.isOvertime ? this.startMatch(!1) : (this.isPlaying = !1, this.nextState = "PostMatch", this.finishMatch()))) : this.isWaiting || this.isScored || this.isTraining || this.isSuperShot || (this.matchTime += t, this.timer.process(this.matchTime), this.matchTime >= this.endTime && this.endOfTime())) : this.countDown.process(t) && (u.default.getInstance().play(b.Sounds.m_whistle), this.isPlaying = !0))
        }, _.prototype.endOfTime = function() {
            u.default.getInstance().play(b.Sounds.m_buzzer), this.isBallInGame() ? (this.isWaiting = !0, this.activateWaiting(), m.Signals.MatchEndSignal.add(this.processMatchEnd, this)) : this.endMatch()
        }, _.prototype.processMatchEnd = function() {
            m.Signals.MatchEndSignal.remove(this.processMatchEnd, this), this.isWaiting = !1, this.endMatch()
        }, _.prototype.endMatch = function() {
            this.isEnd = !0, this.isOvertime = !1;
            var t = d.Inventory.instance.matchData.whoWins(),
                e = 10;
            0 === t && (e = 11, this.isOvertime = !0), this.setEmotions(t), this.isScored ? this.processEvent(this.scoredByHuman, 3, e) : this.messageInfo.show2(e), this.deltaEndTime = 0
        }, _.prototype.add = function(t) {
            var e;
            null !== t && (t.objType === o.ObjectsType.BALL ? (this.ball = t, this.ball.space2 = f.Physics2.space) : t.objType === o.ObjectsType.PLAYER ? (-1 === (e = t).SIDE ? this.playersLeft : this.playersRight).push(e) : t.objType === o.ObjectsType.BASKET ? -1 === (e = t).side ? this.basket1 = e : this.basket2 = e : (t.objType, o.ObjectsType.ARENA), t instanceof o.CountDownObject && (this.countDown = t), a.prototype.add.call(this, t))
        }, _.prototype.restart = function(t) {
            void 0 === t && (t = 0), a.prototype.restart.call(this, t), this.isSuperShot = !1, this.isAlleyOop = !1, this.isTraining ? (this.ball.takeInHands(-1, 0, !0), this.playersLeft[0].takeBallInHands()) : 0 !== t ? -1 === t ? (this.ball.takeInHands(t, this.leftCounter, !0), this.playersLeft[this.leftCounter].takeBallInHands(), this.leftCounter = this.leftCounter++/2>>0):(this.ball.takeInHands(t,this.rightCounter,!0),this.playersRight[this.rightCounter].takeBallInHands(),this.rightCounter=this.rightCounter++/
                2 >> 0) : g.default.isDesktop || v.default.instance.btnDown.labelState.loadTexture(b.Atlases.Gameplay, "shoot_icon0001"), this.physics.update(g.default.STEP)
        }, _.prototype.ballInHands = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            for (var i = 0; i < this.playersLeft.length; i++) this.playersLeft[i].ballInHands(t, e);
            for (var s = 0; s < this.playersRight.length; s++) this.playersRight[s].ballInHands(t, e)
        }, _.prototype.ballShooting = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            for (var i = 0; i < this.playersLeft.length; i++) this.playersLeft[i].ballShooting(t, e);
            for (var s = 0; s < this.playersRight.length; s++) this.playersRight[s].ballShooting(t, e)
        }, _.prototype.ballOthers = function() {
            for (var t = 0; t < this.playersLeft.length; t++) this.playersLeft[t].ballOthers();
            for (var e = 0; e < this.playersRight.length; e++) this.playersRight[e].ballOthers()
        }, _.prototype.setEmotions = function(t) {
            for (var e = 0; e < this.playersLeft.length; e++) this.playersLeft[e].setEmotion(t);
            for (var i = 0; i < this.playersRight.length; i++) this.playersRight[i].setEmotion(t)
        }, _.prototype.release = function() {
            this.ball = null, this.basket1 = null, this.basket2 = null, this.playersLeft.splice(0, this.playersLeft.length), this.playersRight.splice(0, this.playersRight.length), this.opponents.splice(0, this.opponents.length), this.physics2.release(), m.Signals.MatchProcessorSignal.remove(this.processMatchProcessor, this), a.prototype.release.call(this)
        }, _.prototype.steal = function(t, e, i, s) {
            var n;
            this.isTraining || this.isSuperShot || (this.opponents = -1 === t ? this.playersRight : this.playersLeft, n = !1, n = this.isSinglePlayer ? this.stealSinglePlayer(e, i, 0) : (t = this.opponents[0].checkToBeStolen(e, i)) < 0 ? this.stealSinglePlayer(e, i, 1) : ((0 < (i = this.opponents[1].checkToBeStolen(e, i)) && i < t ? this.opponents[1] : this.opponents[0]).getBeStolen(e), !0), s && n && m.Signals.EventSignal.dispatch(!0, 5))
        }, _.prototype.stealSinglePlayer = function(t, e, i) {
            return 0 <= this.opponents[i].checkToBeStolen(t, e) && (this.opponents[i].getBeStolen(t), !0)
        }, _.prototype.isBallInGame = function() {
            return "shooting" === this.ball.state || "basket" === this.ball.state || "dunk" === this.ball.state || "block" === this.ball.state
        }, _.prototype.activateWaiting = function() {
            this.ball.isWaiting = !0, this.setEmotions(0)
        }, _.prototype.getTeamMate = function(t) {
            return this.isSinglePlayer ? null : (t = 0 === t ? 1 : 0, this.playersLeft[t])
        }, _.prototype.processEvent = function(t, e, i) {
            void 0 === i && (i = 0), e < 9 && 4 !== e && 5 !== e && this.messageInfo.show2(e, i), 0 === d.Inventory.instance.gameMode && t && e < 7 && d.Inventory.instance.statsMgr.updateData(e)
        }, _.prototype.finishMatch = function() {
            this.isTraining || u.default.getInstance().stop(b.Sounds.m_tribune), "" === this.nextState && (this.nextState = _.FULL_TIME), this.isPaused = !0, _.instance.menuPauseSignal.dispatch(this.nextState)
        }, _.PAUSE = "pause", _.HELP = "help", _.FULL_TIME = "PostMatch", _);

    function _() {
        var t = a.call(this) || this;
        return t.isPlaying = !1, t.isPaused = !1, t.isWaiting = !1, t.scoredByHuman = !1, t.isEnd = !1, t.SIDE = 0, t.delayEndTime = 1.5, t.matchTime = 0, t.endTime = 0, t.leftCounter = 0, t.rightCounter = 0, t.nextState = "", t.slowSignal = new c.Signal, t.matchEndSignal = new c.Signal, t.menuPauseSignal = new c.Signal, m.Signals.MatchProcessorSignal.add(t.processMatchProcessor, t), t
    }
    e.MainGameCore = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = Phaser.Keyboard,
        n = i(1),
        a = i(7),
        o = i(4),
        i = (Object.defineProperty(r.prototype, "isbtnZ", {
            get: function() {
                return !o.default.isDesktop && this._isbtnZ || this.keyboard.isDown(s.Z)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnX", {
            get: function() {
                return !o.default.isDesktop && this._isbtnX || this.keyboard.isDown(s.X)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnK", {
            get: function() {
                return !o.default.isDesktop && this._isbtnK || this.keyboard.isDown(s.K)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnL", {
            get: function() {
                return !o.default.isDesktop && this._isbtnL || this.keyboard.isDown(s.L)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnV", {
            get: function() {
                return !o.default.isDesktop && this._isbtnV || this.keyboard.isDown(s.V)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnB", {
            get: function() {
                return !o.default.isDesktop && this._isbtnB || this.keyboard.isDown(s.B)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnUp", {
            get: function() {
                return !o.default.isDesktop && this._isbtnUp || this.keyboard.isDown(s.UP)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnDown", {
            get: function() {
                return !o.default.isDesktop && this._isbtnDown || this.keyboard.isDown(s.DOWN)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnLeft", {
            get: function() {
                return !o.default.isDesktop && this._isbtnLeft || this.keyboard.isDown(s.LEFT)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnLeftDouble", {
            get: function() {
                null === this.keyLeft && (this.keyLeft = this.keyboard.addKey(s.LEFT)), this.keyTimer = this.keyLeft.timeDown - this.keyLeft.timeUp;
                var t = this.keyTimer < 460 && this.keyLeft.justDown;
                if (o.default.isDesktop || t) return t;
                t = this.game.time.time - this.btnLeftDownTime < 100;
                return this.btnLeftDownTime - this.btnLeftUpTime < 460 && t
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnRight", {
            get: function() {
                return !o.default.isDesktop && this._isbtnRight || this.keyboard.isDown(s.RIGHT)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnRightDouble", {
            get: function() {
                null === this.keyRight && (this.keyRight = this.keyboard.addKey(s.RIGHT)), this.keyTimer = this.keyRight.timeDown - this.keyRight.timeUp;
                var t = this.keyTimer < 460 && this.keyRight.justDown;
                if (o.default.isDesktop || t) return t;
                t = this.game.time.time - this.btnRightDownTime < 100;
                return this.btnRightDownTime - this.btnRightUpTime < 460 && t
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnW", {
            get: function() {
                return !o.default.isDesktop && this._isbtnUp || this.keyboard.isDown(s.W)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnS", {
            get: function() {
                return !o.default.isDesktop && this._isbtnDown || this.keyboard.isDown(s.S)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnADouble", {
            get: function() {
                return null === this.keyA && (this.keyA = this.keyboard.addKey(s.A)), this.keyTimer = this.keyA.timeDown - this.keyA.timeUp, this.keyTimer < 460 && this.keyA.justDown
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnA", {
            get: function() {
                return !o.default.isDesktop && this._isbtnLeft || this.keyboard.isDown(s.A)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnDDouble", {
            get: function() {
                return null === this.keyD && (this.keyD = this.keyboard.addKey(s.D)), this.keyTimer = this.keyD.timeDown - this.keyD.timeUp, this.keyTimer < 460 && this.keyD.justDown
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isbtnD", {
            get: function() {
                return !o.default.isDesktop && this._isbtnRight || this.keyboard.isDown(s.D)
            },
            enumerable: !0,
            configurable: !0
        }), r.prototype.init = function(t, e) {
            this.container = t, this.game = e, this.container.inputEnableChildren = !0, this.keyboard = this.game.input.keyboard, this.keyboard.addKeyCapture(s.RIGHT), this.keyboard.addKeyCapture(s.LEFT), this.keyboard.addKeyCapture(s.DOWN), this.keyboard.addKeyCapture(s.UP), this.keyboard.addKeyCapture(s.A), this.keyboard.addKeyCapture(s.W), this.keyboard.addKeyCapture(s.S), this.keyboard.addKeyCapture(s.D), this.keyboard.addKeyCapture(s.Z), this.keyboard.addKeyCapture(s.X), this.keyboard.addKeyCapture(s.K), this.keyboard.addKeyCapture(s.L), o.default.isDesktop || this.createButtons()
        }, r.prototype.createButtons = function() {
            var t = this.game.add.image(0, 0, n.Atlases.Gameplay, "arrow_icon20000");
            t.anchor.set(.5), this.btnUp = new a.default(this.game, "", {}, function() {}, this, n.Atlases.Gameplay), this.btnUp.setFrames("btn_bg20000", "btn_bg20000", "btn_bg20000", "btn_bg20000"), this.btnUp.x = 725, this.btnUp.y = 427, this.btnUp.btn.alpha = .9, this.container.addChild(this.btnUp), this.btnUp.label.parent.addChild(t);
            var e = this.game.make.graphics();
            e.beginFill(16711680, 0), e.drawRect((this.btnUp.width + 5) / -2, (this.btnUp.height + 5) / -2, this.btnUp.width + 30, this.btnUp.height + 10), e.endFill(), e.inputEnabled = !0, e.events.onInputDown.add(this.upTap, this), e.events.onInputUp.add(this.upUnTap, this), this.btnUp.label.parent.addChild(e), this.btnZ = new a.default(this.game, "", {}, function() {}, this, n.Atlases.Gameplay), this.btnZ.setFrames("btn_bg20000", "btn_bg20000", "btn_bg20000", "btn_bg20000"), this.btnZ.x = 745, this.btnZ.y = 327, this.btnZ.btn.events.onInputDown.add(this.ZTap, this), this.btnZ.btn.events.onInputUp.add(this.ZUnTap, this), this.btnZ.btn.alpha = .9, this.container.addChild(this.btnZ), (t = this.game.add.image(0, 0, n.Atlases.Gameplay, "shoot_icon0000")).anchor.set(.5), this.btnDown = new a.default(this.game, "", {}, function() {}, this, n.Atlases.Gameplay), this.btnDown.setFrames("btn_bg20000", "btn_bg20000", "btn_bg20000", "btn_bg20000"), this.btnDown.x = 615, this.btnDown.y = 427, this.btnDown.btn.events.onInputDown.add(this.XTap, this), this.btnDown.btn.events.onInputUp.add(this.XUnTap, this), this.btnDown.btn.alpha = .9, this.container.addChild(this.btnDown), this.btnDown.labelState = t, (t = this.game.add.image(0, 0, n.Atlases.Gameplay, "arrow_icon0000")).anchor.set(.5), t.scale.set(.85), this.btnLeft = new a.default(this.game, "", {}, function() {}, this, n.Atlases.Gameplay), this.btnLeft.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.btnLeft.x = 75, this.btnLeft.y = 415, this.btnLeft.sScale = .57, this.btnLeft.btn.alpha = .9, this.container.addChild(this.btnLeft), t.angle = -180, this.btnLeft.label.parent.addChild(t), (e = this.game.make.graphics()).beginFill(16711680, 0), e.drawRect((this.btnLeft.width + 59) / -2, (this.btnLeft.height + 5) / -2, this.btnLeft.width + 34, this.btnLeft.height + 10), e.endFill(), e.inputEnabled = !0, e.events.onInputDown.add(this.leftTap, this), e.events.onInputUp.add(this.leftUnTap, this), this.btnLeft.label.parent.addChild(e), (t = this.game.add.image(0, 0, n.Atlases.Gameplay, "arrow_icon0000")).anchor.set(.5), t.scale.set(.85), this.btnRight = new a.default(this.game, "", {}, function() {}, this, n.Atlases.Gameplay), this.btnRight.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.btnRight.x = 185, this.btnRight.y = 415, this.btnRight.sScale = .57, this.btnRight.btn.alpha = .9, this.container.addChild(this.btnRight), this.btnRight.label.parent.addChild(t), (e = this.game.make.graphics()).beginFill(16711680, 0), e.drawRect((this.btnRight.width + 59) / -2, (this.btnRight.height + 5) / -2, this.btnRight.width + 34, this.btnRight.height + 10), e.endFill(), e.inputEnabled = !0, e.events.onInputDown.add(this.rightTap, this), e.events.onInputUp.add(this.rightUnTap, this), this.btnRight.label.parent.addChild(e)
        }, r.prototype.upTap = function() {
            this.btnUp.onDownLabel(), this._isbtnUp = !0
        }, r.prototype.leftTap = function() {
            this.btnLeft.onDownLabel(), this.btnLeftDownTime = this.game.time.time, this._isbtnLeft = !0
        }, r.prototype.rightTap = function() {
            this.btnRight.onDownLabel(), this.btnRightDownTime = this.game.time.time, this._isbtnRight = !0
        }, r.prototype.ZTap = function() {
            this._isbtnZ = !0
        }, r.prototype.XTap = function() {
            this._isbtnX = !0
        }, r.prototype.upUnTap = function() {
            this.btnUp.onOut(), this._isbtnUp = !1
        }, r.prototype.leftUnTap = function() {
            this.btnLeft.onOut(), this.btnLeftUpTime = this.game.time.time, this._isbtnLeft = !1
        }, r.prototype.rightUnTap = function() {
            this.btnRight.onOut(), this.btnRightUpTime = this.game.time.time, this._isbtnRight = !1
        }, r.prototype.ZUnTap = function() {
            this._isbtnZ = !1
        }, r.prototype.XUnTap = function() {
            this._isbtnX = !1
        }, r.prototype.resize = function(t) {
            var e;
            this.container.parent && this.container.parent.parent, this.container && (this.container.scale.set(t), e = 0, 1 <= t && this.game.width > n.Constants.WIDTH && (e = .5 * (this.game.width - n.Constants.WIDTH) / this.container.parent.scale.x), this.btnUp.x = 725 + e, this.btnUp.y = 427, this.btnZ.x = 745 + e, this.btnZ.y = 327, this.btnDown.x = 615 + e, this.btnDown.y = 427, this.btnLeft.x = 75 - e, this.btnLeft.y = 415, this.btnRight.x = 185 - e, this.btnRight.y = 415)
        }, Object.defineProperty(r, "instance", {
            get: function() {
                return r._instance || (r._instance = new r), r._instance
            },
            enumerable: !0,
            configurable: !0
        }), r);

    function r() {
        this.container = null, this.keyLeft = null, this.keyRight = null, this.keyA = null, this.keyD = null, this.keyL = null, this.keyX = null, this.keyB = null, this.btnUp = null, this.btnZ = null, this.btnDown = null, this.btnLeft = null, this.btnLeftDownTime = 0, this.btnLeftUpTime = 0, this.btnRight = null, this.btnRightDownTime = 0, this.btnRightUpTime = 0, this._isbtnZ = !1, this._isbtnK = !1, this._isbtnX = !1, this._isbtnL = !1, this._isbtnV = !1, this._isbtnB = !1, this._isbtnUp = !1, this._isbtnDown = !1, this._isbtnLeft = !1, this._isbtnRight = !1, this._isbtnLeftDouble = !1, this._isbtnRightDouble = !1, this._isbtnADouble = !1, this._isbtnDDouble = !1
    }
    e.default = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    i = i(0), s.dataLoadedSignal = new i.Signal, s.PlayerSignal = new i.Signal, s.SensorSignal = new i.Signal, s.MatchProcessorSignal = new i.Signal, s.MatchEndSignal = new i.Signal, s.EventSignal = new i.Signal, i = s;

    function s() {}
    e.Signals = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.getInstance = function() {
        return null === n.instance && (n.instance = new n), n.instance
    }, n.prototype.checkDomain = function(t) {
        for (var e = 0; e < this.brandDomains.length; e++) {
            var i = this.brandDomains[e];
            if (-1 !== t.indexOf(i)) return !0
        }
        return !1
    }, n.prototype.getUrlLock = function() {
        return null !== n.Current ? this.brandInstances[n.Current] : ""
    }, n.prototype.getUrl = function(t) {
        return this.brandInstances[t]
    }, n.instance = null, n.YEP10 = "yep10", n.Current = n.YEP10, n.Google = "google", n.Apple = "itunes", n);

    function n() {
        this.brandInstances = {}, this.brandDomains = [], this.brandInstances[n.YEP10] = "http://yep10.com/?utm_source=bb_2019", this.brandInstances[n.Google] = "https://play.google.com/store/apps/details?id=air.com.madpuffers.football", this.brandInstances[n.Apple] = "https://itunes.apple.com/us/app/euro-football-legends/id1124042258&utm_source=flash_fl2016&utm_medium=banner&utm_campaign=football_legends_ios", n.Current = n.YEP10, this.brandDomains = [], this.brandDomains.push("y8.com"), this.brandDomains.push("id.net"), this.brandDomains.push("pog.com"), this.brandDomains.push("gamepost.com"), this.brandDomains.push("dollmania.com"), this.brandDomains.push("madpuffers.com"), this.brandDomains.push("localhost:")
    }
    e.default = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(1),
        r = i(4),
        h = i(9),
        l = i(0),
        n = (a = Phaser.Graphics, n(c, a), c);

    function c(t, e, i) {
        void 0 === i && (i = null);
        var s = a.call(this, t) || this;
        return t.add.existing(s), e.backgroundBase && (t = s.game.make.sprite(0, 0, o.Atlases.Preloader, h.default.BASE_BG[h.default.INDEX_BG + 1 === 3 ? 0 : h.default.INDEX_BG + 1] + "0000"), e.backgroundBase.addChildAt(t, 0), t.alpha = .5, (t = s.game.add.tween(t)).to({
            alpha: 1
        }, r.default.PRELOADER_TIME_HALF, l.Easing.Linear.None), t.start(), h.default.INDEX_BG++, h.default.INDEX_BG >= h.default.BASE_BG.length && (h.default.INDEX_BG = 0), e.backgroundBaseMask && (e.backgroundBase.mask = e.backgroundBaseMask)), null !== i && i.call(e), s
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(7),
        l = i(17),
        c = i(9),
        u = i(2),
        d = i(10),
        p = i(16),
        f = i(11),
        g = i(8),
        m = i(32),
        y = i(26),
        b = i(12),
        v = i(33),
        _ = i(4),
        x = i(0),
        n = (a = Phaser.State, n(w, a), w.prototype.init = function() {
            this.game.world.removeAll()
        }, w.prototype.create = function() {
            a.prototype.create.call(this), this.background = this.game.add.sprite(0, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, c.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.background4 = this.game.add.sprite(400, 290, r.Atlases.Interface, "bg0000");
            var t = null;
            (t = this.game.add.sprite(-185, 66, r.Atlases.Interface, "body00000")).anchor.set(.5), this.background4.addChild(t), (t = this.game.add.sprite(230, 55, r.Atlases.Interface, "body10000")).anchor.set(.5), this.background4.addChild(t), (t = this.game.add.sprite(0, 15, r.Atlases.Interface, "0bg100000")).anchor.set(.5), t.scale.set(1.1, .9), this.background4.addChild(t), (t = this.game.add.sprite(-213, -50, r.Atlases.Interface, "head00000")).anchor.set(.5), t.scale.set(.95), this.background4.addChild(t), (t = this.game.add.sprite(215, -55, r.Atlases.Interface, "head10000")).anchor.set(.5), t.scale.set(.95), this.background4.addChild(t), this.background4.anchor.set(.5), this.playBtn1 = new g.default(this.game, "TOURNAMENT", r.Constants.stylePlay3, this.startTournament, this, r.Atlases.Interface), this.playBtn1.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn1.y = -110, this.playBtn1.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn1), this.playBtn1.scale.set(.75, 1), this.playBtn2 = new g.default(this.game, "RANDOM", r.Constants.stylePlay3, this.startRandom, this, r.Atlases.Interface), this.playBtn2.y = 0, this.playBtn2.label.parent.y = -50, this.playBtn2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn2.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn2);
            t = new g.default(this.game, "MATCH", r.Constants.stylePlay3, null, null, r.Atlases.Interface);
            t.label.parent.y = 50, t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#330099", 5, "#FF99FF", 10), t.inputEnableChildren = !0, this.playBtn2.label.addChild(t);
            t = new g.default(this.game, "TRAINING", r.Constants.stylePlay2, this.startTraining, this, r.Atlases.Interface);
            t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.y = 70, t.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(t), this.playBtn3 = new g.default(this.game, "BACK", r.Constants.stylePlay4, this.onBack, this, r.Atlases.Interface), this.playBtn3.setFrames("arrow0000", "arrow0000", "arrow0000", "arrow0000"), this.playBtn3.btn.btn.x = -110, this.playBtn3.setProp("#330099", 5, "#FF99FF", 10), this.playBtn3.x = 35, this.playBtn3.y = 130, this.background4.addChild(this.playBtn3), this.leaderBoardBtn = new h.default(this.game, "", null, this.onScoreList, this, r.Atlases.Interface), this.leaderBoardBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.leaderBoardBtn.sScale = .7, this.leaderBoardBtn.sLabelScale = .7;
            t = this.game.add.image(0, 0, r.Atlases.Interface, "lead_icon0000");
            t.anchor.set(.5), this.leaderBoardBtn.label.parent.addChild(t), this.achievmentBtn = new h.default(this.game, "", null, this.onAchievment, this, r.Atlases.Gameplay), this.achievmentBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000");
            t = this.game.add.image(0, 0, r.Atlases.Interface, "ach_icon0000");
            t.anchor.set(.5), this.achievmentBtn.label.parent.addChild(t), this.achievmentBtn.x = 730, this.achievmentBtn.y = 25, this.logo = this.game.add.sprite(400, 65, r.Atlases.Preloader, "logo0000"), this.logo.anchor.set(.5), this.backgroundBase2.addChild(this.logo), this.musicBtn = new h.default(this.game, "", {}, this.toggleMusic, this, r.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.achievmentBtn.sScale = this.musicBtn.sScale = 42 / this.musicBtn.btn.width, this.musicBtn.x = 772, this.musicBtn.y = 25, this.musicBtn.labelState = this.game.add.image(0, 0, r.Atlases.Gameplay, "InGameMusicButton0000"), this.backgroundBase2.addChild(this.musicBtn), this.branding2 = new h.default(this.game, "", null, this.onMoreGames, this, r.Atlases.Preloader), this.branding2.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.branding2.x = 698, this.branding2.y = 444, this.updateSoundButtons(), this.backgroundBase2.addChild(this.achievmentBtn), this.backgroundBase2.addChild(this.leaderBoardBtn), this.leaderBoardBtn.x = 730, this.leaderBoardBtn.y = 150, this.backgroundBase2.addChild(this.background4), this.backgroundBase2.addChild(this.branding2), this.leaderBoardBtn.visible = !1, this.resize(), new l.default(this.game, this, this.show)
        }, w.prototype.show = function() {
            var t = this.game.add.tween(this.background4);
            t.from({
                y: 800
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.logo)).from({
                y: -145
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).from({
                x: 1600
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.branding2)).from({
                x: 1600
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start()
        }, w.prototype.hide = function() {
            var t = this.game.add.tween(this.background4);
            t.to({
                y: 800
            }, _.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.logo)).to({
                y: -145
            }, _.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).to({
                x: 1600
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                x: 1600
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start()
        }, w.prototype.onMoreGames = function() {
            window.open(p.default.getInstance().getUrl(p.default.Current), "_blank")
        }, w.prototype.startTournament = function() {
            var t, e;
            o.default.getInstance().play(r.Sounds.Click), u.Inventory.instance.getTournament() ? (this.createPopup("0bg100000"), (t = this.popup.getChildAt(0)).alpha = .5, t.inputEnabled = !0, t.events.onInputDown.addOnce(this.disposePopup, this), (e = new g.default(this.game, "CONTINUE TOURNAMENT", r.Constants.styleTournamentPopup, this.startOLDTournament, this, r.Atlases.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#330099", 5, "#FF99FF", 10), e.y = -140, this.popup.getChildAt(1).addChild(e), (e = new g.default(this.game, "NEW TOURNAMENT", r.Constants.styleTournamentPopup, this.startNEWTournament, this, r.Atlases.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#330099", 5, "#FF99FF", 10), e.y = -65, this.popup.getChildAt(1).addChild(e), t = {
                font: "bold 28px Impact2",
                fill: "#FF99FF"
            }, (e = new d.default(this.game, 0, -10, "WARNING", t)).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (e = new d.default(this.game, 0, 20, "IF YOU CHOOSE", t)).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (e = new d.default(this.game, 0, 50, "NEW TOURNAMENT,", t)).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (e = new d.default(this.game, 0, 80, "YOU WILL LOST", t)).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (e = new d.default(this.game, 0, 110, "YOUR PROGRESS", t)).anchor.set(.5), this.popup.getChildAt(1).addChild(e), this.resize()) : this.startNEWTournament()
        }, w.prototype.startNEWTournament = function() {
            u.Inventory.instance.matchData.matchMode = 0, u.Inventory.instance.breakTournament(), new c.default(this.game, this, y.default.Name)
        }, w.prototype.startOLDTournament = function() {
            u.Inventory.instance.matchData.matchMode = 0, new c.default(this.game, this, b.TournamentState.Name)
        }, w.prototype.startRandom = function() {
            o.default.getInstance().play(r.Sounds.Click), u.Inventory.instance.matchData.resetScore(), u.Inventory.instance.gameMode = 1, new c.default(this.game, this, y.default.Name)
        }, w.prototype.startTraining = function() {
            o.default.getInstance().play(r.Sounds.Click), u.Inventory.instance.matchData.resetScore(), u.Inventory.instance.gameMode = 3, new c.default(this.game, this, b.Gameplay.Name)
        }, w.prototype.onScoreList = function() {
            o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.onAchievment = function() {
            o.default.getInstance().play(r.Sounds.Click), new c.default(this.game, this, v.default.Name)
        }, w.prototype.toggleMusic = function() {
            f.default.getInstance().music ? o.default.getInstance().toggleMusic() : f.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.updateSoundButtons = function() {
            var t = f.default.getInstance().music ? 0 : 1;
            t += f.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(r.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, w.prototype.onBack = function() {
            o.default.getInstance().play(r.Sounds.Click), new c.default(this.game, this, m.default.Name)
        }, w.prototype.disposePopup = function() {
            this.popup.destroy(), this.popup = null, this.popup_btn && (this.popup_btn.destroy(), this.popup_btn = null)
        }, w.prototype.backgroundPopup = function() {
            this.popup = this.game.add.sprite(350, 280, r.Atlases.Interface, "bg0000"), this.popup.anchor.set(.5), this.popup.scale.set(1.3);
            var t = this.game.add.sprite(0, 0, r.Atlases.Interface, "black0000");
            t.width = this.game.width + 500, t.height = this.game.height + 500, t.inputEnabled = !0, t.anchor.set(.5), this.popup.addChild(t)
        }, w.prototype.createPopup = function(t) {
            void 0 === t && (t = "0bg100000"), null !== this.popup && this.disposePopup(), this.backgroundPopup();
            var e = this.game.add.sprite(0, 0, r.Atlases.Interface, "bg0000");
            e.anchor.set(.5), e.inputEnabled = !0, this.popup.addChild(e);
            t = this.game.add.sprite(0, -30, r.Atlases.Interface, t);
            t.scale.set(1.8, 1), t.anchor.set(.5), e.addChild(t)
        }, w.prototype.resizePopup = function(t) {
            var e;
            null !== this.popup && ((e = this.popup.removeChildAt(0)).width = this.game.width + 500, e.height = this.game.height + 500, this.popup.x = this.world.bounds.centerX, this.popup.y = this.world.bounds.centerY, this.popup.addChildAt(e, 0), this.popup_btn && (this.popup_btn.x = this.world.bounds.centerX - 270 * t, this.popup_btn.y = this.world.bounds.centerY + 200 * t))
        }, w.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.background.scale.set(t), this.background.alignIn(this.backgroundBase2, Phaser.BOTTOM_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, this.resizePopup(t), a.prototype.resize.call(this)
        }, w.prototype.shutdown = function() {
            this.background = null, this.popup = null, this.popup_btn = null, this.playBtn1 = null, this.playBtn2 = null, this.playBtn3 = null, this.achievmentBtn = null, this.leaderBoardBtn = null, this.branding2 = null, this.musicBtn = null, a.prototype.shutdown.call(this)
        }, w.Name = "menu2", w);

    function w() {
        var t = a.call(this) || this;
        return t.name = w.Name, t.popup = null, t.popup_btn = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.ARENA = 0, n.BASKET = 1, n.BALL = 2, n.PLAYER = 3, n.SHADOW = 4, n.EFFECTS = 5, n.INFO = 6, n);

    function n() {}
    e.ObjectsType = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (f.normalizeAngle = function(t) {
        return t > Math.PI ? t -= 2 * Math.PI : t < -Math.PI && (t += 2 * Math.PI), t
    }, f.normalizeAngle2 = function(t) {
        return (t %= 2 * Math.PI) > Math.PI ? t -= 2 * Math.PI : t < -Math.PI && (t += 2 * Math.PI), t
    }, f.normalizeVertices = function(t) {
        var e = {};
        e.className = t.className, e.params = {}, e.params.vertices = [];
        var i, s = t.params,
            n = s.x,
            a = s.y;
        for (i in s) "vertices" !== i && (e.params[i] = s[i]);
        for (var o = f.TO_RAD * s.rotation, r = s.vertices, h = e.params.vertices, l = r.length, c = 0; c < l; c++) {
            var u, d = Math.round(r[c].x),
                p = Math.round(r[c].y);
            h[c] = {}, 0 === d && 0 === p ? (h[c].x = n, h[c].y = a) : (u = void 0, u = Math.atan2(p, d), p = Math.sqrt(d * d + p * p), u += o, h[c].x = n + Math.cos(u) * p, h[c].y = a + Math.sin(u) * p)
        }
        return e.params.x = 0, e.params.y = 0, e.params.rotation = 0, e
    }, f.dist = function(t, e, i, s) {
        return Math.sqrt((t - i) * (t - i) + (e - s) * (e - s))
    }, f.TO_RAD = Math.PI / 180, f.TO_DEG = 180 / Math.PI, f.PIdiv2 = Math.PI / 0, f.PIdiv4 = Math.PI / 4, f.PIdiv4mul3 = 3 * Math.PI / 4, f);

    function f() {}
    e.default = s;
    n.rand = function(t, e) {
        return t - .5 * e + e * Math.random()
    }, s = n;

    function n() {}
    e.MyRand = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.activate = function() {
        this.delta = 0, this.dispersion = Math.random() * this.range, this.delay = this.fixed + this.dispersion
    }, n.prototype.update = function(t) {
        return 0 <= this.delta ? (this.result = 0, this.delta += t, this.delta >= this.delay && (this.result = 1, this.delta = -1), this.result) : -1
    }, n.prototype.reset = function() {
        this.delta = -1
    }, n);

    function n(t, e) {
        void 0 === e && (e = 0), this.result = 0, this.delta = -1, this.fixed = e, this.range = t
    }
    e.FullDelay = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = nape.space.Space,
        r = i(28),
        h = i(23),
        l = nape.callbacks.CbEvent,
        c = nape.callbacks.InteractionListener,
        u = nape.callbacks.InteractionType,
        d = i(2),
        p = i(40),
        f = i(15),
        n = (a = r.GamePhysics, n(g, a), g.prototype.start = function() {
            g.hasListeners || this.setupListners()
        }, g.prototype.setupListners = function() {
            g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbGround, this.onBallGround)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbBorders, this.onBallBorder)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbBasket, this.onBallBasket)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbRing, this.onBallRing)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbShield, this.onBallShield)), g.space.listeners.add(new c(l.BEGIN, u.SENSOR, d.CbTypes.cbBall, d.CbTypes.cbPlayersHands, this.onBallHands)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbBall, d.CbTypes.cbPlayersBlock, this.onBallBlock)), g.space.listeners.add(new c(l.BEGIN, u.SENSOR, d.CbTypes.cbPlayersBlock, d.CbTypes.cbDownSensor, this.onBlockSensor)), g.space.listeners.add(new c(l.BEGIN, u.COLLISION, d.CbTypes.cbPlayer, d.CbTypes.cbGround, this.onPlayerGround)), g.space.listeners.add(new c(l.BEGIN, u.SENSOR, d.CbTypes.cbBall, d.CbTypes.cbUpperSensor, this.onUpperSensor)), g.space.listeners.add(new c(l.BEGIN, u.SENSOR, d.CbTypes.cbBall, d.CbTypes.cbDownSensor, this.onDownSensor)), g.hasListeners = !0
        }, g.prototype.onBallGround = function(t) {
            t.int1.castBody.userData.owner.onGroundCollision(!0)
        }, g.prototype.onBallBorder = function(t) {
            t.int1.castBody.userData.owner.onGroundCollision(!1)
        }, g.prototype.onBallRing = function(t) {
            var e = t.int1.castBody.userData.owner;
            e.setState("basket"), 0 < t.arbiters.length && t.arbiters.at(0).collisionArbiter.contacts.at(0).position.y < 198 && e.playSnd(1)
        }, g.prototype.onBallBasket = function(t) {
            t = t.int1.castBody.userData.owner;
            t.setState("basket"), t.playSnd(2)
        }, g.prototype.onBallBlock = function(t) {
            var e = t.int1.castBody.userData.owner,
                i = !1;
            t.int2.castShape.body && (i = 0 < (e.getX() - t.int2.castShape.worldCOM.x) * e.SIDE), t.int2.castShape.body && i && (t = t.int2.castShape.body.userData.owner, e.setState("block", t.SIDE), p.MatchProcessor.instance.block(t.SIDE, t.isHuman), f.Signals.EventSignal.dispatch(t.isHuman, 4))
        }, g.prototype.onBallHands = function(t) {
            var e = t.int2.castShape.body.userData.owner,
                i = e.SIDE,
                s = e.playerNo;
            e.canTakeInHands && t.int1.castBody.userData.owner.takeInHands(i, s)
        }, g.prototype.onBlockSensor = function(t) {
            t.int1.castShape.body && t.int1.castShape.body.userData.owner.removeBlock()
        }, g.prototype.onPlayerGround = function(t) {
            t.int1.castShape.body.userData.owner.onGroundCollision()
        }, g.prototype.onUpperSensor = function(t) {
            f.Signals.SensorSignal.dispatch(0, t.int2.castShape.body.userData.side)
        }, g.prototype.onDownSensor = function(t) {
            f.Signals.SensorSignal.dispatch(1, t.int2.castShape.body.userData.side), t.int1.castBody.userData.owner.onDownSensor()
        }, g.prototype.onBallShield = function(t) {
            var e = t.int2.castShape.body.userData.side;
            t.int1.castBody.userData.owner.onShieldCollision(e)
        }, g.prototype.update = function(t) {
            g.space.step(t)
        }, g.prototype.updateGraphics = function() {
            for (var t = g.space.liveBodies.iterator(); t.hasNext();) {
                var e = t.next(),
                    i = e.userData;
                i.graphic && ((i = i.graphic).x = e.position.x, i.y = e.position.y, i.rotation = e.rotation % (2 * Math.PI))
            }
        }, g.prototype.add = function(t) {
            t.body && (t.body.space = g.space)
        }, g.prototype.release = function() {
            for (; !g.space.bodies.empty();) h.NapeUtil.disposeBody(g.space.bodies.at(0));
            a.prototype.release.call(this), g.space.clear(), g.space = null, g.hasListeners = !1
        }, g.hasListeners = !1, g.isGoal = !1, g);

    function g() {
        var t = a.call(this) || this;
        return g.space = new o(d.ObjectsData.GRAVITY), t
    }
    e.NapePhysics = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var o = i(20),
        s = nape.constraint.PivotJoint,
        p = nape.geom.GeomPoly,
        n = nape.geom.GeomPolyList,
        f = nape.geom.Vec2,
        g = nape.phys.Body,
        i = nape.phys.BodyList,
        m = nape.phys.BodyType,
        l = nape.shape.Circle,
        y = nape.shape.Polygon,
        i = (d.disposeBody = function(t) {
            d.clearUserData(t), t.cbTypes.clear(), t.compound ? t.compound = null : t.space = null
        }, d.resetStartPos = function(t) {
            t.position.x = t.userData.sx, t.position.y = t.userData.sy, t.rotation = t.userData.sr
        }, d.clearUserData = function(t) {
            for (var e in t.userData) t.userData.hasOwnProperty(e) && (t.userData[e] = null)
        }, d.createRectBody = function(t, e, i, s, n, a) {
            void 0 === n && (n = null), void 0 === a && (a = null);
            e = new y(y.box(s.width, s.height, !0), a, e);
            e.sensorEnabled = i;
            n = d.createBody(t, s.x, s.y, o.default.TO_RAD * s.rotation, n);
            return n.shapes.add(e), n
        }, d.createRectBodyWH = function(t, e, i, s, n, a, o, r, h, l) {
            void 0 === a && (a = 0), void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === h && (h = null), void 0 === l && (l = null);
            e = new y(y.box(s, n, !0), l, e);
            e.sensorEnabled = i;
            h = d.createBody(t, a, o, r, h);
            return h.shapes.add(e), h
        }, d.createRegularBody = function(t, e, i, s, n, a, o, r, h, l, c) {
            void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === h && (h = 0), void 0 === l && (l = null), void 0 === c && (c = null);
            e = new y(y.regular(.5 * s, .5 * n, a, 0, !0), c, e);
            e.sensorEnabled = i;
            l = d.createBody(t, o, r, h, l);
            return l.shapes.add(e), l
        }, d.createBody = function(t, e, i, s, n) {
            void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = null);
            i = new g(t, f.weak(e, i));
            return i.rotation = s, null != n && i.cbTypes.add(n), i
        }, d.createCircleBody = function(t, e, i, s, n, a, o, r, h) {
            void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === o && (o = 0), void 0 === r && (r = null), void 0 === h && (h = null);
            e = new l(s, null, h, e);
            e.sensorEnabled = i;
            o = d.createBody(t, n, a, o, r);
            return null != r && o.cbTypes.add(r), o.shapes.add(e), o
        }, d.bodiesInCircle = function(t, e, i, s, n) {
            return void 0 === s && (s = !1), void 0 === n && (n = null), d.bodyList.clear(), t.bodiesInCircle(e, i, s, n, d.bodyList), d.bodyList
        }, d.bodiesUnderPoint = function(t, e, i) {
            return void 0 === i && (i = null), d.bodyList.clear(), t.bodiesUnderPoint(e, i, d.bodyList), d.bodyList
        }, d.createPolyBody = function(t, e, i, s) {
            for (var n, a = t instanceof Array ? (n = t, new g(s)) : (n = t.vertices, new g(s, f.weak(t.x, t.y))), o = n.length, r = [], h = 0; h < o; h++) r[h] = f.get(n[h].x, n[h].y);
            var l = new p(r);
            if (l.isConvex()) a.shapes.add(new y(l, e, i)), l.dispose();
            else
                for (l.convexDecomposition(!1, d.geomPolyList), l.dispose(); !d.geomPolyList.empty();) l = d.geomPolyList.pop(), a.shapes.add(new y(l, e, i)), l.dispose();
            return a
        }, d.createPolyShape = function(t, e, i, s, n) {
            for (var a = e.vertices, o = a.length, r = [], h = 0; h < o; h++) r.push(f.get(e.x + a[h].x, e.y + a[h].y));
            var l = new p(r);
            if (l.isConvex()) {
                var c = new y(l, i, s);
                c.cbTypes.add(n), t.shapes.add(c), l.dispose()
            } else
                for (l.convexDecomposition(!1, d.geomPolyList), l.dispose(); !d.geomPolyList.empty();) {
                    l = d.geomPolyList.pop();
                    var u = new y(l, i, s);
                    u.cbTypes.add(n), t.shapes.add(u), l.dispose()
                }
        }, d.createSensor = function(t, e, i) {
            var s = new y(y.rect(e.x, e.y - e.height / 2, e.width, e.height));
            s.sensorEnabled = !0, s.cbTypes.add(i), s.userData.id = e.id, t.shapes.add(s)
        }, d.createPivot = function(t, e, i) {
            return new s(t, e, t.worldPointToLocal(i, !0), e.worldPointToLocal(i, !0))
        }, d.disposeJoint = function(t) {
            t.active = !1, t.space = null, t.body1 = null, t.body2 = null
        }, d.createPatherBody = function(t, e, i, s) {
            (e = e.copy()).density = t.params.density;
            for (var n, a = new g(t.params.isStatic ? m.STATIC : m.DYNAMIC, f.weak(t.params.x, t.params.y)), o = [f.get(), f.get(), f.get(), f.get()], r = f.get(), h = f.get(), l = t.params.vertices, c = l.length, u = 0; u < c - 1; u++) {
                r.setxy(l[u + 1].x - l[u].x, l[u + 1].y - l[u].y), 0 === u ? (n = r.angle + .5 * Math.PI, o[0].x = l[u].x - .5 * s * Math.cos(n), o[0].y = l[u].y - .5 * s * Math.sin(n), o[1].x = l[u].x + .5 * s * Math.cos(n), o[1].y = l[u].y + .5 * s * Math.sin(n)) : (o[0].x = o[3].x, o[0].y = o[3].y, o[1].x = o[2].x, o[1].y = o[2].y), u === c - 2 ? (n = r.angle + .5 * Math.PI, o[3].x = l[u + 1].x - .5 * s * Math.cos(n), o[3].y = l[u + 1].y - .5 * s * Math.sin(n), o[2].x = l[u + 1].x + .5 * s * Math.cos(n), o[2].y = l[u + 1].y + .5 * s * Math.sin(n)) : (r.muleq(-1 / r.length), h.setxy(l[u + 2].x - l[u + 1].x, l[u + 2].y - l[u + 1].y), h.muleq(1 / h.length), n = (d = f.get(r.x + h.x, r.y + h.y)).angle, o[3].x = l[u + 1].x - .5 * s * Math.cos(n), o[3].y = l[u + 1].y - .5 * s * Math.sin(n), o[2].x = l[u + 1].x + .5 * s * Math.cos(n), o[2].y = l[u + 1].y + .5 * s * Math.sin(n), d.dispose());
                var d;
                new p(o).isConvex() || (d = o[3], o[3] = o[2], o[2] = d), new y(o, e, i).body = a
            }
            return r.dispose(), h.dispose(), o[0].dispose(), o[1].dispose(), o[2].dispose(), o[3].dispose(), o = null, a.align(), a
        }, d.geomPolyList = new n, d.bodyList = new i, d);

    function d() {}
    e.NapeUtil = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(37),
        n = i(69),
        a = i(70),
        o = i(71),
        r = i(72),
        h = i(74),
        i = (l.prototype.initManagers = function() {
            this.achievsMgr = new r.AchievsDataManager(this.save, this.ACHIEVS, !this.isLocal), this.achievsMgr.signalSave.add(s.default.getInstance().save, s.default.getInstance()), this.statsMgr = new h.StatsDataManager(this.save, this.STATS, !this.isLocal, this.achievsMgr), this.statsMgr.signalSave.add(s.default.getInstance().save, s.default.getInstance())
        }, Object.defineProperty(l, "instance", {
            get: function() {
                return null === l._instance && (l._instance = new l), l._instance
            },
            enumerable: !0,
            configurable: !0
        }), l.prototype.init = function() {
            var t;
            this.inited || (this.inited = !0, this.save = {}, t = this.save[l.LAST_ENTER], this.save[l.LAST_ENTER] = Date.now(), t || (this.firstEnter = !0), this.gameMode = 0, this.currentScore = 0, this.clearWin = 0, this.losesCount = 0, this.localGamesCount = 0, this.prevShowForum = 0, l.instance.initManagers())
        }, l.prototype.saveTournament = function() {
            var t = this.tournament.getValues(),
                e = this.SAVE;
            this.save[e] = t, s.default.getInstance().save()
        }, l.prototype.getTournament = function() {
            var t = this.SAVE,
                t = this.save[t];
            return !!t && (this.tournament.setValues(t), !0)
        }, l.prototype.breakTournament = function() {
            this.clearTournamentData(), this.clearTournamentSave()
        }, l.prototype.clearTournamentData = function() {
            this.tournament.resetAll()
        }, l.prototype.clearTournamentSave = function() {
            var t = this.SAVE;
            delete this.save[t], s.default.getInstance().save()
        }, l.prototype.reset = function() {
            this.inited = !1, this.init()
        }, l.prototype.checkQuickMatch = function() {
            return 3 === this.gameMode
        }, l.prototype.isFinal = function() {
            return this.team === this.rounds[28] || this.team === this.rounds[29]
        }, l.prototype.summarizeMatch = function() {
            var t;
            0 === this.gameMode && (this.matchScores = o.ScoresCalculator.calcScores(this.matchData.matchScore, this.tournament.state, this.tournament.difficulty, this.tournament.isSecondPlace()), this.tournament.scores += this.matchScores, this.statsMgr.updateScore(this.tournament.scores, this.tournament.mode), t = this.matchData.matchScore[0], this.tournament.points += t, this.achievsMgr.updateData(7, t), 1 === this.tournament.difficulty && this.achievsMgr.updateData(8, t))
        }, l.prototype.checkForumAchievement = function() {
            this.achievsMgr.updateData(12)
        }, Object.defineProperty(l.prototype, "firstRun", {
            get: function() {
                return !this.save.hasOwnProperty("firstRun") || this.save.firstRun
            },
            set: function(t) {
                this.save.firstRun = t, s.default.getInstance().save()
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "firstRun2", {
            get: function() {
                return !this.save.hasOwnProperty("firstRun2") || this.save.firstRun2
            },
            set: function(t) {
                this.save.firstRun2 = t, s.default.getInstance().save()
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "rounds", {
            get: function() {
                return this.tournament.rounds
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "results", {
            get: function() {
                return this.tournament.results
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "opponent", {
            get: function() {
                return this.tournament.opponent
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "team", {
            get: function() {
                return this.tournament.team
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "teamNo", {
            get: function() {
                return this.tournament.teamRound
            },
            enumerable: !0,
            configurable: !0
        }), l.prototype.nextLeg = function() {
            var t = "Standings";
            this.calcVars();
            var e = this.tournament.generateResults(this.startId, this.endId, this.isFinalLegs, this.matchData.matchScore);
            if (this.tournament.state++, this.summarizeMatch(), 4 === this.tournament.state) this.summarizeTournament(!0), t = "Final";
            else if (e) this.tournament.defineOpponent(), this.saveTournament(), t = "Standings";
            else {
                for (var i = this.tournament.state; i < 4; i++) this.calcVars(), this.tournament.generateResults(this.startId, this.endId, this.isFinalLegs), this.tournament.state++;
                this.summarizeTournament(!1), t = "Final"
            }
            return [e, t]
        }, l.prototype.calcVars = function() {
            this.isFinalLegs = !1;
            var t = this.tournament.state;
            0 === t ? (this.startId = 0, this.endId = 8) : 1 === t ? (this.startId = 8, this.endId = 12) : (2 === t ? (this.startId = 12, this.endId = 14) : (this.startId = 14, this.endId = 16), this.isFinalLegs = !0)
        }, l.prototype.summarizeTournament = function(t) {
            var e = this.tournament.getPlace();
            t && e < 4 && (this.achievsMgr.updateData(14 + 3 * this.tournament.mode + e), 1 === e && (17 === this.tournament.team && this.achievsMgr.updateData(11), 1 === this.tournament.difficulty && this.achievsMgr.updateData(13 + this.tournament.mode))), this.achievsMgr.updateData(9, this.tournament.points), 1 === this.tournament.difficulty && this.achievsMgr.updateData(10, this.tournament.points)
        }, l.prototype.breakMatch = function() {
            0 === this.gameMode && this.breakTournament(), this.matchData.finishMatch(this.gameMode)
        }, l.prototype.getTitleFrame = function() {
            var t = -1 === this.matchData.whoWins();
            return 4 !== this.gameMode || 2 === this.matchData.matchMode ? t ? 1 : 2 : t ? 3 : 4
        }, l.prototype.isPvP = function() {
            return 4 === this.gameMode && this.matchData.matchMode < 2
        }, l.prototype.createNewTournament = function() {
            this.tournament.createNewTournament(this.matchData), this.saveTournament()
        }, l.prototype.startTournamentMatch = function() {
            this.matchData.startTournamentMatch(this.tournament)
        }, l.prototype.showAdditionalGUI = function() {
            0 === this.gameMode && this.matchData.matchScore[0] <= this.matchData.matchScore[1] && this.losesCount++, this.isLocal && this.notLogged && this.localGamesCount++;
            var t = Date.now();
            return 3 <= this.losesCount && (0 === this.prevShowForum || t - this.prevShowForum >= this.timeToShowAdditionalGUI) ? (this.prevShowForum = t, this.losesCount = 0, 1) : 3 <= this.localGamesCount && (0 === this.prevShowRegister || t - this.prevShowRegister >= this.timeToShowAdditionalGUI) ? (this.prevShowRegister = t, this.localGamesCount = 0, 2) : 0
        }, l.prototype.getAchievsArray = function() {
            return this.achievsMgr.getValuesForRead()
        }, l.prototype.getMatchScores = function() {
            return this.matchScores
        }, l.prototype.getTournamentScores = function() {
            return this.tournament.scores
        }, l.prototype.getTotalScores = function() {
            return this.statsMgr.getTotalScores()
        }, l.LAST_ENTER = "l_e", l._instance = null, l);

    function l() {
        if (this.nickNames = ["points3", "dunks", "fromBlock", "buzzer", "blocks", "steals", "scores", "pointsM", "pointsMH", "pointsT", "pointsTH", "idNet", "forum", "GC1", "SC1", "BC1", "GC2", "SC2", "BC2", "GC1H", "GC2H"], this.save = null, this.firstEnter = !1, this.inited = !1, this.isLocal = !0, this.gameMode = 0, this.matchData = null, this.tournament = null, this.currentScore = 0, this.clearWin = 0, this.losesCount = 0, this.localGamesCount = 0, this.prevShowForum = 0, this.SAVE = "tsave", this.ACHIEVS = "achievs", this.STATS = "stats", this.outInfo = "", this.timeToShowAdditionalGUI = 18e5, this.notLogged = !0, null !== l._instance) throw new Error("Signleton: Must be only one Object");
        this.isLocal = !0, this.matchData = new n.MatchData(this.isLocal), this.tournament = new a.TournamentData, this.matchData.matchMode = 0
    }
    e.Inventory = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.playerOnGround = function() {}, n.prototype.playerOnBlock = function() {}, n.prototype.ballInOwnHands = function(t) {
        void 0 === t && (t = 0)
    }, n.prototype.ballInOpponentsHands = function(t) {
        void 0 === t && (t = 0)
    }, n.prototype.ballOwnShoot = function(t) {
        void 0 === t && (t = 0)
    }, n.prototype.ballOpponentShoot = function(t) {
        void 0 === t && (t = 0)
    }, n.prototype.ballOthers = function() {}, n.prototype.readyForAction = function() {
        return !1
    }, n.prototype.releaseBlockOrPump = function(t) {
        return !1
    }, n.prototype.restart = function(t) {}, n.prototype.update = function(t) {}, n.prototype.dispose = function() {
        this.player = null
    }, n);

    function n(t) {
        this.type = -1, this.player = t, this.SIDE = t.SIDE
    }
    e.BaseController = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(7),
        l = i(17),
        c = i(9),
        u = i(2),
        d = i(10),
        p = i(11),
        f = i(8),
        g = i(31),
        m = i(18),
        y = i(102),
        b = i(51),
        v = i(12),
        _ = i(4),
        x = i(0),
        n = (a = Phaser.State, n(w, a), w.prototype.init = function() {
            this.game.world.removeAll(), this.manager = u.Inventory.instance, dragonBones.PhaserFactory.init(this.game)
        }, w.prototype.create = function() {
            a.prototype.create.call(this);
            var t = this.game.cache.getJSON(r.JSONData.DBPers),
                e = this.game.cache.getJSON(r.JSONData.DBPers_Texture),
                i = this.game.cache.getImage(r.Images.DBPers, !0).base;
            dragonBones.PhaserFactory.factory.parseDragonBonesData(t), dragonBones.PhaserFactory.factory.parseTextureAtlasData(e, i), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, c.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.background5 = this.game.add.sprite(600, 240, r.Atlases.Interface, "bg0000"), this.background4 = this.game.add.sprite(200, 240, r.Atlases.Interface, "bg0000"), this.background5.anchor.set(.5), this.background4.anchor.set(.5), this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay.x = -50, this._armatureDisplay.y = 90, this._armatureDisplay.animation.play("idle", 0), this._armatureDisplay2 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay2.x = 50, this._armatureDisplay2.y = 90, this._armatureDisplay2.animation.play("idle", 0), this._armatureDisplay3 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay3.x = -50, this._armatureDisplay3.y = 90, this._armatureDisplay3.animation.play("idle", 0), this._armatureDisplay4 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay4.x = 50, this._armatureDisplay4.y = 90, this._armatureDisplay4.animation.play("idle", 0), this.selectPlayer = new y.SelectPlayer(0, this._armatureDisplay.armature, this._armatureDisplay2.armature), this.selectPlayer.x = 162, this.selectPlayer.y = 131, this.backgroundBase2.addChild(this.selectPlayer), this.musicBtn = new h.default(this.game, "", {}, this.toggleMusic, this, r.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.musicBtn.sScale = 42 / this.musicBtn.btn.width, this.musicBtn.x = 772, this.musicBtn.y = 25, this.musicBtn.labelState = this.game.add.image(0, 0, r.Atlases.Gameplay, "InGameMusicButton0000"), this.backgroundBase2.addChild(this.musicBtn), this.backgroundBase2.addChild(this.background4), this.updateSoundButtons(), (this.manager.matchData.matchMode = 0) === this.manager.gameMode ? (0 === this.manager.matchData.matchMode && (this.createPanel(), this.createDifficultySelect()), this.selectPlayer.setUp(0)) : (this.createP2Select(), this.createPanel(), 0 === this.manager.matchData.matchMode && 4 !== u.Inventory.instance.gameMode ? (this.selectPlayer.setUp(), this.selectPlayer2.setUp(2)) : 1 === this.manager.matchData.matchMode ? (this.selectPlayer.setUp(1), this.selectPlayer2.setUp(2)) : (this.selectPlayer.setUp(), this.selectPlayer2.setUp())), this.logo = this.game.add.sprite(400, 35, r.Atlases.Interface, "bg0000"), this.logo.anchor.set(.5);
            i = "RANDOM MATCH";
            4 === u.Inventory.instance.gameMode ? i = "2 PLAYERS MATCH" : 0 === u.Inventory.instance.gameMode && (i = "TOURNAMENT", u.Inventory.instance.tournament.state = 0);
            i = new f.default(this.game, i, r.Constants.styleTitle2, null, null, r.Atlases.Interface);
            i.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), i.setProp("#330099", 7, "#FF99FF", 15), this.logo.addChild(i), this.logo.x = 400, this.backgroundBase2.addChild(this.logo), 0 === u.Inventory.instance.gameMode ? (this.playBtn = new f.default(this.game, "NEXT", r.Constants.stylePlayGreen, this.onTournament, this, r.Atlases.Interface), this.playBtn.setFrames("arrow20000", "arrow20000", "arrow20000", "arrow20000"), this.playBtn.btn.btn.x = 110, this.playBtn.x = 646) : (this.playBtn = new f.default(this.game, "PLAY", r.Constants.stylePlayGreen, this.onPlay, this, r.Atlases.Interface), this.playBtn.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn.x = 716), this.playBtn.y = 450, this.background4.addChild(this.playBtn), this.playBtn.setProp("#000000", 7, "#FFFFFF", 15), this.backBtn = new f.default(this.game, "BACK", r.Constants.styleBackArrow, this.onBack, this, r.Atlases.Interface), this.backBtn.setFrames("arrow0000", "arrow0000", "arrow0000", "arrow0000"), this.backBtn.btn.btn.x = -110, this.backBtn.setProp("#330099", 7, "#FF99FF", 15), this.backBtn.x = 150, this.backBtn.y = 450, this.backgroundBase2.addChild(this.backBtn), this.backgroundBase2.addChild(this.playBtn), this.resize(), new l.default(this.game, this, this.show)
        }, w.prototype.show = function() {
            var t = this.game.add.tween(this.logo);
            t.from({
                y: -60
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.selectPlayer)).from({
                x: -520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), this.selectPlayer2 && ((t = this.game.add.tween(this.selectPlayer2)).from({
                x: 1140
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start()), this.plateDifficulty && ((t = this.game.add.tween(this.plateDifficulty)).from({
                y: 720
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start()), (t = this.game.add.tween(this.playBtn)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.backBtn)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), this.matchModePanel && ((t = this.game.add.tween(this.matchModePanel)).from({
                y: 720
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start())
        }, w.prototype.hide = function() {
            var t = this.game.add.tween(this.logo);
            t.to({
                y: -60
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.selectPlayer)).to({
                x: -520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), this.selectPlayer2 && ((t = this.game.add.tween(this.selectPlayer2)).to({
                x: 1140
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start()), this.plateDifficulty && ((t = this.game.add.tween(this.plateDifficulty)).to({
                y: 720
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start()), (t = this.game.add.tween(this.playBtn)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.backBtn)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), this.matchModePanel && ((t = this.game.add.tween(this.matchModePanel)).to({
                y: 720
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start())
        }, w.prototype.render = function() {
            dragonBones.PhaserFactory.factory.dragonBones.advanceTime(-1), a.prototype.render.call(this)
        }, w.prototype.createPanel = function() {
            this.matchModePanel = new b.MatchModePanel(this), this.matchModePanel.x = 400, this.matchModePanel.y = 207, this.backgroundBase2.addChild(this.matchModePanel), this.processMatchMode()
        }, w.prototype.createDifficultySelect = function() {
            this.plateDifficulty = this.game.add.sprite(400, 370, r.Atlases.Interface, "bg0000"), this.plateDifficulty.anchor.set(.5);
            var t = this.game.make.image(0, 0, r.Atlases.Interface, "0bg130000");
            t.anchor.set(.5), t.scale.set(1, .42), this.plateDifficulty.addChild(t), (t = this.game.make.image(0, 0, r.Atlases.Interface, "line0000")).anchor.set(.5), t.scale.set(1), this.plateDifficulty.addChild(t);
            var e = new d.default(this.game, 0, -26, "NORMAL", r.Constants.styleDIfficulltyBg);
            e.anchor.set(.5), this.plateDifficulty.addChild(e);
            t = new d.default(this.game, 0, 26, "HARD", r.Constants.styleDIfficulltyBg2);
            t.anchor.set(.5), this.plateDifficulty.addChild(t), e.inputEnabled = !0, t.inputEnabled = !0, e.input.useHandCursor = !0, t.input.useHandCursor = !0;
            var i = new f.default(this.game, "NORMAL", r.Constants.styleNormalGreen, null, null, r.Atlases.Interface);
            i.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), i.setProp("#000000", 3, "#FFFFFF", 5);
            var s = new f.default(this.game, "HARD", r.Constants.styleHardGreen, null, null, r.Atlases.Interface);
            s.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), s.setProp("#000000", 3, "#FFFFFF", 5), this.backgroundBase2.addChild(this.plateDifficulty), this.plateDifficulty.addChild(i), this.plateDifficulty.addChild(s), i.y = -26, s.y = 26, s.visible = !1, u.Inventory.instance.tournament.difficulty = 0, t.events.onInputDown.add(function() {
                s.visible = !0, i.visible = !1, u.Inventory.instance.tournament.difficulty = 1
            }), e.events.onInputDown.add(function() {
                i.visible = !0, s.visible = !1, u.Inventory.instance.tournament.difficulty = 0
            })
        }, w.prototype.createP2Select = function() {
            this.selectPlayer2 = new y.SelectPlayer(1, this._armatureDisplay3.armature, this._armatureDisplay4.armature), this.selectPlayer2.x = 638, this.selectPlayer2.y = 131, this.backgroundBase2.addChild(this.selectPlayer2)
        }, w.prototype.processMatchMode = function() {
            var t, e;
            0 === this.manager.matchData.matchMode && (t = 0 === this.manager.matchData.players[0][0] ? 0 : 1, e = 0 === this.manager.matchData.players[1][0] ? 0 : 1, this.manager.matchData.players = [
                [t],
                [e]
            ]), 0 !== this.manager.gameMode ? 2 === this.manager.matchData.matchMode ? (this.selectPlayer.setUp(1), this.selectPlayer2.setUp(2)) : (this.selectPlayer.setUp(), this.selectPlayer2.setUp(4 === this.manager.gameMode ? 0 : 2)) : this.selectPlayer.setUp(0)
        }, w.prototype.toggleMusic = function() {
            p.default.getInstance().music ? o.default.getInstance().toggleMusic() : p.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.updateSoundButtons = function() {
            var t = p.default.getInstance().music ? 0 : 1;
            t += p.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(r.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, w.prototype.onBack = function() {
            o.default.getInstance().play(r.Sounds.Click), 0 === u.Inventory.instance.gameMode ? new c.default(this.game, this, m.default.Name) : new c.default(this.game, this, v.Menu.Name)
        }, w.prototype.onPlay = function() {
            o.default.getInstance().play(r.Sounds.Click), new c.default(this.game, this, g.default.Name)
        }, w.prototype.onTournament = function() {
            o.default.getInstance().play(r.Sounds.Click), this.manager.createNewTournament(), new c.default(this.game, this, v.TournamentState.Name)
        }, w.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, this.background5.scale.set(.65 * t), this.background5.alignIn(this.backgroundBase2, Phaser.RIGHT_CENTER, -20, 0), a.prototype.resize.call(this)
        }, w.prototype.shutdown = function() {
            this.backBtn = null, this.playBtn = null, this.musicBtn = null, this._armatureDisplay = null, this._armatureDisplay2 = null, this._armatureDisplay3 = null, this._armatureDisplay4 = null, a.prototype.shutdown.call(this)
        }, w.Name = "randomstate", w);

    function w() {
        var t = a.call(this) || this;
        return t.name = w.Name, t._armatureDisplay = null, t._armatureDisplay2 = null, t._armatureDisplay3 = null, t._armatureDisplay4 = null, t.manager = null, t
    }
    e.default = n
}, function(t, e) {
    var i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.add = function(t) {}, n.prototype.release = function() {}, n.prototype.update = function(t) {}, n.prototype.updateGraphics = function() {}, n.prototype.start = function() {}, n);

    function n() {}
    e.GamePhysics = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.geom.Vec2,
        i = i(4),
        i = (n.GRAVITY = new s(0, 450), n.BALL_RADIUS = 18, n.BALL_GRAVMASS = 2, n.BALL_BOUNCE = -400, n.BALL_UP_VELOCITY_Y = -500, n.BALL_STEAL_VELOCITY_X_BASE = 400, n.BALL_STEAL_VELOCITY_X_ADD = 200, n.BALL_STEAL_VELOCITY_Y = -100, n.BALL_INDENT_Y_CENTER = 300, n.BALL_INDENT_Y_PLAYER = 340, n.VERTICAL_DISPERSION = .1, n.DISPERSION = .01, n.BASKET_CENTER = (n.BASKET_INDENT = 25) + (n.BASKET_RADIUS = 30), n.BASKET_CENTER2 = i.default.WIDTH - n.BASKET_CENTER, n.BASKET_HEIGHT = 200, n.BASKET_PART_RADIUS = 7, n.GLASS_WIDTH = 12, n.GLASS_Y = 20 - (n.GLASS_HEIGHT = 120), n.SENSOR_WIDTH = 2 * (n.SENSOR_HALF = 25), n.SENSOR_HEIGHT = 5, n.SENSOR_UP = -10, n.SENSOR_DOWN = 15, n.PLAYER_JUMP = -600, n.PLAYER_MOVE_WITH_BALL = .85 * (n.PLAYER_MOVE = 250), n.PLAYER_INDENT_X = 30, n.PLAYER_INDENT_Y = 385, n.STEAL_DISTANCE = 55, n.INDENT_GENERAL_X = 50, n.PAINT_START_X = 100, n.PAINT_MIDDLE_X = 200, n.DUNK_ZONE1_Y = 280, n.DUNK_ZONE2_Y = 300, n.DUNK_X = 100, n.DUNK_Y = 180, n.ALLEY_OOP_X = 160, n.ALLEY_OOP_Y = 150, n.SUPER_DASH_X1 = 150, n.SUPER_DASH_X2 = 650, n.SUPER_DASH_Y = 385, n.OPPONENT_DELTA = 60, n.IDEAL_JUMP_BALL_JUMP = .5, n.IDEAL_ATTACK_JUMP = .41, n.CHANCE_FOR_THREE = .2, n.CHANCE_FOR_THREE2 = .4, n.ATTACK_ZONE_START = 120, n.ATTACK_ZONE_END = 350, n.DASH_ZONE_START = 300, n.DASH_ZONE_END = 700, n.DEFENSE_POINT = 250, n.STEAL_DURATION = .3, n.THREE_POINTS_DISTANCE = 500, n.DASH_DELAY = 1, n.DIG_TIME = 3, n.ENERGY_TIME = 3, n);

    function n() {}
    e.ObjectsData = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(1),
        n = i(7),
        a = i(14),
        o = i(5),
        r = i(11),
        h = i(4),
        l = i(2),
        i = (c.prototype.release = function() {
            h.default.isDesktop || a.default.instance.container && a.default.instance.container.destroy(), this.game = null, this.helpBtn = null, this.pauseBtn = null, this.musicBtn = null, this.signalToggleMusic.removeAll(), this.signalRestart.removeAll(), this.signalPause.removeAll(), this.signalToggleMusic = null, this.signalRestart = null, this.signalPause = null, this.container.destroy(), this.container = null
        }, c.prototype.init = function(t, e) {
            this.container = t, this.game = e, this.scl = Math.max(this.game.width, this.game.height) / s.Constants.WIDTH, this.scl = 1 < this.scl ? 1 : this.scl, this.signalRestart = new Phaser.Signal, this.signalPause = new Phaser.Signal, this.signalToggleMusic = new Phaser.Signal, this.helpBtn = new n.default(this.game, "", {}, this.onHelp, this, s.Atlases.Gameplay), this.helpBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.helpBtn.sScale = 42 / this.helpBtn.btn.width * 1.33333, this.helpBtn.x = h.default.GAME_W - Math.round(162.66626), this.helpBtn.y = Math.round(33.33325), this.helpBtn.labelState = this.game.add.image(0, 0, s.Atlases.Gameplay, "InGameHelpButton0000"), this.pauseBtn = new n.default(this.game, "", {}, this.onPause, this, s.Atlases.Gameplay), this.pauseBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.pauseBtn.sScale = 42 / this.pauseBtn.btn.width * 1.33333, this.pauseBtn.x = h.default.GAME_W - Math.round(75 * 1.33333), this.pauseBtn.y = this.helpBtn.y, this.pauseBtn.labelState = this.game.add.image(0, 0, s.Atlases.Gameplay, "InGamePauseButton0000"), this.musicBtn = new n.default(this.game, "", {}, this.toggleMusic, this, s.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.musicBtn.sScale = 42 / this.musicBtn.btn.width * 1.33333, this.musicBtn.x = h.default.GAME_W - Math.round(28 * 1.33333), this.musicBtn.y = this.helpBtn.y, this.musicBtn.labelState = this.game.add.image(0, 0, s.Atlases.Gameplay, "InGameMusicButton0000"), this.updateSoundButtons(), h.default.isDesktop ? this.container.addChild(this.helpBtn) : this.helpBtn.destroy(), this.container.addChild(this.pauseBtn), this.container.addChild(this.musicBtn), h.default.isDesktop || a.default.instance.container.parent.addChild(a.default.instance.container)
        }, c.prototype.toggleMusic = function() {
            r.default.getInstance().music ? o.default.getInstance().toggleMusic() : r.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(s.Sounds.Click)
        }, c.prototype.updateSoundButtons = function() {
            var t = r.default.getInstance().music ? 0 : 1;
            t += r.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(s.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, c.prototype.resize = function(t) {
            this.game.width / this.game.height < h.default.GAME_W / h.default.GAME_H ? (this.container.scale.set(t), this.container.x = 0) : (this.container.scale.set(t), this.container.x = this.game.width / 2 - h.default.DISPLAY_W2), h.default.isDesktop || a.default.instance.resize(t)
        }, c.prototype.onPause = function() {
            this.signalPause.dispatch(l.MainGameCore.PAUSE)
        }, c.prototype.onHelp = function() {
            this.signalPause.dispatch(l.MainGameCore.HELP)
        }, Object.defineProperty(c, "instance", {
            get: function() {
                return c._instance || (c._instance = new c), c._instance
            },
            enumerable: !0,
            configurable: !0
        }), c);

    function c() {
        this.signalRestart = null, this.signalPause = null, this.signalToggleMusic = null, this.game = null, this.scl = 1, this.container = null
    }
    e.default = i
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var o, c = i(1),
        u = i(36),
        d = i(7),
        r = i(5),
        h = i(9),
        l = i(34),
        p = i(30),
        f = i(44),
        g = i(13),
        a = i(32),
        m = i(4),
        y = i(8),
        b = i(2),
        v = i(52),
        _ = i(16),
        x = i(18),
        n = (o = Phaser.State, n(w, o), w.prototype.onBuild = function() {
            g.MainGameCore.instance.start(), g.MainGameCore.instance.slowSignal.removeAll(), g.MainGameCore.instance.menuPauseSignal.removeAll(), g.MainGameCore.instance.menuPauseSignal.add(this.onCallPopup, this), g.MainGameCore.instance.slowSignal.add(g.MainGameCore.instance.slow, g.MainGameCore.instance)
        }, w.prototype.init = function() {
            var t = this;
            o.prototype.init.call(this), this.game.world.removeAll(), w.loadedLevel = !1, dragonBones.PhaserFactory.init(this.game);
            var e, i = this.game.cache.getJSON(c.JSONData.DBPers2),
                s = this.game.cache.getJSON(c.JSONData.DBPers_Texture2),
                n = this.game.cache.getImage(l.default.DBPers2, !0).base;
            dragonBones.PhaserFactory.factory.parseDragonBonesData(i), dragonBones.PhaserFactory.factory.parseTextureAtlasData(s, n), i = this.game.cache.getJSON(c.JSONData.DBHelp), s = this.game.cache.getJSON(c.JSONData.DBHelp_Texture), n = this.game.cache.getImage(l.default.DBHelp, !0).base, dragonBones.PhaserFactory.factory.parseDragonBonesData(i), dragonBones.PhaserFactory.factory.parseTextureAtlasData(s, n), this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("playerSmall"), this._armatureDisplay.animation.play("idle", 0), this._armatureDisplay2 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("playerSmall"), this._armatureDisplay2.animation.play("idle", 0), this._armatureDisplay3 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("playerSmall"), this._armatureDisplay3.animation.play("idle", 0), this._armatureDisplay4 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("playerSmall"), this._armatureDisplay4.animation.play("idle", 0), this._armatureDisplayArr = [];
            for (var a = 0; a < 5; a++)(e = dragonBones.PhaserFactory.factory.buildArmatureDisplay("playerH" + a)).animation.play("anim", 0), e.visible = !1, this._armatureDisplayArr.push(e);
            this.initData(), this.game.time.advancedTiming = !0, this.game.time.desiredFps = 40, g.MainGameCore.instance.init(this.game), p.default.instance.init(this.game.add.group(), this.game), (new f.GameBuilder).start(this.onBuild, this, [this._armatureDisplay, this._armatureDisplay3, this._armatureDisplay2, this._armatureDisplay4]);
            n = 1;
            n = 1 < (n = this.game.width / c.Constants.WIDTH) ? 1 : n, this.backgroudBase = this.game.add.sprite(0, 0, u.default.Preloader, h.default.getBG()), this.backgroudBase.scale.set(1.33333 * n), this.backgroudBase.x = this.game.width / 2 - this.backgroudBase.width / 2, this.transition = this.game.add.tween(this.backgroudBase), this.transition.to({
                alpha: 0
            }, 1, Phaser.Easing.Linear.None, !1, 500), this.transition.onComplete.add(function() {
                w.loadedLevel = !0, t.backgroudBase.destroy(), t.backgroudBase = null, t.transition = null, m.default.isDesktop && t.game.input.keyboard.addKey(Phaser.Keyboard.P).onUp.add(t.onP, t), p.default.instance.signalPause.add(t.onPause, t)
            }), this.transition.start(), r.default.getInstance().playMusic(c.Sounds.GameMusic)
        }, w.prototype.create = function() {
            o.prototype.create.call(this), this.resize()
        }, w.prototype.onP = function() {
            g.MainGameCore.instance.isPaused ? this.onResume() : this.onPause()
        }, w.prototype.onPause = function(t) {
            void 0 === t && (t = ""), g.MainGameCore.instance.isPaused || g.MainGameCore.instance.menuPauseSignal.dispatch(0 === t.length ? g.MainGameCore.PAUSE : t)
        }, w.prototype.onCallPopup = function(t) {
            this.closePopup();
            var e = "GAME PAUSED";
            if (t !== g.MainGameCore.PAUSE) return t === g.MainGameCore.HELP ? void this.createHelpPopup() : void this.onPostMatch();
            this.createPopup();
            var i = new y.default(this.game, e, c.Constants.stylePause, null, this, u.default.Interface);
            i.y = -210, i.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), i.setProp("#330099", 6, "#FF99FF", 13), i.btn.label.setMaxSize(600, 90), i.label.setMaxSize(600, 90), i.setText(e), this.popup.getChildAt(1).addChild(i);
            var s = new y.default(this.game, "MENU", c.Constants.stylePauseBtn1, this.confirmExit, this, u.default.Interface);
            s.x = -150, s.y = 200, s.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), s.setProp("#330099", 6, "#FF99FF", 13), this.popup.getChildAt(1).addChild(s);
            t = new y.default(this.game, "RESUME", c.Constants.stylePauseBtn2, this.onResume, this, u.default.Interface);
            t.x = 150, t.y = 200, t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#330099", 6, "#FF99FF", 13), this.popup.getChildAt(1).addChild(t);
            e = new y.default(this.game, b.Inventory.instance.matchData.matchScore[0] + " : " + b.Inventory.instance.matchData.matchScore[1], c.Constants.styleEndMatchScore, null, null, u.default.Interface);
            e.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#FFFFFF", 7, "#000000", 15), e.y = -90, this.popup.getChildAt(1).addChild(e);
            i = b.Inventory.instance.matchData.teams[0] - 1, s = b.Inventory.instance.matchData.teams[1] - 1, t = this.game.add.image(-270, -90, u.default.Interface, "EmblemsBg0000");
            t.anchor.set(.5), t.scale.set(1.18), this.popup.getChildAt(1).addChild(t);
            e = this.game.add.image(270, -90, u.default.Interface, "EmblemsBg0000");
            e.anchor.set(.5), e.scale.set(1.18), this.popup.getChildAt(1).addChild(e), (t = this.game.add.image(-270, -90, u.default.Interface, "emptyBg0000")).scale.set(.8), this.popup.getChildAt(1).addChild(t), (e = this.game.add.image(270, -90, u.default.Interface, "emptyBg0000")).scale.set(.8), this.popup.getChildAt(1).addChild(e), t.loadTexture(u.default.Interface, "Emblems00" + (i < 10 ? "0" : "") + i), e.loadTexture(u.default.Interface, "Emblems00" + (s < 10 ? "0" : "") + s), t.anchor.set(.5), e.anchor.set(.5);
            e = new d.default(this.game, "", null, this.onMoreGames, this, u.default.Preloader);
            e.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), e.y = 80, this.popup.getChildAt(1).addChild(e);
            e = 1;
            e = 1 < (e = this.game.width / c.Constants.WIDTH) ? 1 : e, this.resizePopup(e)
        }, w.prototype.buildText = function(t, e, i, s) {
            void 0 === i && (i = 30), void 0 === s && (s = c.Constants.stylePopupContentSmall);
            for (var n, a = 0; a < t.length; a++)(n = new d.default(this.game, t[a], s, null, null, u.default.Interface)).y = a * i + 8, n.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.btn.inputEnabled = !1, 0 === a && n.label.addColor("#66CCFF", 11), 1 === a && (n.label.addColor("#66CCFF", 0), n.label.addColor("#ffffff", 5)), 2 === a && n.label.addColor("#66CCFF", 10), e.label.parent.addChild(n)
        }, w.prototype.buildText2 = function(t, e, i, s) {
            void 0 === i && (i = 30), void 0 === s && (s = c.Constants.stylePopupContent);
            for (var n, a = 0; a < t.length; a++)(n = new d.default(this.game, t[a], s, null, null, u.default.Interface)).y = a * i - 30, n.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.btn.inputEnabled = !1, e.label.parent.addChild(n)
        }, w.prototype.onForum = function() {
            b.Inventory.instance.checkForumAchievement(), window.open("https://forum.y8.com/t/basketball-legends/1741", "_blank")
        }, w.prototype.onMoreGames = function() {
            window.open(_.default.getInstance().getUrl(_.default.Current), "_blank")
        }, w.prototype.onScoreList = function() {}, w.prototype.disposePopup = function() {
            this.popup && this.popup.destroy(!0), this.popup = null, g.MainGameCore.instance.countDown.activate()
        }, w.prototype.backgroundPopup = function() {
            this.popup = this.game.add.sprite(350, 250, u.default.Interface, "bg0000"), this.popup.anchor.set(.5), this.popup.scale.set(1.33333);
            var t = this.game.add.sprite(0, 0, u.default.Interface, "bg0000");
            t.width = this.game.width, t.height = this.game.height, t.inputEnabled = !0, t.anchor.set(.5), this.popup.addChild(t), this.world.addChild(p.default.instance.container)
        }, w.prototype.createPopup = function() {
            null !== this.popup && this.disposePopup(), this.backgroundPopup();
            var t = this.game.add.sprite(0, 0, u.default.Preloader, h.default.BASE_BG[h.default.INDEX_BG] + "0000");
            t.anchor.set(.5), this.popup.addChild(t), g.MainGameCore.instance.isPlaying = !1, g.MainGameCore.instance.isPaused = !0, p.default.instance.pauseBtn.visible = !1, p.default.instance.helpBtn && (p.default.instance.helpBtn.visible = !1)
        }, w.prototype.createHelpPopup = function() {
            null !== this.popup && this.disposePopup(), this.backgroundPopup();
            var t = this.game.add.sprite(0, 0, u.default.Interface, "0bg100000");
            t.anchor.set(.5), t.scale.set(2.2, 1.2), this.popup.addChild(t), g.MainGameCore.instance.isPlaying = !1, g.MainGameCore.instance.isPaused = !0, p.default.instance.pauseBtn.visible = !1, p.default.instance.helpBtn && (p.default.instance.helpBtn.visible = !1);
            var e = this.game.cache.getJSON(c.JSONData.Players),
                t = this.parseStaticGraphic(e, 2);
            this.popup.addChild(t), t = 4 === b.Inventory.instance.gameMode ? this.parseStaticGraphic(e, 1) : this.parseStaticGraphic(e, 0), this.popup.addChild(t);
            t = new y.default(this.game, "OK", c.Constants.styleOKGreen, this.closePopup, this, u.default.Interface);
            t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.y = 215, t.setProp("#330099", 5, "#FF99FF", 10), this.popup.addChild(t), (t = new y.default(this.game, "HOW TO PLAY", c.Constants.styleHelpTitle, null, null, u.default.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.y = -210, t.setProp("#330099", 5, "#FF99FF", 10), this.popup.addChild(t), this.resizePopup(1)
        }, w.prototype.parseStaticGraphic = function(t, e) {
            for (var i, s, n, a = this.game.make.group(this.popup), o = null, r = 0, h = t["control" + e], l = 0; l < 40; l++) h.hasOwnProperty(l) && ((r = 0) === h[l].g.indexOf("arm_") ? ((o = this.game.make.image(0, 0, u.default.Interface, "loginSelect0000")).anchor.set(.5, .95), o.x = h[l].x, o.y = h[l].y + -10, a.addChild(o), s = parseInt(h[l].g.split("arm_")[1]), (n = this._armatureDisplayArr[s]).x = h[l].x + r, n.y = h[l].y + -10, n.scale.set(.9), n.visible = !0, a.addChild(n), n.animation.play("anim", 0)) : 0 === h[l].g.indexOf("txt_") ? (i = h[l].g.split("txt_")[1], s = c.Constants.styleHelpLetter, n = " ", 3 < i.length ? s = c.Constants.styleHelpTxt0 : ("X" === (i = i.charAt(0)) && (r = 2), "W" === i && (r = 1)), (0 < h[l].g.indexOf("Attack") || 0 < h[l].g.indexOf("Defense")) && (s = c.Constants.styleHelpTxt1), (0 < h[l].g.indexOf("action") || 0 < h[l].g.indexOf("super")) && (s = c.Constants.styleHelpTxt0, n = " - "), (o = new d.default(this.game, n + i, s, null, null, u.default.Gameplay)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), 3 < i.length && (o.label.stroke = "#0033FF", o.label.strokeThickness = 1), o.label.anchor.set(0), o.x = h[l].x + r, o.y = h[l].y + -10, a.addChild(o)) : ((o = this.game.make.image(h[l].x, h[l].y, u.default.Interface, h[l].g + "0000")).anchor.set(.5), o.x = h[l].x, o.y = h[l].y + -10, o.angle = h[l].r, o.scale.set(h[l].scaleX, h[l].scaleY), 0 < h[l].g.indexOf("plate") ? a.addChildAt(o, 0) : a.addChild(o)));
            return a
        }, w.prototype.resizePopup = function(t) {
            var e;
            null !== this.popup && ((e = this.popup.removeChildAt(0)).width = this.game.width, e.height = this.game.height, this.popup.x = this.world.bounds.centerX, this.popup.y = 240 * t * 1.33333, this.popup.addChildAt(e, 0), this.popup.scale.set(1.33333 * t))
        }, w.prototype.closePopup = function() {
            if (this._armatureDisplayArr[0].visible)
                for (var t = 0; t < this._armatureDisplayArr.length; t++) {
                    var e = this._armatureDisplayArr[t];
                    e.parent.removeChild(e), e.visible = !1
                }
            g.MainGameCore.instance.isPaused = !1, p.default.instance.pauseBtn.visible = !0, p.default.instance.helpBtn && (p.default.instance.helpBtn.visible = !0), p.default.instance.pauseBtn.onOut(), this.disposePopup()
        }, w.prototype.onResume = function() {
            this.closePopup()
        }, w.prototype.onPostMatch = function() {
            new h.default(this.game, 0, v.default.Name)
        }, w.prototype.confirmExit = function() {
            var t = new d.default(this.game, "", null, null, null, u.default.Interface);
            t.setFrames("0bg100000", "0bg100000", "0bg100000", "0bg100000"), t.btn.scale.set(1.3, 1);
            var e = this.game.add.sprite(0, 0, u.default.Interface, "black0000");
            e.width = this.game.width + 500, e.height = this.game.height + 500, e.inputEnabled = !0, e.anchor.set(.5), e.alpha = .5, t.btn.parent.addChildAt(e, 0);
            e = new y.default(this.game, "WARNING!!", c.Constants.styleWarningLeave, null, this, u.default.Interface);
            e.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#000000", 5, "#FFFFFF", 10), e.y = -95, t.addChild(e);
            e = this.game.add.image(0, -55, u.default.Interface, "line0000");
            e.anchor.set(.5), t.label.parent.addChild(e), (e = this.game.add.image(0, 55, u.default.Interface, "line0000")).anchor.set(.5), t.label.parent.addChild(e), this.popup.getChildAt(1).addChild(t);
            this.buildText2(["IF YOU CONTINUE,", "YOU WIL LOST", "YOUR PROGRESS"], t, 30);
            e = new y.default(this.game, "OK", c.Constants.stylePopupPlay, this.onMenu, this, u.default.Interface);
            e.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#000000", 6, "#FFFFFF", 12), e.x = -110, e.y = 90, t.label.parent.addChild(e), (e = new y.default(this.game, "CANCEL", c.Constants.stylePopupCancel, function() {
                t.destroy()
            }, this, u.default.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.setProp("#000000", 6, "#FFFFFF", 12), e.x = 60, e.y = 90, t.label.parent.addChild(e)
        }, w.prototype.onMenu = function() {
            this.closePopup(), !b.Inventory.instance.checkQuickMatch() && 0 === b.Inventory.instance.gameMode ? new h.default(this.game, 0, x.default.Name) : new h.default(this.game, 0, a.default.Name)
        }, w.prototype.update = function() {
            if (!w.isAdsPause && (o.prototype.update.call(this), w.loadedLevel)) {
                if (this.isFirstUpdate) return this.isFirstUpdate = !1, this.timeAcc = 0, void(this.prevTimeMS = Date.now());
                for (this.currTimeMS = Date.now(), this.deltaTime = (this.currTimeMS - this.prevTimeMS) / 1e3, this.deltaTime > w.MAX_FRAME_TIME && (this.deltaTime = w.MAX_FRAME_TIME), this.prevTimeMS = this.currTimeMS, this.timeAcc += this.deltaTime; this.timeAcc >= w.DESIRED_FRAME_TIME;) this.updateGameController(w.DESIRED_FRAME_TIME), this.timeAcc -= w.DESIRED_FRAME_TIME;
                g.MainGameCore.instance.isPaused || g.MainGameCore.instance.physics.updateGraphics()
            }
        }, w.prototype.resize = function() {
            o.prototype.resize.call(this);
            var t = 1;
            t = 1 < (t = this.game.width / c.Constants.WIDTH) ? 1 : t, g.MainGameCore.instance.view.resize(), g.MainGameCore.instance.view.scale.set(1.3333333 * t), g.MainGameCore.instance.view.alignIn(this.world.bounds, Phaser.TOP_CENTER), p.default.instance.resize(t), this.resizePopup(t)
        }, w.prototype.shutdown = function() {
            this.closePopup(), this._armatureDisplay = null, this._armatureDisplay2 = null, this._armatureDisplay3 = null, this._armatureDisplay4 = null, g.MainGameCore.instance.release(), p.default.instance.release(), o.prototype.shutdown.call(this)
        }, w.prototype.render = function() {
            1 !== g.MainGameCore.instance.timeScale ? 0 === g.MainGameCore.instance.timeScale ? dragonBones.PhaserFactory.factory.dragonBones.advanceTime(.3 * m.default.STEP) : dragonBones.PhaserFactory.factory.dragonBones.advanceTime(m.default.STEP * g.MainGameCore.instance.timeScale) : dragonBones.PhaserFactory.factory.dragonBones.advanceTime(-1), o.prototype.render.call(this)
        }, w.prototype.initData = function() {
            this.isFirstUpdate = !0
        }, w.prototype.updateGameController = function(t) {
            g.MainGameCore.instance.update(t)
        }, w.Name = "gameplay", w.pause = !1, w.MAX_FRAME_TIME = .1, w.DESIRED_FRAME_TIME = .025, w.isAdsPause = !1, w.loadedLevel = !1, w);

    function w() {
        var t = o.call(this) || this;
        return t.name = w.Name, t.popup = null, t.backgroudBase = null, t.transition = null, t._armatureDisplay = null, t._armatureDisplay2 = null, t._armatureDisplay3 = null, t._armatureDisplay4 = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(7),
        l = i(17),
        c = i(9),
        u = i(4),
        d = i(2),
        p = i(10),
        f = i(16),
        g = i(11),
        m = i(8),
        y = i(31),
        b = i(18),
        v = i(33),
        _ = i(0),
        x = i(26),
        n = (a = Phaser.State, n(w, a), w.prototype.init = function() {
            this.game.world.removeAll()
        }, w.prototype.create = function() {
            a.prototype.create.call(this), d.PlayersData.setupPlayers(), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, c.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.background4 = this.game.add.sprite(400, 290, r.Atlases.Interface, "bg0000");
            var t = null;
            (t = this.game.add.sprite(-185, 66, r.Atlases.Interface, "body00000")).anchor.set(.5), this.background4.addChild(t), (t = this.game.add.sprite(230, 55, r.Atlases.Interface, "body10000")).anchor.set(.5), this.background4.addChild(t), (t = this.game.add.sprite(0, 15, r.Atlases.Interface, "0bg100000")).anchor.set(.5), t.scale.set(1.1, .9), this.background4.addChild(t), (t = this.game.add.sprite(-213, -50, r.Atlases.Interface, "head00000")).anchor.set(.5), t.scale.set(.95), this.background4.addChild(t), (t = this.game.add.sprite(215, -55, r.Atlases.Interface, "head10000")).anchor.set(.5), t.scale.set(.95), this.background4.addChild(t), this.background4.anchor.set(.5), this.playBtn1 = new m.default(this.game, "1 PLAYER", r.Constants.stylePlay, this.start1Player, this, r.Atlases.Interface), this.playBtn1.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn1.y = -115, this.playBtn1.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn1), this.playBtn4 = new m.default(this.game, "CREDITS", r.Constants.stylePlay, this.onCredits, this, r.Atlases.Interface), this.playBtn4.y = 140, this.playBtn4.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn4.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn4), this.playBtn2 = new m.default(this.game, "2 PLAYERS", r.Constants.stylePlay, this.start2Player, this, r.Atlases.Interface), this.playBtn2.y = -45, this.playBtn2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn2.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn2), this.playBtn3 = new m.default(this.game, "QUICK", r.Constants.stylePlay2, this.startQuickMath, this, r.Atlases.Interface), this.playBtn3.y = 70, this.playBtn3.label.parent.y = -50, this.playBtn3.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn3.setProp("#330099", 5, "#FF99FF", 10), this.background4.addChild(this.playBtn3);
            t = new m.default(this.game, "MATCH", r.Constants.stylePlay2, null, null, r.Atlases.Interface);
            t.label.parent.y = 50, t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#330099", 5, "#FF99FF", 10), t.inputEnableChildren = !0, this.playBtn3.label.addChild(t), u.default.isDesktop || (this.playBtn2.visible = !1, this.playBtn1.y += 35, this.playBtn4.y += -35, this.playBtn3.y += -35), this.leaderBoardBtn = new h.default(this.game, "", null, this.onScoreList, this, r.Atlases.Interface), this.leaderBoardBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.leaderBoardBtn.sScale = .7, this.leaderBoardBtn.sLabelScale = .7;
            t = this.game.add.image(0, 0, r.Atlases.Interface, "lead_icon0000");
            t.anchor.set(.5), this.leaderBoardBtn.label.parent.addChild(t), this.achievmentBtn = new h.default(this.game, "", null, this.onAchievment, this, r.Atlases.Gameplay), this.achievmentBtn.sScale = 42 / this.achievmentBtn.btn.width, this.achievmentBtn.x = 730, this.achievmentBtn.y = 25, this.achievmentBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000");
            t = this.game.add.image(0, 0, r.Atlases.Interface, "ach_icon0000");
            t.anchor.set(.5), this.achievmentBtn.label.parent.addChild(t), this.logo = this.game.add.sprite(400, 65, r.Atlases.Preloader, "logo0000"), this.logo.anchor.set(.5), this.backgroundBase2.addChild(this.logo), this.musicBtn = new h.default(this.game, "", {}, this.toggleMusic, this, r.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.achievmentBtn.sScale = this.musicBtn.sScale = 42 / this.musicBtn.btn.width, this.musicBtn.x = 772, this.musicBtn.y = 25, this.musicBtn.labelState = this.game.add.image(0, 0, r.Atlases.Gameplay, "InGameMusicButton0000"), this.backgroundBase2.addChild(this.musicBtn), this.textVersion = new p.default(this.game, 0, 465, " " + r.Constants.VERSION, r.Constants.styleVersion), this.backgroundBase2.addChild(this.textVersion), this.branding2 = new h.default(this.game, "", null, this.onMoreGames, this, r.Atlases.Preloader), this.branding2.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.branding2.x = 698, this.branding2.y = 444, this.updateSoundButtons(), this.backgroundBase2.addChild(this.achievmentBtn), this.backgroundBase2.addChild(this.leaderBoardBtn), this.leaderBoardBtn.x = 730, this.leaderBoardBtn.y = 150, this.backgroundBase2.addChild(this.background4), this.backgroundBase2.addChild(this.branding2), this.leaderBoardBtn.visible = !1, this.resize(), new l.default(this.game, this, this.show)
        }, w.prototype.show = function() {
            var t = this.game.add.tween(this.background4);
            t.from({
                y: 800
            }, u.default.PRELOADER_TIME, _.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.logo)).from({
                y: -145
            }, u.default.PRELOADER_TIME, _.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).from({
                x: 1600
            }, u.default.PRELOADER_TIME, _.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.branding2)).from({
                x: 1600
            }, u.default.PRELOADER_TIME, _.Easing.Back.Out), t.start()
        }, w.prototype.hide = function() {
            var t = this.game.add.tween(this.background4);
            t.to({
                y: 800
            }, u.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.logo)).to({
                y: -145
            }, u.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).to({
                x: 1600
            }, u.default.PRELOADER_TIME, _.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                x: 1600
            }, u.default.PRELOADER_TIME, _.Easing.Linear.None), t.start()
        }, w.prototype.onMoreGames = function() {
            window.open(f.default.getInstance().getUrl(f.default.Current), "_blank")
        }, w.prototype.showBanner = function() {
            "undefined" != typeof gdsdk && "undefined" !== gdsdk.showBanner && gdsdk.showBanner()
        }, w.prototype.start1Player = function() {
            o.default.getInstance().play(r.Sounds.Click), d.Inventory.instance.matchData.resetScore(), d.Inventory.instance.gameMode = 0, d.Inventory.instance.matchData.matchMode = 0, this.showBanner(), new c.default(this.game, this, b.default.Name)
        }, w.prototype.start2Player = function() {
            o.default.getInstance().play(r.Sounds.Click), d.Inventory.instance.matchData.resetScore(), d.Inventory.instance.gameMode = 4, d.Inventory.instance.matchData.matchMode = 0, this.showBanner(), new c.default(this.game, this, x.default.Name)
        }, w.prototype.startQuickMath = function() {
            o.default.getInstance().play(r.Sounds.Click), d.Inventory.instance.gameMode = 2, d.Inventory.instance.matchData.matchMode = 0, this.showBanner(), new c.default(this.game, this, y.default.Name)
        }, w.prototype.onScoreList = function() {
            o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.onAchievment = function() {
            o.default.getInstance().play(r.Sounds.Click), new c.default(this.game, this, v.default.Name)
        }, w.prototype.toggleMusic = function() {
            g.default.getInstance().music ? o.default.getInstance().toggleMusic() : g.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.updateSoundButtons = function() {
            var t = g.default.getInstance().music ? 0 : 1;
            t += g.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(r.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, w.prototype.onCredits = function() {
            this.createPopup();
            var t = new m.default(this.game, "CREDITS", r.Constants.styleCredits3, null, null, r.Atlases.Interface);
            t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#330099", 5, "#FF99FF", 10), t.y = -192, this.popup.getChildAt(1).addChild(t);
            for (var e, i = [" ", " ", " ", " ", " ", "CEO: Konstantin Matrunchik", "Coding: Yuriy Borozenets,", "Dmytro Borozenets", "Art: Andrey Zdyshchuk", "Roman Padaliuk", "Game Design: Vasiliy Kachor", "Ported by iriysoft.com"], s = 0; s < i.length; s++)(e = new h.default(this.game, i[s], r.Constants.styleCredits2, null, this, r.Atlases.Interface)).y = 19 * s - 48, e.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.btn.inputEnabled = !1, this.popup.getChildAt(1).addChild(e);
            this.popup_btn = new m.default(this.game, "BACK", r.Constants.styleBackArrow, this.disposePopup, this, r.Atlases.Interface), this.popup_btn.setFrames("arrow0000", "arrow0000", "arrow0000", "arrow0000"), this.popup_btn.btn.btn.x = -110, this.popup_btn.x = -250, this.popup_btn.y = 200, this.popup_btn.setProp("#330099", 5, "#FF99FF", 10);
            var n = new h.default(this.game, "", {}, this.onLogo, this, r.Atlases.Interface);
            n.setFrames("logo_mad0000", "logo_mad0000", "logo_mad0000", "logo_mad0000"), n.position.set(0, -92), n.scale.set(.87), this.popup.getChildAt(1).addChild(n);
            t = new h.default(this.game, "", {}, this.onVK, this, r.Atlases.Interface);
            t.setFrames("vk_icon0000", "vk_icon0000", "vk_icon0000", "vk_icon0000"), t.position.set(0, 7), t.scale.set(.9), this.popup.getChildAt(1).addChild(t);
            n = new h.default(this.game, "", {}, this.onFB, this, r.Atlases.Interface);
            n.setFrames("fb_icon0000", "fb_icon0000", "fb_icon0000", "fb_icon0000"), n.position.set(70, 7), n.scale.set(.9), this.popup.getChildAt(1).addChild(n);
            t = new h.default(this.game, "", {}, this.onTW, this, r.Atlases.Interface);
            t.setFrames("tw_icon0000", "tw_icon0000", "tw_icon0000", "tw_icon0000"), t.position.set(-70, 7), t.scale.set(.9), this.popup.getChildAt(1).addChild(t), this.popup.getChildAt(1).addChild(this.popup_btn);
            n = null, t = this.game.add.group();
            this.popup.getChildAt(1).addChildAt(t, 0), (n = this.game.add.sprite(-175, 66, r.Atlases.Interface, "body00000")).anchor.set(.5), t.addChild(n), (n = this.game.add.sprite(220, 55, r.Atlases.Interface, "body10000")).anchor.set(.5), t.addChild(n), (n = this.game.add.sprite(0, 0, r.Atlases.Interface, "0bg100000")).anchor.set(.5), n.scale.set(1), t.addChild(n), (n = this.game.add.sprite(-203, -50, r.Atlases.Interface, "head00000")).anchor.set(.5), n.scale.set(.95), t.addChild(n), (n = this.game.add.sprite(205, -55, r.Atlases.Interface, "head10000")).anchor.set(.5), n.scale.set(.95), t.addChild(n), this.resize()
        }, w.prototype.onLogo = function() {
            window.open("http://madpuffers.com/", "_blank")
        }, w.prototype.onVK = function() {
            window.open("https://vk.com/madpuffers", "_blank")
        }, w.prototype.onFB = function() {
            window.open("https://www.facebook.com/madpuffers", "_blank")
        }, w.prototype.onTW = function() {
            window.open("https://twitter.com/MadPuffers", "_blank")
        }, w.prototype.disposePopup = function() {
            this.popup.destroy(), this.popup = null, this.popup_btn.destroy(), this.popup_btn = null
        }, w.prototype.backgroundPopup = function() {
            this.popup = this.game.add.sprite(350, 280, r.Atlases.Interface, "bg0000"), this.popup.anchor.set(.5), this.popup.scale.set(1.33333);
            var t = this.game.add.sprite(0, 0, r.Atlases.Interface, "black0000");
            t.width = this.game.width + 500, t.height = this.game.height + 500, t.inputEnabled = !0, t.anchor.set(.5), this.popup.addChild(t)
        }, w.prototype.createPopup = function() {
            null !== this.popup && this.disposePopup(), this.backgroundPopup();
            var t = this.game.add.sprite(0, -15, r.Atlases.Interface, "0bg100000");
            t.anchor.set(.5), this.popup.addChild(t)
        }, w.prototype.resizePopup = function(t) {
            var e;
            null !== this.popup && ((e = this.popup.removeChildAt(0)).width = this.game.width + 500, e.height = this.game.height + 500, this.popup.x = this.world.bounds.centerX, this.popup.y = 260 * t, this.popup.addChildAt(e, 0), this.popup.scale.set(t))
        }, w.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, this.resizePopup(t), a.prototype.resize.call(this)
        }, w.prototype.shutdown = function() {
            this.popup = null, this.popup_btn = null, this.playBtn1 = null, this.playBtn2 = null, this.playBtn3 = null, this.achievmentBtn = null, this.leaderBoardBtn = null, this.branding2 = null, this.musicBtn = null, a.prototype.shutdown.call(this)
        }, w.Name = "menu", w);

    function w() {
        var t = a.call(this) || this;
        return t.name = w.Name, t.popup = null, t.popup_btn = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var r, a = i(5),
        h = i(1),
        l = i(7),
        c = i(17),
        u = i(9),
        o = i(4),
        d = i(2),
        p = i(8),
        f = i(18),
        g = i(12),
        m = i(0),
        n = (r = Phaser.State, n(y, r), y.prototype.init = function() {
            this.game.world.removeAll()
        }, y.prototype.create = function() {
            r.prototype.create.call(this), this.backgroundBase = this.game.add.sprite(0, 0, h.Atlases.Preloader, u.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, h.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.backBtn = new p.default(this.game, "BACK", h.Constants.styleBackArrow, this.onBack, this, h.Atlases.Interface), this.backBtn.setFrames("arrow0000", "arrow0000", "arrow0000", "arrow0000"), this.backBtn.btn.btn.x = -110, this.backBtn.setProp("#330099", 7, "#FF99FF", 15), this.backBtn.x = 130, this.backBtn.y = 450, this.backBtn.scale.set(.8, 1), this.backgroundBase2.addChild(this.backBtn), this.textHintArr = [];
            for (var t = 0; t < h.Constants.hints.length; t++) {
                var e = new p.default(this.game, h.Constants.hints[t], h.Constants.styleAchievDiscr, null, null, h.Atlases.Achiev);
                e.setFrames("hadr_ach_icon0000", "hadr_ach_icon0000", "hadr_ach_icon0000", "hadr_ach_icon0000"), e.btn.btn.visible = !1, e.btn.label.setMaxSize(600, 55), e.label.setMaxSize(600, 55), e.x = 500, e.y = 450, this.backgroundBase2.addChild(e), e.setText(h.Constants.hints[t]), e.setProp(null, 6, null, 12), this.textHintArr.push(e), e.visible = !1
            }
            this.logo = this.game.add.sprite(400, 35, h.Atlases.Interface, "bg0000"), this.logo.anchor.set(.5);
            var i = new p.default(this.game, "ACHIEVEMENTS", h.Constants.stylePreMatchTop, null, null, h.Atlases.Interface);
            i.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), i.setProp("#330099", 7, "#FF99FF", 15), this.logo.addChild(i);
            var s, n = this.game.cache.getJSON(h.JSONData.Players);
            this.btns = this.game.add.group(), this.backgroundBase2.addChild(this.btns), this.backgroundBase2.addChild(this.logo);
            for (t = 0; t < 19; t++) {
                if (s = new l.default(this.game, "", h.Constants.stylePopupContentSmall, this.onMouseOver, this, h.Atlases.Achiev), 15 <= t) {
                    var a = 0;
                    switch (t) {
                        case 15:
                            a = 2;
                            break;
                        case 16:
                            a = 10;
                            break;
                        case 17:
                            a = 1;
                            break;
                        case 18:
                            a = 14
                    }
                    s.setFrames("icon_a" + a + "0000", "icon_a" + a + "0000", "icon_a" + a + "0000", "icon_a" + a + "0000"), s.id = t + "", (o = new Phaser.Image(this.game, -45, -45, h.Atlases.Achiev, "hadr_ach_icon0000")).scale.set(.9), s.btn.parent.addChild(o)
                } else s.id = t + "", s.setFrames("icon_a" + t + "0000", "icon_a" + t + "0000", "icon_a" + t + "0000", "icon_a" + t + "0000");
                s.position.set(434 + n["a" + t].x, 240 + n["a" + t].y), s.btn.events.onInputOver.add(this.onMouseOver, this), s.btn.events.onInputDown.add(this.onMouseOver, this), s.btn.events.onInputOut.add(this.onMouseOut, this);
                var o = h.Constants.aNamesScreen.indexOf(h.Constants.aNames[parseInt(s.id)]);
                1 <= d.Inventory.instance.achievsMgr.getValuesForRead()[o] || (s.btn.tint = 3355443), this.btns.addChild(s)
            }
            new c.default(this.game, this, this.show), this.resize()
        }, y.prototype.tweenBtn = function(t) {
            t = this.game.add.tween(t);
            t.from({
                y: -290
            }, o.default.PRELOADER_TIME, m.Easing.Back.Out), t.start()
        }, y.prototype.tweenBtnHide = function(t) {
            t = this.game.add.tween(t);
            t.to({
                y: -290
            }, o.default.PRELOADER_TIME, m.Easing.Back.Out), t.start()
        }, y.prototype.show = function() {
            this.btns.forEach(this.tweenBtn, this, !0);
            var t = this.game.add.tween(this.logo);
            t.from({
                y: -60
            }, o.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.backBtn)).from({
                y: 520
            }, o.default.PRELOADER_TIME, m.Easing.Linear.None), t.start()
        }, y.prototype.hide = function() {
            this.btns.forEach(this.tweenBtnHide, this, !0);
            var t = this.game.add.tween(this.logo);
            t.to({
                y: -60
            }, o.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.backBtn)).to({
                y: 520
            }, o.default.PRELOADER_TIME, m.Easing.Linear.None), t.start()
        }, y.prototype.onMouseOver = function(t) {
            for (var t = parseInt(t.parent.parent.id), e = 0; e < this.textHintArr.length; e++) this.textHintArr[e].visible = !1;
            this.textHintArr[t].visible = !0
        }, y.prototype.onMouseOut = function(t) {
            for (var e = 0; e < this.textHintArr.length; e++) this.textHintArr[e].visible = !1
        }, y.prototype.onBack = function() {
            a.default.getInstance().play(h.Sounds.Click), u.default.prevState[0] === g.Menu.Name ? new u.default(this.game, this, g.Menu.Name) : new u.default(this.game, this, f.default.Name)
        }, y.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / h.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, r.prototype.resize.call(this)
        }, y.prototype.shutdown = function() {
            this.backgroundBase2 = null, this.logo = null, r.prototype.shutdown.call(this)
        }, y.Name = "achievment", y);

    function y() {
        var t = r.call(this) || this;
        return t.name = y.Name, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.DBHelp = "data3", n.DBPers2 = "data2", n.DBPers = "data", n.preloadList = [], n.list = [n.DBHelp, n.DBPers2, n.DBPers], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.VERSION = "1.0.8g", n.GAME_SCALE = 1, n.CALCULATED_WIDTH = 0, n.CALCULATED_HEIGHT = 0, n.WIDTH = 1066, n.HEIGHT = 640, n.LANDSCAPE_LOCKED = !0, n.PORTRAIT_LOCKED = !1, n.GAME_DISTRIBUTION_LOCAL_ID = "", n.STORAGE_KEY = "bb_test", n.STORAGE_KEY_SFX = "bb_sfx_sv", n.styleFPS = {
        font: "24px Impact",
        fill: "#FF00FF"
    }, n.styleTime = {
        font: "15px Impact",
        fill: "#DDD9D7"
    }, n.stylePreMatchTop = {
        font: "60px Impact",
        fill: "#FFFFFF"
    }, n.styleEndMatchTop = {
        font: "60px Impact",
        fill: "#FFFFFF"
    }, n.stylePreMatchState = {
        font: "40px Impact",
        fill: "#FFFFFF"
    }, n.stylePreMatchScore = {
        font: "80px CfCrackBold",
        fill: "#FEAE00"
    }, n.styleEndMatchScore = {
        font: "90px CfCrackBold",
        fill: "#FEAE00"
    }, n.stylePreMatchNames = {
        font: "20px Impact",
        fill: "#FFFFFF"
    }, n.styleIDnetScore = {
        font: "18px Impact2",
        fill: "#FFFFFF"
    }, n.styleIDnetScore2 = {
        font: "18px Impact2",
        fill: "#FF9900"
    }, n.styleIDnetBestScore = {
        font: "18px Impact2",
        fill: "#FFFFFF"
    }, n.styleIDnetBestScore2 = {
        font: "18px Impact2",
        fill: "#FF9900"
    }, n.styleHintSkillKey = {
        font: "14px Impact",
        fill: "#1E292E"
    }, n.stylePlay = {
        font: "40px Impact",
        fill: "#00CCFF"
    }, n.stylePlay3 = {
        font: "40px Impact",
        fill: "#00CCFF"
    }, n.stylePauseBtn1 = {
        font: "42px Impact",
        fill: "#FF9900"
    }, n.stylePauseBtn2 = {
        font: "42px Impact",
        fill: "#00CCFF"
    }, n.stylePlayLogin = {
        font: "42px Impact",
        fill: "#B1FE00"
    }, n.stylePlayGreen = {
        font: "40px Impact",
        fill: "#B1FE00"
    }, n.styleNormalGreen = {
        font: "25px Impact",
        fill: "#C254FF"
    }, n.styleHardGreen = {
        font: "35px Impact",
        fill: "#C254FF"
    }, n.styleDIfficulltyBg = {
        font: "25px Impact",
        fill: "#FFFFFF"
    }, n.styleDIfficulltyBg2 = {
        font: "35px Impact",
        fill: "#FFFFFF"
    }, n.stylePlay2 = {
        font: "40px Impact",
        fill: "#CDF00F"
    }, n.stylePlay4 = {
        font: "40px Impact",
        fill: "#FF9900"
    }, n.styleAchievDiscr = {
        font: "24px Impact",
        fill: "#FF9900"
    }, n.styleTitle0 = {
        font: "88px Impact",
        fill: "#FFFFFF"
    }, n.styleTitle1 = {
        font: "88px Impact",
        fill: "#000000"
    }, n.styleTitle2 = {
        font: "34px Impact",
        fill: "#00CCFF"
    }, n.styleTitleFinalTournamet = {
        font: "40px Impact",
        fill: "#FFFFFF"
    }, n.styleVS = {
        font: "25px Impact",
        fill: "#FFFFFF"
    }, n.styleVS2 = {
        font: "25px Impact",
        fill: "#C254FF"
    }, n.styleCPU = {
        font: "10px Impact",
        fill: "#FFFFFF"
    }, n.styleCPU2 = {
        font: "10px Impact",
        fill: "#C254FF"
    }, n.stylePause = {
        font: "42px Impact",
        fill: "#FFFFFF"
    }, n.styleWarningLeave = {
        font: "38px Impact",
        fill: "#FFFFFF"
    }, n.styleWarningContext = {
        font: "28px Impact2",
        fill: "#FFFFFF"
    }, n.styleOKGreen = {
        font: "42px Impact",
        fill: "#CDF00F"
    }, n.styleCancel = {
        font: "52px Impact",
        fill: "#FF9900"
    }, n.styleLoading = {
        font: "25px Impact",
        fill: "#FF00FF"
    }, n.styleCredits0 = {
        font: "30px Impact",
        fill: "#FFFFFF"
    }, n.styleBackArrow = {
        font: "40px Impact",
        fill: "#FF9900"
    }, n.stylePopupContentSmall = {
        font: "17px Impact2",
        fill: "#FFFFFF"
    }, n.stylePopupContent = {
        font: "30px Impact2",
        fill: "#FFFFFF"
    }, n.stylePopupContentYellow = {
        font: "30px Impact2",
        fill: "#66CCFF"
    }, n.stylePopupContent2 = {
        font: "46px Impact2",
        fill: "#000000"
    }, n.stylePopupCancel = {
        font: "40px Impact",
        fill: "#FF9900"
    }, n.stylePopupPlay = {
        font: "40px Impact",
        fill: "#B1FE00"
    }, n.styleCredits1 = {
        font: "19px Impact2",
        fill: "#FFFFFF"
    }, n.styleCredits2 = {
        font: "15px Impact2",
        fill: "#FFFFFF"
    }, n.styleCredits3 = {
        font: "56px Impact",
        fill: "#FFFFFF"
    }, n.styleCredits33 = {
        font: "42px Impact",
        fill: "#FFFFFF"
    }, n.styleCredits4 = {
        font: "46px Impact",
        fill: "#FFFFFF"
    }, n.styleCredits5 = {
        font: "27px Impact",
        fill: "#FFFFFF"
    }, n.styleTournamentPopup = {
        font: "38px Impact",
        fill: "#00CCFF"
    }, n.styleMSG = {
        font: "80px Impact3",
        fill: "#FF9900"
    }, n.styleTimer = {
        font: "24px CfCrackBold",
        fill: "#CDF00F"
    }, n.styleVersion = {
        font: "12px Impact",
        fill: "#FFFFFF"
    }, n.styleHelpTxt0 = {
        font: "18px Impact2",
        fill: "#FFFFFF"
    }, n.styleHelpTxt1 = {
        font: "24px Impact2",
        fill: "#FFFFFF"
    }, n.styleHelpLetter = {
        font: "20px Impact2",
        fill: "#000000"
    }, n.styleHelpTitle = {
        font: "40px Impact",
        fill: "#FFB600"
    }, n.styleLogin = {
        font: "28px Impact",
        fill: "#FFB600",
        boundsAlignH: "center",
        boundsAlignV: "middle"
    }, n.styleLoginInfo = {
        font: "18px Impact2",
        fill: "#FFFFFF",
        boundsAlignH: "center",
        boundsAlignV: "middle"
    }, n.styleLoginInfoYellow = {
        font: "20px Impact2",
        fill: "#66CCFF",
        boundsAlignH: "center",
        boundsAlignV: "middle"
    }, n.styleLoginInfoYellow2 = {
        font: "20px Impact2",
        fill: "#FFFFFF",
        boundsAlignH: "center",
        boundsAlignV: "middle"
    }, n.styleLoginInfoIsf = {
        font: "16px Impact2",
        fill: "#FFFFFF"
    }, n.stylePlayer = {
        font: "16px Impact2",
        fill: "#FF9900"
    }, n.stylePlayerName = {
        font: "14px Impact2",
        fill: "#FFFFFF"
    }, n.styleClubName = {
        font: "20px Impact2",
        fill: "#FFFFFF"
    }, n.styleSkillName = {
        font: "14px Impact2",
        fill: "#FFFFFF"
    }, n.aNames = ["Sniper", "Gold Cup 2", "Gold Cup", "Dunker", "Silver Cup 2", "Silver Cup", "Block Scorer", "Bronze Cup 2", "Bronze Cup", "Defender", "Match Leader", "Blocker", "Buzzer Beater", "Points Leader", "Tournament Leader", "Hard Gold Cup", "Hard Match Leader", "Hard Gold Cup 2", "Hard Tournament Leader"], n.aNamesScreen = ["Sniper", "Dunker", "Block Scorer", "Buzzer Beater", "Blocker", "Defender", "Points Leader", "Match Leader", "Hard Match Leader", "Tournament Leader", "Hard Tournament Leader", "Gold Cup", "Silver Cup", "Bronze Cup", "Gold Cup 2", "Silver Cup 2", "Bronze Cup 2", "Hard Gold Cup", "Hard Gold Cup 2"], n.hints = ["Sniper: Make 20 three-pointers", "Gold Cup 2: Win Gold Cup in 2 vs 2 mode", "Gold Cup: Win Gold Cup in 1 vs 1 mode", "Dunker: Make 50 dunks", "Silver Cup 2: Win Silver Cup in 2 vs 2 mode", "Silver Cup: Win Silver Cup in 1 vs 1 mode", "Block Scorer: Score 5 times using block", "Bronze Cup 2: Win Bronze Cup in 2 vs 2 mode", "Bronze Cup: Win Bronze Cup in 1 vs 1 mode", "Defender: Make 50 steals", "Match Leader: Score 25 points in one match", "Blocker: Make 20 blocks", "Buzzer Beater: Score 5 time after final buzzer", "Points Leader: Score 500 points", "Tournament Leader: Score 150 points in one tournament", "Hard Gold Cup: Win Gold Cup in 1 vs 1 Hard mode", "Hard Match Leader: Score 25 points in one match in Hard mode", "Hard Gold Cup 2: Win Gold Cup in 2 vs 2 Hard mode", "Hard Tournament Leader: Score 150 points in one tournament in Hard mode"], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.Interface = "interface", n.Gameplay = "gameplay", n.Preloader = "preloader", n.Achiev = "ach", n.preloadList = [n.Preloader], n.list = [n.Interface, n.Gameplay, n.Achiev, n.Preloader], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var a = i(1),
        o = i(2),
        i = (s.prototype.initFirstSave = function() {
            o.Inventory.instance.init(), this.save()
        }, s.getInstance = function(t, e, i) {
            return s.instance ? i && e.call(i) : s.instance = new s(t, e, i), s.instance
        }, s.prototype.save = function() {
            var t = JSON.stringify({
                    invsav: o.Inventory.instance.save
                }),
                e = this.hash(t);
            this.game.storage.setItem(a.Constants.STORAGE_KEY, t), this.game.storage.setItem(a.Constants.STORAGE_KEY + "h", e)
        }, s.prototype.restore = function() {
            var i, s, n = this,
                t = this.game.storage.getItem(a.Constants.STORAGE_KEY),
                e = this.game.storage.getItem(a.Constants.STORAGE_KEY + "h");
            Promise.all([t, e]).then(function(t) {
                if (i = t[0] || "", s = t[1] || "0", "" === i) return n.initFirstSave(), void(n.callback && n.callbackContext && n.callback.call(n.callbackContext));
                if (s !== n.hash(i)) return n.initFirstSave(), void(n.callback && n.callbackContext && n.callback.call(n.callbackContext));
                if (i && "" !== i) try {
                    var e = JSON.parse(i);
                    o.Inventory.instance.save = e.invsav
                } catch (t) {
                    n.initFirstSave()
                } else n.initFirstSave();
                n.callback && n.callbackContext && n.callback.call(n.callbackContext)
            })
        }, s.prototype.hash = function(t) {
            var e, i, s = 0;
            if (0 === t.length) return s.toString();
            for (e = 0, i = t.length; e < i; e++) s = (s << 5) - s + t.charCodeAt(e), s |= 0;
            return s.toString()
        }, s);

    function s(t, e, i) {
        var s = this;
        this.carSaves = {}, this.game = t, this.callback = e, this.callbackContext = i, this.game && this.game.storage.getItem(a.Constants.STORAGE_KEY).then(function(t) {
            null == t ? (s.initFirstSave(), s.callback && s.callbackContext && s.callback.call(s.callbackContext)) : s.restore()
        })
    }
    e.default = i
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        n = (a = Phaser.Group, n(r, a), r.prototype.add = function(t) {}, r.prototype.shake = function(t) {}, r.prototype.shakeContainer = function(t, e) {
            void 0 === t && (t = null);
            var i = o.default.game.add.tween(t),
                s = t.x,
                n = t.y;
            i.to({
                x: t.x - e,
                y: t.y - e
            }, 25, Phaser.Easing.Bounce.InOut, !1, 0, 4, !0), i.onComplete.addOnce(function() {
                t.x = s, t.y = n
            }, this), i.start()
        }, r.prototype.release = function() {
            this.game = null
        }, r.prototype.start = function() {}, r.prototype.resize = function() {}, r);

    function r(t) {
        var e = a.call(this, t) || this;
        return e.game = t, e
    }
    e.GameView = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(5),
        r = i(3),
        h = i(35),
        l = i(13),
        c = i(1),
        u = i(7),
        d = i(2),
        p = i(15),
        n = (a = Phaser.Group, n(f, a), f.prototype.start = function(t) {
            this.wasEnd = !1, this.fullTime = t, this.noticeTime = 4, this.process(0)
        }, Object.defineProperty(f.prototype, "fullTimeMatch", {
            get: function() {
                return this.fullTime
            },
            enumerable: !0,
            configurable: !0
        }), f.prototype.updateScore = function(t, e) {
            1 === t ? l.MainGameCore.instance.infoPanel.updateScore(e, d.Inventory.instance.matchData.matchScore[1]) : l.MainGameCore.instance.infoPanel.updateScore(d.Inventory.instance.matchData.matchScore[0], e)
        }, f.prototype.process = function(t) {
            var e, i = this.fullTime - t;
            i <= 0 ? this.wasEnd || (this.timer.label.text = "00.0", this.wasEnd = !0, p.Signals.MatchEndSignal.dispatch()) : 120 == i ? this.timer.label.text = "2:00" : 60 <= i ? (e = i - 60 >> 0, this.timer.label.text = 10 <= e ? "1:" + e.toString() : "1:0" + e.toString()) : (e = 10 * (i - (t = i >> 0)) >> 0, 10 <= i ? this.timer.label.text = t.toString() + "." + e.toString() : (this.timer.label.text = "0" + t.toString() + "." + e.toString(), t === this.noticeTime && 0 <= this.noticeTime && (o.default.getInstance().play(c.Sounds.m_countdown), this.noticeTime--)))
        }, f);

    function f() {
        var t = a.call(this, r.default.game) || this;
        return t.timer = null, t.x = 400, t.y = 77, t.timer = new u.default(r.default.game, " ", h.default.styleTimer, null, null, c.Atlases.Gameplay), t.addChild(t.timer), t.timer.label.setMaxSize(150, 70), t.timer.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.timer.label.setShadow(3, 3, "rgba(0,0,0,0.5)", 5), t.timer.setText("2:00"), t
    }
    e.TimerObject = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(15),
        i = (Object.defineProperty(n, "instance", {
            get: function() {
                return null === n._instance && (n._instance = new n), n._instance
            },
            enumerable: !0,
            configurable: !0
        }), n.prototype.clearSensors = function() {
            this.canScore = !0, this.upperSensor = !1
        }, n.prototype.shoot = function(t, e, i) {
            this.clearSensors(), this.shotSide = t, this.isHuman = e, this.throwType = i, this.blockSide = 0, this.blockIsHuman = !1
        }, n.prototype.block = function(t, e) {
            this.clearSensors(), this.blockSide = t, this.blockIsHuman = e
        }, n.prototype.processSensor = function(t, e) {
            this.canScore && (0 === t ? this.upperSensor = !0 : this.upperSensor ? this.sendScore(e) : this.canScore = !1)
        }, n.prototype.sendScore = function(t) {
            var e;
            this.blockSide === -t ? (e = 2, this.isHuman = this.blockIsHuman, this.throwType = 2) : e = 0 === this.throwType ? 3 : 2, this.callBack.dispatch(t, e, this.isHuman, this.throwType)
        }, n.prototype.finishMatch = function() {
            s.Signals.SensorSignal.remove(this.processSensor, this)
        }, n._instance = null, n);

    function n() {
        this.callBack = s.Signals.MatchProcessorSignal, s.Signals.SensorSignal.add(this.processSensor, this)
    }
    e.MatchProcessor = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(0),
        i = (n.prototype.init = function(t, e, i) {
            this.values = this.baseData.getValues(), this.save = t, this.saveName = e, this.signalSave = new s.Signal, this.loadData()
        }, n.prototype.loadData = function() {
            var t;
            null === this.save && (this.save = {}), null == (t = this.save[this.saveName]) ? (this.save[this.saveName] = {}, this.saveData()) : this.baseData.setValues(t)
        }, n.prototype.saveData = function() {
            this.save[this.saveName] = this.baseData.getValuesForWrite(), this.signalSave.dispatch()
        }, n.prototype.updateData = function(t, e) {
            void 0 === e && (e = 0)
        }, n);

    function n() {}
    e.BaseDataManager = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.createEmpty = function() {
        this.values = [];
        for (var t = 0; t < this.count; t++) this.values[t] = 0
    }, n.prototype.getValuesForWrite = function() {
        for (var t = {}, e = 0; e < this.count; e++) t[this.names[e]] = this.values[e];
        return t
    }, n.prototype.setValues = function(t) {
        for (var e in t) {
            var i = this.names.indexOf(e);
            this.values[i] = t[e]
        }
    }, n.prototype.getValues = function() {
        return this.values
    }, n);

    function n() {}
    e.BaseData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(2),
        n = i(13),
        i = (a.prototype.create = function(t) {
            void 0 === t && (t = null)
        }, a.prototype.add = function() {
            this.body && this.updateGraphic(), n.MainGameCore.instance.add(this)
        }, a.prototype.release = function() {
            if (this.graphic) {
                if (this.graphic.dispose) try {
                    this.graphic.dispose()
                } catch (t) {}
                this.graphic = null
            }
            if (this.body) {
                try {
                    s.NapeUtil.disposeBody(this.body)
                } catch (t) {}
                this.body = null
            }
        }, a.prototype.updateGraphic = function() {
            this.graphic && (this.graphic.x = this.body.position.x, this.graphic.y = this.body.position.y, this.graphic.rotation = 180 * this.body.rotation / Math.PI % 360, this.body.userData.graphic = this.graphic)
        }, a.prototype.start = function() {}, a.prototype.update = function(t) {}, a.prototype.getPosition = function() {
            return this.body ? this.body.position : null
        }, a.prototype.getX = function() {
            return this.body ? this.body.position.x : -1e3
        }, a.prototype.getY = function() {
            return this.body ? this.body.position.y : -1e3
        }, a.prototype.stopVelocity = function() {
            this.body && this.body.velocity.setxy(0, 0)
        }, a);

    function a() {
        this.graphic = null, this.objType = -1
    }
    e.GameObject = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var h = i(2),
        l = i(45),
        c = i(24),
        u = i(3),
        d = i(80),
        p = i(81),
        f = i(47),
        i = (s.prototype.start = function(t, e, i) {
            var s = new d.ArenaObject;
            new p.BasketObject(-1), new p.BasketObject(1), new l.BallObject, new h.CountDownObject, new h.MessageInfo;
            for (var n = c.Inventory.instance.matchData, a = 0; a < n.teams.length; a++)
                for (var o = 0; o < n.players[a].length; o++) {
                    var r = i.pop();
                    u.default.game.world.addChild(r), new h.PlayerObject(a, n.teams[a], n.players[a][o], n.forms[a], o, n.pb[a][o], f.AISkillsData.botsSkills[n.skills[a][o]], r)
                }
            s.setLogo(n.teams[0]), t.call(e)
        }, s);

    function s() {
        var t = c.Inventory.instance.gameMode;
        0 === t ? c.Inventory.instance.startTournamentMatch() : 3 === t ? c.Inventory.instance.matchData.startTraining() : c.Inventory.instance.matchData.restarted ? (c.Inventory.instance.matchData.restarted = !1, c.Inventory.instance.matchData.resetScore()) : 1 === t ? c.Inventory.instance.matchData.startRandomMatch() : 2 === t ? c.Inventory.instance.matchData.startQuickMatch() : 4 === t && c.Inventory.instance.matchData.startPlayers2Match()
    }
    e.GameBuilder = i
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = nape.geom.Vec2,
        r = nape.phys.BodyType,
        h = i(43),
        l = i(23),
        c = i(2),
        u = i(19),
        d = i(4),
        p = i(29),
        f = i(3),
        g = i(1),
        m = i(46),
        y = i(15),
        b = i(5),
        n = (a = h.GameObject, n(v, a), v.prototype.createGraphic = function() {
            this.graphic = new Phaser.Group(f.default.game);
            var t = new Phaser.Sprite(f.default.game, 0, 0, g.Atlases.Gameplay, "BallMC0000");
            t.anchor.set(.5), this.graphic.addChild(t), this.shadow = new m.ShadowObject(this.graphic, 0)
        }, v.prototype.createBody = function() {
            this.body = l.NapeUtil.createCircleBody(r.DYNAMIC, c.Filters.BALL, !1, p.ObjectsData.BALL_RADIUS, 0, 0, 0, c.CbTypes.cbBall, c.Materials.BALL), this.body.userData.graphic = this.graphic, (this.body.userData.owner = this).body.gravMass *= p.ObjectsData.BALL_GRAVMASS
        }, v.prototype.restart = function(t) {
            void 0 === t && (t = 0), 0 === t && (this.body.velocity.setxy(0, this.velUp), this.state = "up", this.body.position.set(this.indent), this.body.rotation = 0, this.body.angularVel = 0, this.updateGraphic(), this.shadow.update(), null === this.body.space && this.returnToPhysics())
        }, v.prototype.setState = function(t, e, i, s) {
            void 0 === e && (e = 2), void 0 === i && (i = 0), void 0 === s && (s = !1), t === this.state && !s || (e < 2 && (this.SIDE = e), "inHands" === t ? this.gamecore.ballInHands(this.SIDE, i) : "shooting" === t ? this.gamecore.ballShooting(this.SIDE, i) : this.gamecore.ballOthers(), !this.isWaiting || "bounce" !== t && "score" !== t || (this.isWaiting = !1, y.Signals.MatchEndSignal.dispatch()), this.state = t)
        }, v.prototype.shoot = function(t, e, i, s, n) {
            this.SIDE = t, this.body.position.setxy(e, i);
            var a = this.calcThrowVel(e, i),
                o = 1 === t ? e : this.width - e,
                s = Math.abs(s) / this.maxVelX * .1,
                n = this.calcDispersion(o, i, s, n);
            n < 2 ? this.body.velocity.setxy(a.x * n, a.y) : 2 === n ? this.body.velocity.set(this.calcThrowVel(e, i, 30 * this.SIDE)) : this.body.velocity.set(this.calcThrowVel(e, i, 30 * -this.SIDE)), this.body.rotation = 0, this.body.angularVel = t * (5 + 10 * Math.random()), this.setState("shooting"), a.dispose(), this.returnToPhysics()
        }, v.prototype.alleyOop = function(t, e, i, s) {
            this.player = s, this.SIDE = t, this.body.position.setxy(e, i), this.body.rotation = 0;
            t = 1 === t ? this.alleyOopX1 : this.alleyOopX2;
            this.body.velocity.set(this.calcVel(e, i, t, this.alleyOopY, 150)), this.toPhysics2()
        }, v.prototype.calcThrowVel = function(t, e, i) {
            var s;
            return void 0 === i && (i = 0), i = (i = 1 === this.SIDE ? (s = this.xB1 + i, t) : (s = this.xB2 + i, this.width - t)) <= 150 ? 70 : i <= 250 ? 100 : i <= 350 ? .3 * i + 40 : i <= 540 ? 150 : 130, 185 < (i *= 1 + .1 * (Math.random() <= .5 ? -1 : 1) * Math.random()) && (i = 185), this.calcVel(t, e, s, this.yB, i)
        }, v.prototype.calcVel = function(t, e, i, s, n) {
            e -= s - n, s = -Math.sqrt(2 * this.gravity * e), e = -s / this.gravity, n = Math.sqrt(2 * n / this.gravity);
            return new o((i - t) / (e + n) * 1.035, s)
        }, v.prototype.calcDispersion = function(t, e, i, s) {
            e = e < 235 ? 0 : 295 <= e ? this.vertDispersion : (1 - (295 - e) / 60) * this.vertDispersion, t = t <= 100 ? 0 : t <= 200 ? .01 : t <= 300 ? .02 : t <= 400 ? .03 : t <= 490 ? .04 : t <= 540 ? .01 : .07;
            i = (Math.random() < .5 ? -1 : 1) * (this.baseDispersion + e + t + s + i) * Math.random();
            return Math.abs(i) <= .02 ? 1 : i < -.08 ? 2 : .08 < i ? 3 : 1 + i
        }, v.prototype.dunk = function(t, e) {
            var i, s, n;
            return this.SIDE = t, Math.random() <= e ? (i = 1 === t ? this.basket1 + 17 : this.basket2 - 17, s = o.get(-260 * t, 400), n = !0) : (i = 1 === t ? this.basket1 : this.basket2, s = o.get(-550 * t, 400), n = !1, b.default.getInstance().play(g.Sounds.b_brick)), this.body.position.setxy(i, 170), this.body.velocity.set(s), this.body.rotation = 0, this.body.angularVel = 0, this.setState("dunk"), this.returnToPhysics(), s.dispose(), n
        }, v.prototype.takeInHands = function(t, e, i) {
            void 0 === i && (i = !1);
            var s = !1;
            return (i || "shooting" !== this.state && "inHands" !== this.state) && (this.removeFromPhysics(), this.SIDE = t, this.setState("inHands", this.SIDE, e, i), s = !0), s
        }, v.prototype.fromHands = function(t, e) {
            this.setState("down"), this.body.position.set(t), this.body.velocity.setxy(150 * e, -100), this.returnToPhysics()
        }, v.prototype.applySteal = function(t, e, i) {
            this.setState("steal"), this.body.position.set(t);
            e = i * (this.stealVelXBase + e * this.stealVelXAdd);
            this.body.velocity.setxy(e, this.stealVelY), this.returnToPhysics()
        }, v.prototype.onGroundCollision = function(t) {
            void 0 === t && (t = !0), "inHands" !== this.state && (this.setState("bounce"), t && (this.body.velocity.y = this.bounceVel, b.default.getInstance().play(g.Sounds.b_bounce)))
        }, v.prototype.isInGame = function() {
            return null !== this.body.space
        }, v.prototype.removeFromPhysics = function() {
            this.shadow.hide(), this.body.velocity.setxy(0, 0), this.body.angularVel = 0, this.body.rotation = 0, this.graphic.visible = !1, this.body.space = null
        }, v.prototype.returnToPhysics = function() {
            this.body.space = this.space1, this.updateGraphic(), this.setVisibleOnframe = !0
        }, v.prototype.toPhysics2 = function() {
            this.gamecore.isAlleyOop = !0, this.body.space = this.space2, this.updateGraphic(), this.graphic.visible = !0
        }, v.prototype.playSnd = function(t) {
            var e, i;
            0 === t ? b.default.getInstance().play(g.Sounds.b_net) : 1 === t ? (i = void 0, i = 300 < (e = Math.abs(this.body.velocity.length)) ? 1 : e / 300 * .8, b.default.getInstance().play(g.Sounds.b_ring, i)) : 2 === t && b.default.getInstance().play(g.Sounds.b_basket)
        }, v.prototype.onDownSensor = function() {
            this.setState("score"), this.playSnd(0)
        }, v.prototype.onShieldCollision = function(t) {
            "score" !== this.state && (b.default.getInstance().play(g.Sounds.b_steel), this.body.velocity.setxy(-t * (200 + 100 * Math.random()), -200 - 100 * Math.random()), this.setState("basket"))
        }, v.prototype.update = function(t) {
            void 0 === t && (t = 0), this.player && 0 < this.body.velocity.y && (this.player.continueAlleyOop(), this.player = null), this.setVisibleOnframe && (this.setVisibleOnframe = !1, this.graphic.visible = !0, this.shadow.show())
        }, v.prototype.release = function() {
            this.shadow = null, this.space1 = null, this.space2 = null, this.indent.dispose(), this.indent = null, this.player = null, a.prototype.release.call(this)
        }, v);

    function v() {
        var t = a.call(this) || this;
        return t.isWaiting = !1, t.setVisibleOnframe = !1, t.gamecore = c.MainGameCore.instance, t.objType = u.ObjectsType.BALL, t.width = d.default.WIDTH, t.velUp = p.ObjectsData.BALL_UP_VELOCITY_Y, t.bounceVel = p.ObjectsData.BALL_BOUNCE, t.stealVelXBase = p.ObjectsData.BALL_STEAL_VELOCITY_X_BASE, t.stealVelXAdd = p.ObjectsData.BALL_STEAL_VELOCITY_X_ADD, t.stealVelY = p.ObjectsData.BALL_STEAL_VELOCITY_Y, t.xB1 = p.ObjectsData.BASKET_CENTER, t.xB2 = p.ObjectsData.BASKET_CENTER2, t.yB = p.ObjectsData.BASKET_HEIGHT, t.gravity = p.ObjectsData.GRAVITY.y * p.ObjectsData.BALL_GRAVMASS, t.alleyOopX1 = p.ObjectsData.ALLEY_OOP_X, t.alleyOopX2 = t.width - p.ObjectsData.ALLEY_OOP_X, t.alleyOopY = p.ObjectsData.ALLEY_OOP_Y, t.baseDispersion = p.ObjectsData.DISPERSION, t.vertDispersion = p.ObjectsData.VERTICAL_DISPERSION, t.maxVelX = p.ObjectsData.PLAYER_MOVE_WITH_BALL, t.basket1 = p.ObjectsData.BASKET_CENTER, t.basket2 = p.ObjectsData.BASKET_CENTER2, t.createBody(), t.createGraphic(), t.indent = o.get(d.default.WIDTH2, p.ObjectsData.BALL_INDENT_Y_CENTER), a.prototype.add.call(t), t.space1 = t.body.space, t
    }
    e.BallObject = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = i(0),
        h = nape.geom.Ray,
        l = nape.geom.Vec2,
        c = i(22),
        u = i(3),
        d = i(1),
        n = (a = o.GameObject, n(p, a), p.prototype.update = function(t) {
            var e;
            void 0 === t && (t = 0), this.space && this.graphic.visible && (this.ray.origin = l.weak(this.owner.x, this.owner.y), (e = this.space.rayCast(this.ray, !1, o.Filters.RAY)) && (t = this.ray.at(e.distance), this.graphic.x = t.x, this.graphic.y = t.y, this.graphic.alpha = 0 < 1 - e.distance / this.dist ? 1 - e.distance / this.dist : 0, t.dispose(), e.dispose()))
        }, p.prototype.release = function() {
            this.space = null, this.owner = null, this.ray.origin.dispose(), this.ray.direction.dispose(), this.ray = null, a.prototype.release.call(this)
        }, p.prototype.show = function() {
            this.graphic.visible = !0, this.update()
        }, p.prototype.hide = function() {
            this.graphic.visible = !1
        }, p);

    function p(t, e) {
        var i, s = a.call(this) || this;
        return s.objType = o.ObjectsType.SHADOW, s.space = c.NapePhysics.space, s.owner = t, s.ray = new h(l.weak(t.x, t.y), l.weak(0, 1)), s.graphic = new r.Sprite(u.default.game, 0, 0, d.Atlases.Gameplay, "ShadowMC0002"), s.graphic.anchor.set(.5), s.dist = 250, 0 === e ? (s.dist = 400, s.graphic.scale.set(.7)) : 1 === e || (2 === e ? ((i = new Phaser.Image(u.default.game, 0, 0, d.Atlases.Gameplay, "ShadowMC0000")).anchor.set(.5), s.graphic.addChild(i)) : 3 === e && ((i = new Phaser.Image(u.default.game, 0, 0, d.Atlases.Gameplay, "ShadowMC0001")).anchor.set(.5), s.graphic.addChild(i))), a.prototype.add.call(s), s
    }
    e.ShadowObject = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.create = function() {
        var t;
        n.botsSkills.push({
            accuracy: .01,
            chanceToCompleteDunk: .9,
            coolDown: 18
        }), t = {
            accuracy: .14,
            chanceToCompleteDunk: .4,
            jumpBall: .45,
            chanceToRebound: .3,
            attack: .4,
            attackAtOnce: .2,
            avoidSteal: .2,
            makePump: .5,
            reactOnOpponent: .3,
            makeDash: 1,
            delayDash: 5,
            defence: .5,
            jumpThrow: .3,
            makeSteal: .3,
            delaySteal: 3,
            jumpPump: .8,
            makeBlock: .2,
            reboundFixed: .35,
            reboundRange: .1,
            moveDelay: .1,
            coolDown: 48
        }, n.botsSkills.push(t), t = {
            accuracy: .12,
            chanceToCompleteDunk: .45,
            jumpBall: .45,
            chanceToRebound: .35,
            attack: .4,
            attackAtOnce: .3,
            avoidSteal: .3,
            makePump: .5,
            reactOnOpponent: .4,
            makeDash: 1,
            delayDash: 4.5,
            defence: .5,
            jumpThrow: .4,
            makeSteal: .4,
            delaySteal: 2.5,
            jumpPump: .7,
            makeBlock: .3,
            reboundFixed: .3,
            reboundRange: .1,
            moveDelay: .08,
            coolDown: 48
        }, n.botsSkills.push(t), t = {
            accuracy: .1,
            chanceToCompleteDunk: .5,
            jumpBall: .45,
            chanceToRebound: .4,
            attack: .35,
            attackAtOnce: .4,
            avoidSteal: .4,
            makePump: .5,
            reactOnOpponent: .5,
            makeDash: 1,
            delayDash: 4,
            defence: .45,
            jumpThrow: .6,
            makeSteal: .5,
            delaySteal: 2,
            jumpPump: .6,
            makeBlock: .4,
            reboundFixed: .25,
            reboundRange: .1,
            moveDelay: .06,
            coolDown: 35
        }, n.botsSkills.push(t), t = {
            accuracy: .08,
            chanceToCompleteDunk: .6,
            jumpBall: .4,
            chanceToRebound: .5,
            attack: .3,
            attackAtOnce: .5,
            avoidSteal: .5,
            makePump: .5,
            reactOnOpponent: .6,
            makeDash: 1,
            delayDash: 3,
            defence: .3,
            jumpThrow: .8,
            makeSteal: .6,
            delaySteal: 1,
            jumpPump: .5,
            makeBlock: .5,
            reboundFixed: .2,
            reboundRange: .1,
            moveDelay: .05,
            coolDown: 35
        }, n.botsSkills.push(t), t = {
            accuracy: .04,
            chanceToCompleteDunk: .7,
            jumpBall: .4,
            chanceToRebound: .7,
            attack: .3,
            attackAtOnce: .6,
            avoidSteal: .6,
            makePump: .5,
            reactOnOpponent: .6,
            makeDash: 1,
            delayDash: 3,
            defence: .3,
            jumpThrow: 1,
            makeSteal: .7,
            delaySteal: 1,
            jumpPump: .5,
            makeBlock: .5,
            reboundFixed: .2,
            reboundRange: .1,
            moveDelay: .05,
            coolDown: 28
        }, n.botsSkills.push(t), t = {
            accuracy: .03,
            chanceToCompleteDunk: .75,
            jumpBall: .3,
            chanceToRebound: .8,
            attack: .2,
            attackAtOnce: .7,
            avoidSteal: .7,
            makePump: .5,
            reactOnOpponent: .7,
            makeDash: 1,
            delayDash: 2.5,
            defence: .2,
            jumpThrow: 1,
            makeSteal: .8,
            delaySteal: 1,
            jumpPump: .4,
            makeBlock: .5,
            reboundFixed: .15,
            reboundRange: .1,
            moveDelay: .05,
            coolDown: 28
        }, n.botsSkills.push(t), t = {
            accuracy: .02,
            chanceToCompleteDunk: .8,
            jumpBall: .2,
            chanceToRebound: .9,
            attack: .1,
            attackAtOnce: .8,
            avoidSteal: .8,
            makePump: .5,
            reactOnOpponent: .8,
            makeDash: 1,
            delayDash: 2,
            defence: .1,
            jumpThrow: 1,
            makeSteal: .9,
            delaySteal: 1,
            jumpPump: .3,
            makeBlock: .8,
            reboundFixed: .1,
            reboundRange: .1,
            moveDelay: .05,
            coolDown: 28
        }, n.botsSkills.push(t), t = {
            accuracy: .01,
            chanceToCompleteDunk: .9,
            jumpBall: .1,
            chanceToRebound: 1,
            attack: .05,
            attackAtOnce: .9,
            avoidSteal: .9,
            makePump: .5,
            reactOnOpponent: .9,
            makeDash: 1,
            delayDash: 2,
            defence: .05,
            jumpThrow: 1,
            makeSteal: .9,
            delaySteal: 1,
            jumpPump: .2,
            makeBlock: 1,
            reboundFixed: 0,
            reboundRange: .1,
            moveDelay: .05,
            coolDown: 28
        }, n.botsSkills.push(t)
    }, n.botsSkills = [], n);

    function n() {}
    e.AISkillsData = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(25),
        r = i(13),
        h = i(4),
        l = i(2),
        c = i(21),
        u = i(89),
        d = i(90),
        p = i(91),
        f = i(15),
        n = (a = o.BaseController, n(g, a), g.prototype.initZones = function() {
            1 === this.SIDE ? (this.attackZoneStart = l.ObjectsData.ATTACK_ZONE_START, this.attackZoneEnd = l.ObjectsData.ATTACK_ZONE_END, this.dashZoneStart = l.ObjectsData.DASH_ZONE_START, this.dashZoneEnd = l.ObjectsData.DASH_ZONE_END, 0 === this.playerNo ? (this.baseEndPoint = 280, this.reboundPointInAttack = 190, this.reboundPointInDefence = 610) : (this.baseEndPoint = 400, this.reboundPointInAttack = 150, this.reboundPointInDefence = 680)) : (this.attackZoneStart = this.width - l.ObjectsData.ATTACK_ZONE_END, this.attackZoneEnd = this.width - l.ObjectsData.ATTACK_ZONE_START, this.dashZoneStart = this.width - l.ObjectsData.DASH_ZONE_END, this.dashZoneEnd = this.width - l.ObjectsData.DASH_ZONE_START, 0 === this.playerNo ? (this.baseEndPoint = 580, this.reboundPointInAttack = 610, this.reboundPointInDefence = 190) : (this.baseEndPoint = 400, this.reboundPointInAttack = 650, this.reboundPointInDefence = 120))
        }, g.prototype.init = function(t) {
            this.jumpBall = new u.NegativeDelay(l.ObjectsData.IDEAL_JUMP_BALL_JUMP, t.jumpBall), this.attack = new c.FullDelay(l.ObjectsData.IDEAL_ATTACK_JUMP, t.attack), this.attackJumpDelay = new d.SimpleDelay(t.attackAtOnce), this.chanceToRebound = t.chanceToRebound, this.chanceToAvoidSteal = t.avoidSteal, this.chanceToMakePump = t.makePump, this.chanceToReactOnCloseOpponent = t.reactOnOpponent, this.chanceToDash = t.makeDash, this.dashDelay = new p.AIUseDelay(.1, t.delayDash), this.defence = new d.SimpleDelay(t.defence), this.chanceToJumpWhenThrow = t.jumpThrow, this.chanceToUseSteal = t.makeSteal, this.stealDelay = new p.AIUseDelay(.1, l.ObjectsData.STEAL_DURATION + t.delaySteal), this.chanceToJumpWhenPump = t.jumpPump, this.chanceToBlock = t.makeBlock, this.blockDelay = new c.FullDelay(0, .2), this.reboundDelay = new c.FullDelay(t.reboundRange, t.reboundFixed), this.moveDelay = new c.FullDelay(t.moveDelay, .05), this.opponentDelta = l.ObjectsData.OPPONENT_DELTA, this.chanceForThree = l.ObjectsData.CHANCE_FOR_THREE, this.initZones()
        }, g.prototype.restart = function(t) {
            this.strategy = 3, 0 === t && this.onJumpBall(), this.deltaDownTime = 0, this.endPoint = this.baseEndPoint, this.currentSuper = !1, this.resetAllDelays(), this.resetCurrents(), this.isPumped = !1, this.pumpCount = 0, this.canJump = !0, this.willAttackAtOnce = !1, a.prototype.restart.call(this, t)
        }, g.prototype.onJumpBall = function() {}, g.prototype.resetCurrents = function(t, e, i, s) {
            void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 0), this.currentMove = t, this.currentJump = e, this.currentAction = i, this.currentDash = s
        }, g.prototype.resetBaseDelays = function() {
            this.attackJumpDelay.reset(), this.attack.reset(), this.defence.reset(), this.moveDelay.reset(), this.stealDelay.reset(), this.resetAvoidSteal()
        }, g.prototype.resetAllDelays = function() {
            this.dashDelay.reset(), this.resetBaseDelays()
        }, g.prototype.resetAvoidSteal = function() {
            this.avoidStealJump = !1, this.avoidStealMove = 0
        }, g.prototype.ballInOwnHands = function(t) {
            void 0 === t && (t = 0), 0 === this.superID && this.player.readyForSuper && this.megaDunkDelay.activate(), this.resetBaseDelays(), this.resetCurrents(), this.strategy = 2;
            t = this.isReboundInAttackZone(); - 1 === t ? (this.willAttackAtOnce = !this.player.isGrounded, this.setAttackPoint(150, this.player.getX())) : 0 === t ? (this.willAttackAtOnce = !this.player.isGrounded, t = this.player.getX(), this.setAttackPoint(t, t)) : (this.setAttackPoint(0), Math.abs(this.player.getX() - this.attackPoint) < 50 ? this.willAttackAtOnce = !this.player.isGrounded : this.willAttackAtOnce = !1), this.willAttackAtOnce && (this.canJump = !1)
        }, g.prototype.ballInOpponentsHands = function(t) {
            void 0 === t && (t = 0), this.resetBaseDelays(), this.resetCurrents(), this.willAttackAtOnce = !1, this.isPumped = !1, this.strategy = 0
        }, g.prototype.ballOwnShoot = function(t) {
            void 0 === t && (t = 0), this.resetCurrents(), this.strategy = 4, this.reboundPoint = this.reboundPointInAttack
        }, g.prototype.ballOpponentShoot = function(t) {
            void 0 === t && (t = 0), 1 === this.superID && this.superShot(!0), this.resetCurrents(), this.strategy = 4, this.currentJump = this.opponent.isGrounded && this.isOpponentCloseBehind(120) && Math.random() <= this.chanceToJumpWhenThrow, this.reboundPoint = this.reboundPointInDefence
        }, g.prototype.ballOthers = function() {
            this.strategy = 1
        }, g.prototype.setAttackPoint = function(t, e) {
            void 0 === e && (e = 0), 0 != t ? (this.attackPoint = t, this.jumpPoint = e) : (0 < (this.player.getX() - 450) * this.SIDE && Math.random() <= this.chanceForThree ? this.attackPoint = 510 : Math.random() <= .7 ? this.attackPoint = 120 + 200 * Math.random() : this.attackPoint = 320 + 160 * Math.random(), this.jumpPoint = this.attackPoint <= 200 ? this.attackPoint + 100 : this.attackPoint), -1 === this.SIDE && (this.attackPoint = this.width - this.attackPoint, this.jumpPoint = this.width - this.jumpPoint)
        }, g.prototype.processPlayerSignal = function(t, e, i) {
            void 0 === i && (i = 0), "startSteal" === t ? this.playerStartSteal(e, i) : "steal" === t ? this.playerSteal(e, i) : "jumpA" === t ? this.playerJumpA(e, i) : "pump" === t ? this.playerPump(e, i) : "dash" === t ? this.playerDash(e, i) : "stun" === t && this.playerStun(e, i)
        }, g.prototype.playerStartSteal = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === -t ? this.player.withBall && this.player.isGrounded && (this.isOpponentCloseBehind(80) || this.isOpponentCloseBehind(140) && this.opponent.isMoving()) && this.tryToAvoid() : this.stealDelay.useIt()
        }, g.prototype.tryToAvoid = function() {
            var t;
            (Math.random() <= this.chanceToAvoidSteal || 600 < this.player.getX()) && ((t = Math.random()) <= .1 && this.player.isReadyToDash() ? this.currentDash = -this.SIDE : t <= .4 && this.isInAttackZone() ? (this.avoidStealJump = !0, this.moveDelay.reset()) : this.avoidStealMove = this.SIDE)
        }, g.prototype.playerJumpA = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === t ? e === this.playerNo && (this.resetAvoidSteal(), this.attack.activate(), this.throwPoint = this.player.getX(), this.directionToFly = 0 <= this.player.getX() - this.attackPoint ? -1 : 1) : Math.random() <= this.chanceToJumpWhenThrow && this.defence.activate()
        }, g.prototype.playerPump = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === -t && this.player.canAct && ++this.pumpCount <= 3 && this.isOpponentCloseBehind(90) && Math.random() <= this.chanceToJumpWhenPump && (this.defence.activate(), this.stealDelay.reset(), this.currentMove = 0, this.isPumped = !0)
        }, g.prototype.playerDash = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === t ? this.attack.reset() : 0 === this.strategy && this.player.canAct && this.isOpponentInRangeBehind() && Math.random() <= this.chanceToBlock && (this.resetCurrents(), this.resetAllDelays(), this.currentBlockOrPump = !0)
        }, g.prototype.playerStun = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === t && this.resetAllDelays()
        }, g.prototype.playerSteal = function(t, e) {
            void 0 === e && (e = 0), this.SIDE === -t && this.resetAvoidSteal()
        }, g.prototype.playerOnGround = function() {
            this.isPumped = !1, this.player.withBall && this.willAttackAtOnce && (this.resetCurrents(), this.attackJumpDelay.activate())
        }, g.prototype.playerOnDashEnd = function() {
            (this.player.getX() - this.attackPoint) * this.SIDE < 0 && (this.attackPoint = this.player.getX() - 10 * this.SIDE)
        }, g.prototype.playerOnBlock = function() {
            this.currentBlockOrPump = !1, this.blockDelay.activate()
        }, g.prototype.releaseBlockOrPump = function(t) {
            return 1 === this.blockDelay.update(t)
        }, g.prototype.isReboundInAttackZone = function() {
            var t = this.player.getX(),
                e = 0;
            return (t - this.attackZoneStart) * this.SIDE <= 0 ? e = -1 : 0 <= (t - this.attackZoneEnd) * this.SIDE && (e = 1), e
        }, g.prototype.isInAttackZone = function() {
            return 1 === this.SIDE ? this.player.getX() < 600 : 200 < this.player.getX()
        }, g.prototype.inDashingZone = function() {
            return this.playerX >= this.dashZoneStart
        }, g.prototype.moveToo = function(t) {
            t = this.player.getX() - t;
            return Math.abs(t) <= this.deltaDistance ? 0 : 0 < t ? -1 : 1
        }, g.prototype.moveInAttack = function() {
            var t = this.moveToo(this.jumpPoint);
            return t = 0 === t ? (this.attackJump = !0, this.jumpPoint === this.attackPoint ? 2 : this.moveToo(this.attackPoint)) : (this.attackJump = !1, this.moveToo(this.attackPoint))
        }, g.prototype.readyForAction = function() {
            return !0
        }, g.prototype.dispose = function() {
            f.Signals.PlayerSignal.remove(this.processPlayerSignal, this), this.gamecore = null, this.ball = null, this.opponent = null, this.opponents = null, this.superShot = null, this.attackJumpDelay = null, this.moveDelay = null, this.stealDelay = null, this.dashDelay = null, this.jumpBall = null, this.attack = null, this.defence = null, this.blockDelay = null, this.reboundDelay = null, this.megaDunkDelay = null, a.prototype.dispose.call(this)
        }, g.prototype.update = function(t) {
            this.currentDash = 0;
            var e = this.attackJumpDelay.update(t);
            0 <= e ? 1 === e ? (this.currentMove = 0, this.currentJump = !0, this.currentAction = !1, this.canJump = !0) : (this.currentMove = this.avoidStealMove, this.currentJump = this.avoidStealJump) : (this.calcPositions(), 0 === this.strategy ? this.strategyDefence(t) : 1 === this.strategy ? this.strategyBallFight(t) : 2 === this.strategy ? this.strategyAttack(t) : 3 === this.strategy ? this.strategyJumpBall(t) : 4 === this.strategy ? this.strategyRebound(t) : 5 === this.strategy && this.strategyDefence2(t))
        }, g.prototype.calcPositions = function() {
            this.playerX = this.player.getX(), this.opponentX = this.opponent.getX()
        }, g.prototype.strategyDefence = function(t) {
            var e = this.stealDelay.update(t),
                i = this.moveDelay.update(t);
            this.isPumped ? this.currentMove = 0 : (this.player.isGrounded ? -1 === i && (i = (this.opponentX - this.endPoint) * this.SIDE < 0 ? this.endPoint : this.opponent.isGrounded ? this.opponentX + this.SIDE * this.opponentDelta : this.opponentX + this.SIDE * (this.opponentDelta - 10), this.currentMove = this.moveToo(i), this.moveDelay.activate()) : this.currentMove = this.moveToo(this.opponentX + this.SIDE * (this.opponentDelta - 10)), -1 === e && this.tryToSteal()), this.currentJump = 1 === this.defence.update(t) && this.isOpponentCloseAbs(180), this.currentAction = 1 === e, !1 === this.currentAction && !1 === this.currentJump && 0 === this.currentMove ? (this.deltaDownTime += this.incDownTime, this.deltaDownTime >= this.downTime && (this.endPoint = 1 === this.SIDE ? 0 : this.width, this.deltaDownTime = 0)) : this.deltaDownTime = 0
        }, g.prototype.tryToSteal = function() {
            this.opponent.isGrounded && (this.isOpponentCloseBehind(80) ? Math.random() <= this.chanceToUseSteal ? this.stealDelay.activate() : this.stealDelay.skipIt() : this.isOpponentCloseToBasket(45) && (Math.random() <= 1.5 * this.chanceToUseSteal ? this.stealDelay.activate() : this.stealDelay.skipIt()))
        }, g.prototype.strategyDefence2 = function(t) {}, g.prototype.strategyBallFight = function(t) {
            var e = this.ball.getX(),
                i = 0 <= e - this.playerX ? 10 : -10,
                t = this.reboundDelay.update(t);
            this.currentMove = this.moveToo(e + i), this.currentJump = !1, "bounce" != this.ball.state && "shooting" != this.ball.state && ("basket" === this.ball.state ? -1 === t && this.isBallInReboundZone() ? this.reboundDelay.activate() : this.currentJump = 1 === t && Math.random() < +this.chanceToRebound && this.isBallInReboundZone() : this.currentJump = Math.abs(this.deltaBallX()) < 60 && 70 < Math.abs(this.deltaBallY())), this.currentAction = !1
        }, g.prototype.isBallInReboundZone = function() {
            return Math.abs(this.deltaBallX()) < 60 && 70 < Math.abs(this.deltaBallY())
        }, g.prototype.strategyAttack = function(t) {
            var e;
            this.player.withBall && (1 === this.megaDunkDelay.update(t) ? this.currentSuper = !0 : this.avoidStealJump || 0 != this.avoidStealMove ? (this.currentMove = this.avoidStealMove, this.currentJump = this.avoidStealJump) : this.player.isGrounded ? -1 === this.moveDelay.update(t) && (e = this.moveInAttack(), this.attackJump ? (this.currentJump = !0, this.currentMove = e) : this.isAICloserForBasket() ? e === -this.SIDE ? (this.currentMove = -this.SIDE, this.currentJump = !1) : (this.currentMove = e, this.currentJump = !0) : (this.currentJump = !1, this.currentDash = 0, this.isOpponentCloseBehind() ? this.isUnderOwnBasket() ? this.player.readyForDash ? (this.currentDash = -this.SIDE, this.currentMove = 0) : (Math.random() <= .5 ? this.currentMove = -this.SIDE : this.currentMove = 0, this.moveDelay.activate()) : Math.random() <= this.chanceToReactOnCloseOpponent ? (this.currentJump = !1, this.player.readyForDash && this.inDashingZone() && Math.random() <= this.chanceToDash ? this.currentDash = -this.SIDE : (Math.random() <= .5 ? this.currentMove = 0 : this.currentMove = this.SIDE, this.moveDelay.activate())) : (this.currentMove = -this.SIDE, this.moveDelay.activate()) : this.currentMove = -this.SIDE)) : (this.currentMove = 0 < (this.playerX - this.attackPoint) * this.directionToFly ? this.directionToFly : 0, this.currentJump = !1, this.currentAction = 1 === this.attack.update(t)))
        }, g.prototype.strategyJumpBall = function(t) {
            this.currentMove = 0, this.currentJump = 1 === this.jumpBall.update(t), this.currentAction = !1
        }, g.prototype.strategyRebound = function(t) {
            this.currentJump ? this.currentMove = 0 : this.currentMove = this.player.isGrounded ? this.moveToo(this.reboundPoint) : 0
        }, g.prototype.deltaBallX = function() {
            return this.player.getX() - this.ball.getX()
        }, g.prototype.deltaBallY = function() {
            return this.player.getY() - this.ball.getY()
        }, g.prototype.isOpponentCloseBehind = function(t) {
            void 0 === t && (t = 100);
            var e = (this.player.getX() - this.opponent.getX()) * this.SIDE;
            return 0 < e && e <= t
        }, g.prototype.isOpponentInRangeBehind = function(t, e) {
            void 0 === t && (t = 40), void 0 === e && (e = 180);
            var i = (this.player.getX() - this.opponent.getX()) * this.SIDE;
            return 0 < i && t <= i && i <= e
        }, g.prototype.isOpponentCloseToBasket = function(t) {
            void 0 === t && (t = 30);
            var e = (this.playerX - this.opponentX) * this.SIDE;
            return e < 0 && 0 <= e + t
        }, g.prototype.isAICloserForBasket = function() {
            return (this.playerX - this.opponentX) * this.SIDE < 0
        }, g.prototype.isOpponentCloseAbs = function(t) {
            return void 0 === t && (t = 100), Math.abs(this.playerX - this.opponentX) <= t
        }, g.prototype.isUnderOwnBasket = function() {
            return 1 === this.SIDE ? 700 < this.playerX : this.playerX < 100
        }, g);

    function g(t, e) {
        var i = a.call(this, t) || this;
        return i.deltaDistance = 20, i.chanceToBlock = 1, i.downTime = 5, i.superShot = e, i.superID = t.superID, i.megaDunkDelay = new c.FullDelay(.5, .5), i.gamecore = r.MainGameCore.instance, i.ball = i.gamecore.ball, i.opponents = -1 === i.SIDE ? i.gamecore.playersRight : i.gamecore.playersLeft, i.playerNo = t.playerNo, i.width = h.default.WIDTH, i.delta = -1 === i.SIDE ? 0 : h.default.WIDTH, i.incDownTime = h.default.STEP, f.Signals.PlayerSignal.add(i.processPlayerSignal, i), i
    }
    e.BaseAIController = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(25),
        n = (a = i.BaseController, n(o, a), o.prototype.update = function() {
            this.currentMove = 0
        }, o.prototype.readyForAction = function() {
            return !1
        }, o.prototype.releaseBlockOrPump = function() {
            return !1
        }, o);

    function o(t) {
        return a.call(this, t) || this
    }
    e.PlayerBaseController = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(1),
        r = i(16),
        h = i(9),
        l = i(3),
        c = i(10),
        n = (a = Phaser.State, n(u, a), u.prototype.preload = function() {
            a.prototype.preload.call(this);
            var t = r.default.getInstance().checkDomain(document.URL.split("//")[1].split("/")[0]); - 1 === document.URL.indexOf("84.42.47.232") && -1 === document.URL.indexOf("192.168.10.226") && -1 === document.URL.indexOf("iriysoft.com") || (t = !0), t ? this.preloadSplash() : this.preloadLock()
        }, u.prototype.init = function() {
            a.prototype.init.call(this), this.mainParent = this.game.add.group(), this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2, this.setPauseViewCar(this.mainParent)
        }, u.prototype.preloadLock = function() {
            this.game.load.atlas(o.Atlases.Preloader, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/x1/" + o.Atlases.Preloader + ".png", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/x1/" + o.Atlases.Preloader + ".json")
        }, u.prototype.preloadSplash = function() {
            new h.default(this.game, 0, l.default.Name)
        }, u.prototype.createLock = function() {
            this.logo = this.game.add.image(0, -30, o.Atlases.Preloader, "branding_l20000"), this.logo.anchor.set(.5), this.logo.inputEnabled = !0, this.logo.input.useHandCursor = !0, this.logo.events.onInputDown.add(this.opensitelockLink, this);
            var t = {
                    font: "25px Impact2",
                    fill: "#A8DB2B"
                },
                e = {
                    font: "25px Impact2",
                    fill: "#FFFFFF"
                },
                i = new c.default(this.game, 0, -200, "This is version is url-locked", t),
                s = new c.default(this.game, 0, -160, r.default.getInstance().getUrlLock(), e),
                t = new c.default(this.game, 0, 100, "Contact to license this game", t),
                e = new c.default(this.game, 0, 140, "madpuffers@gmail.com", e);
            i.anchor.set(.5), s.anchor.set(.5), t.anchor.set(.5), e.anchor.set(.5), this.mainParent.addChild(this.logo), this.mainParent.addChild(i), this.mainParent.addChild(s), this.mainParent.addChild(t), this.mainParent.addChild(e)
        }, u.prototype.opensitelockLink = function() {
            window.open(r.default.getInstance().getUrlLock(), "_blank")
        }, u.prototype.createSplash = function() {
            new h.default(this.game, 0, l.default.Name)
        }, u.prototype.fileComplete = function(t, e, i, s, n) {
            100 === t && this.game.load.onFileComplete.removeAll()
        }, u.prototype.setPauseViewCar = function(t) {
            null !== this.bike && this.bike.destroy(), this.bike = this.game.add.group(t), this.bike.x = 0, this.bike.y = 10
        }, u.prototype.create = function() {
            a.prototype.create.call(this);
            var t = r.default.getInstance().checkDomain(document.URL.split("//")[1].split("/")[0]); - 1 === document.URL.indexOf("84.42.47.232") && -1 === document.URL.indexOf("192.168.10.38") && -1 === document.URL.indexOf("iriysoft.com") || (t = !0), t ? this.createSplash() : this.createLock()
        }, u.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / o.Constants.WIDTH) ? 1 : t, this.mainParent && (this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2), a.prototype.resize.call(this)
        }, u.prototype.shutdown = function() {
            a.prototype.shutdown.call(this)
        }, u.Name = "sitelock", u);

    function u() {
        var t = a.call(this) || this;
        return t.name = u.Name, t.bike = null, t.logo = null, t.mainParent = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(1),
        h = i(2),
        l = i(8),
        c = i(5),
        u = i(10),
        n = (a = Phaser.Group, n(d, a), d.prototype.onGameModeClick = function(t) {
            c.default.getInstance().play(r.Sounds.button);
            t = parseInt(t.parent.parent.id) - 1;
            h.Inventory.instance.matchData.matchMode = t, this.setButtonsState(t), null !== this.context && this.context.processMatchMode()
        }, d.prototype.updateIcon = function(t, e) {
            for (var i = 2; i < t.btn.children.length; i++) {
                var s = t.btn.children[i];
                this.updateSingleIcon(s, e), 1 === e && (this.btnSelect.x = t.x, this.btnSelect.y = t.y)
            }
        }, d.prototype.updateSingleIcon = function(t, e) {
            t.loadTexture(r.Atlases.Interface, "iconPl000" + e)
        }, d.prototype.setButtonsState = function(t) {
            0 === t ? (this.updateIcon(this.btn1, 1), this.updateIcon(this.btn2, 0), this.updateIcon(this.btn3, 0), 4 === h.Inventory.instance.gameMode && (this.cpu.visible = !0, this.cpu2.visible = !1)) : 1 === t ? (this.updateIcon(this.btn1, 0), this.updateIcon(this.btn2, 1), this.updateIcon(this.btn3, 0), 4 === h.Inventory.instance.gameMode && (this.cpu.visible = !0, this.cpu2.visible = !1)) : 2 === t && (this.updateIcon(this.btn1, 0), this.updateIcon(this.btn2, 0), this.updateIcon(this.btn3, 1), 4 === h.Inventory.instance.gameMode && (this.cpu.visible = !1, this.cpu2.visible = !0))
        }, d.prototype.hideBG = function() {
            this.bg.visible = !1, this.ccc.visible = !1
        }, d.prototype.showCurrentMode = function() {
            (this.btn1.y = this.btn2.y = this.btn3.y = this.btnSelect.y = 0) === h.Inventory.instance.matchData.matchMode ? (this.btn1.visible = !0, this.btn2.visible = !1, this.btn3.visible = !1) : 1 === h.Inventory.instance.matchData.matchMode ? (this.btn1.visible = !1, this.btn2.visible = !0, this.btn3.visible = !1) : 2 === h.Inventory.instance.matchData.matchMode && (this.btn1.visible = !1, this.btn2.visible = !1, this.btn3.visible = !0)
        }, d.prototype.destroy = function() {
            this.btn1 = null, this.btn2 = null, this.btn3 = null, this.context = null, a.prototype.destroy.call(this)
        }, d);

    function d(t) {
        var e = a.call(this, o.default.game) || this;
        e.context = null, e.context = t, e.bg = e.game.add.sprite(0, 0, r.Atlases.Interface, "0bg130000"), e.bg.anchor.set(.5), e.addChild(e.bg);
        e.ccc = new u.default(e.game, 0, -90, "MODE", {
            font: "bold 42px Impact2",
            fill: "#FFFFFF"
        }), e.ccc.anchor.set(.5), e.addChild(e.ccc), e.btn1 = new l.default(e.game, "VS", r.Constants.styleVS, e.onGameModeClick, e, r.Atlases.Interface), e.btn2 = new l.default(e.game, "VS", r.Constants.styleVS, e.onGameModeClick, e, r.Atlases.Interface), e.btn3 = new l.default(e.game, "VS", r.Constants.styleVS, e.onGameModeClick, e, r.Atlases.Interface), e.btnSelect = new l.default(e.game, "VS", r.Constants.styleVS2, null, null, r.Atlases.Interface), e.btn1.y = -30, e.btn2.y = 30, e.btn3.y = 90, e.btn1.btn.id = "1", e.btn2.btn.id = "2", e.btn3.btn.id = "3", e.btn1.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.btn2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.btn3.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.btnSelect.setFrames("selectModeBg0000", "selectModeBg0000", "selectModeBg0000", "selectModeBg0000"), e.btn1.setProp("#000000", 3, "#FFFFFF", 5), e.btn2.setProp("#000000", 3, "#FFFFFF", 5), e.btn3.setProp("#000000", 3, "#FFFFFF", 5), e.btnSelect.setProp("#000000", 3, "#FFFFFF", 5), e.addChild(e.btn1), e.addChild(e.btn2), e.addChild(e.btn3), e.addChild(e.btnSelect);
        var i = e.game.add.image(-47, 0, r.Atlases.Interface, "iconPl0000");
        return i.anchor.set(.5), e.btn1.btn.addChild(i), (i = e.game.add.image(47, 0, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn1.btn.addChild(i), (i = e.game.add.image(-55, -2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn2.btn.addChild(i), (i = e.game.add.image(-35, 2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn2.btn.addChild(i), (i = e.game.add.image(55, -2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn2.btn.addChild(i), (i = e.game.add.image(35, 2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn2.btn.addChild(i), (i = e.game.add.image(55, -2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn3.btn.addChild(i), (i = e.game.add.image(35, 2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn3.btn.addChild(i), 4 !== h.Inventory.instance.gameMode ? ((i = e.game.add.image(-45, 0, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn3.btn.addChild(i), e.bg.crop(new Phaser.Rectangle(0, 0, 162, 100), !1), e.bg.anchor.set(.5, 1), e.bg.y -= 30, (t = e.game.add.sprite(0, -30, r.Atlases.Interface, "0bg130000")).anchor.set(.5, 1), t.crop(new Phaser.Rectangle(0, 0, 162, 100), !1), t.angle = 180, e.addChildAt(t, 0), e.btn3.visible = !1) : ((i = e.game.add.image(-55, -2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn3.btn.addChild(i), (i = e.game.add.image(-35, 2, r.Atlases.Interface, "iconPl0000")).anchor.set(.5), e.btn3.btn.addChild(i), e.cpu = new l.default(e.game, "CPU", r.Constants.styleCPU, null, null, r.Atlases.Interface), e.cpu.x = 60, e.cpu.y = 15, e.cpu.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.cpu.setProp("#000000", 3, "#FFFFFF", 5), e.btn3.addChild(e.cpu), e.cpu2 = new l.default(e.game, "CPU", r.Constants.styleCPU2, null, null, r.Atlases.Interface), e.cpu2.x = 60, e.cpu2.y = 15, e.cpu2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.cpu2.setProp("#000000", 3, "#FFFFFF", 5), e.btn3.addChild(e.cpu2), e.cpu2.visible = !1), e.setButtonsState(h.Inventory.instance.matchData.matchMode), e.btn1.btn.dynamicScaleDown = 1, e.btn1.btn.dynamicScaleUp = 1, e.btn2.btn.dynamicScaleDown = 1, e.btn2.btn.dynamicScaleUp = 1, e.btn3.btn.dynamicScaleDown = 1, e.btn3.btn.dynamicScaleUp = 1, e.btn1.btn.btn.scale.set(13, 5), e.btn2.btn.btn.scale.set(14, 5), e.btn3.btn.btn.scale.set(14, 5), e
    }
    e.MatchModePanel = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(7),
        l = i(17),
        c = i(9),
        u = i(2),
        d = i(11),
        p = i(8),
        f = i(12),
        g = i(26),
        m = i(103),
        y = i(16),
        b = i(53),
        v = i(104),
        _ = i(4),
        x = i(0),
        n = (a = Phaser.State, n(w, a), w.prototype.init = function() {
            this.game.world.removeAll(), this.manager = u.Inventory.instance, dragonBones.PhaserFactory.init(this.game)
        }, w.prototype.create = function() {
            a.prototype.create.call(this);
            var t, e = this.game.cache.getJSON(r.JSONData.DBPers),
                i = this.game.cache.getJSON(r.JSONData.DBPers_Texture),
                s = this.game.cache.getImage(r.Images.DBPers, !0).base;
            dragonBones.PhaserFactory.factory.parseDragonBonesData(e), dragonBones.PhaserFactory.factory.parseTextureAtlasData(i, s), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, c.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this.armatureDisplay.animation.play("idle", 0), this.armatureDisplay2 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this.armatureDisplay2.animation.play("idle", 0), this.logo = this.game.add.sprite(400, 100, r.Atlases.Interface, "bg0000"), this.logo.anchor.set(.5), this.logo.x = 400, this.backgroundBase2.addChild(this.logo), this.backBtn = new p.default(this.game, "RESTART", r.Constants.styleBackArrow, this.onBack, this, r.Atlases.Interface), this.backBtn.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.backBtn.setProp("#000000", 7, "#FFFFFF", 14), this.backBtn.x = 130, this.backBtn.y = 450, this.backgroundBase2.addChild(this.backBtn), 0 === u.Inventory.instance.gameMode && (t = this.manager.nextLeg()), this.setUp(), 3 === u.Inventory.instance.gameMode || 2 === u.Inventory.instance.gameMode ? this.nextState = f.Menu.Name : 0 === u.Inventory.instance.gameMode ? !0 === t[0] ? this.nextState = ("Standings" === t[1] ? f.TournamentState : b.default).Name : this.nextState = b.default.Name : this.nextState = g.default.Name, this.musicBtn = new h.default(this.game, "", {}, this.toggleMusic, this, r.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.musicBtn.sScale = 42 / this.musicBtn.btn.width, this.musicBtn.x = 772, this.musicBtn.y = 25, this.musicBtn.labelState = this.game.add.image(0, 0, r.Atlases.Gameplay, "InGameMusicButton0000"), this.backgroundBase2.addChild(this.musicBtn), this.updateSoundButtons(), this.playBtn = new p.default(this.game, "NEXT", r.Constants.stylePlayGreen, this.onNextState, this, r.Atlases.Interface), this.playBtn.setFrames("arrow20000", "arrow20000", "arrow20000", "arrow20000"), this.playBtn.btn.btn.x = 110, this.playBtn.x = 655, this.playBtn.y = 450, this.playBtn.setProp("#000000", 7, "#FFFFFF", 14), this.backgroundBase2.addChild(this.playBtn), this.resize(), new l.default(this.game, this, this.show)
        }, w.prototype.show = function() {
            var t = this.game.add.tween(this.scoreLabel);
            t.from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreText)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreBestLabel)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreBestText)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.playBtn)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.backBtn)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.branding2)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).from({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.panel.score)).from({
                y: -220
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.panel.title ? this.game.add.tween(this.panel.title) : this.game.add.tween(this.panel.title_state)).from({
                y: -220
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.panel.ccc)).from({
                x: -600
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.panel.team1)).from({
                x: -550
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.player1)).from({
                x: -550
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.panel.ccc2)).from({
                x: 600
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.panel.team2)).from({
                x: 550
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.player2)).from({
                x: 880
            }, _.default.PRELOADER_TIME, x.Easing.Back.Out), t.start()
        }, w.prototype.hide = function() {
            var t = this.game.add.tween(this.scoreLabel);
            t.to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreText)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreBestLabel)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreBestText)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.playBtn)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.backBtn)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).to({
                y: 520
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.panel.score)).to({
                y: -220
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.panel.title ? this.game.add.tween(this.panel.title) : this.game.add.tween(this.panel.title_state)).to({
                y: -220
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.panel.ccc)).to({
                x: -600
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.panel.team1)).to({
                x: -550
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.player1)).to({
                x: -550
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.panel.ccc2)).to({
                x: 600
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.panel.team2)).to({
                x: 550
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.player2)).to({
                x: 880
            }, _.default.PRELOADER_TIME, x.Easing.Linear.None), t.start()
        }, w.prototype.render = function() {
            dragonBones.PhaserFactory.factory.dragonBones.advanceTime(-1), a.prototype.render.call(this)
        }, w.prototype.setUp = function() {
            u.PlayersData.switchPlayer(this.armatureDisplay.armature, 2 * (u.Inventory.instance.matchData.teams[0] - 1) + u.Inventory.instance.matchData.players[0][0], 2 * u.Inventory.instance.matchData.teams[0] - 2), u.PlayersData.switchPlayer(this.armatureDisplay2.armature, 2 * (u.Inventory.instance.matchData.teams[1] - 1) + u.Inventory.instance.matchData.players[1][0], 2 * u.Inventory.instance.matchData.teams[1] - 2 + 1);
            var t = u.Inventory.instance.matchData.matchScore[0],
                e = u.Inventory.instance.matchData.matchScore[1];
            this.panel = new m.PreMatchPanelResult(2), e < t ? (this.armatureDisplay.armature.animation.play("happiness", -1), this.armatureDisplay2.armature.animation.play("sad", -1)) : (this.armatureDisplay.armature.animation.play("sad", -1), this.armatureDisplay2.armature.animation.play("happiness", -1)), this.player1 = this.game.add.group(), this.player1.x = 216, this.player1.y = 388, this.player2 = this.game.add.group(), this.player2.x = 584, this.player2.y = 388;
            e = this.game.add.sprite(0, 0, r.Atlases.Gameplay, "ShadowMC0002");
            e.scale.set(2.5), e.anchor.set(.5), this.player1.addChild(e), (e = this.game.add.sprite(0, 0, r.Atlases.Gameplay, "ShadowMC0002")).scale.set(2.5), e.anchor.set(.5), this.player2.addChild(e), this.player1.addChild(this.armatureDisplay.armature.display), this.player2.addChild(this.armatureDisplay2.armature.display), this.player1.scale.set(.9), this.player2.scale.set(-.9, .9), this.backgroundBase2.addChild(this.player1), this.backgroundBase2.addChild(this.player2), this.logo.addChild(this.panel), this.branding2 = new h.default(this.game, "", null, this.onMoreGames, this, r.Atlases.Preloader), this.branding2.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.branding2.y = 200, this.branding2.sScale = 1.2, y.default.getInstance().checkDomain(document.URL.split("//")[1].split("/")[0]) && (this.branding2.inputEnableChildren = !1), this.panel.addChild(this.branding2);
            this.leaderBoardBtn = new h.default(this.game, "LEADERBOARD", {
                font: " 20px Impact2",
                fill: "#FFFFFF"
            }, this.onScoreList, this, r.Atlases.Interface), this.leaderBoardBtn.setFrames("btnRect0000", "btnRect0000", "btnRect0000", "btnRect0000"), this.leaderBoardBtn.sScale = 1, this.leaderBoardBtn.sLabelScale = 1, this.leaderBoardBtn.label.y = 5, this.leaderBoardBtn.x = this.branding2.x, this.leaderBoardBtn.y = this.branding2.y + 100, this.leaderBoardBtn.visible = !1, this.panel.addChild(this.leaderBoardBtn), this.scoreLabel = new p.default(this.game, "SCORE:", r.Constants.styleIDnetScore, null, null, r.Atlases.Interface), this.scoreLabel.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreLabel.setProp("#000000", 5, "#FFFFFF", 10), this.scoreLabel.x = 250, this.scoreLabel.y = 460, this.backgroundBase2.addChild(this.scoreLabel), this.scoreBestLabel = new p.default(this.game, "BEST SCORE:", r.Constants.styleIDnetBestScore, null, null, r.Atlases.Interface), this.scoreBestLabel.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreBestLabel.setProp("#000000", 5, "#FFFFFF", 10), this.scoreBestLabel.x = 460, this.scoreBestLabel.y = 460, this.backgroundBase2.addChild(this.scoreBestLabel), this.scoreText = new p.default(this.game, "", r.Constants.styleIDnetScore2, null, null, r.Atlases.Interface), this.scoreText.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreText.x = 310, this.scoreText.y = 460, this.backgroundBase2.addChild(this.scoreText), this.scoreBestText = new p.default(this.game, "", r.Constants.styleIDnetBestScore2, null, null, r.Atlases.Interface), this.scoreBestText.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreBestText.x = 540, this.scoreBestText.y = 460, this.backgroundBase2.addChild(this.scoreBestText), 3 === u.Inventory.instance.gameMode || 2 === u.Inventory.instance.gameMode ? (this.scoreLabel.visible = !1, this.scoreText.visible = !1, this.scoreBestLabel.visible = !1, this.scoreBestText.visible = !1) : (this.backBtn.visible = !1, 0 === u.Inventory.instance.gameMode ? (this.scoreText.setText(u.Inventory.instance.getMatchScores() + ""), this.scoreBestText.setText(u.Inventory.instance.getTournamentScores() + ""), this.scoreBestText.setProp("#000000", 5, "#FFFFFF", 10), this.scoreText.setProp("#000000", 5, "#FFFFFF", 10)) : (this.scoreLabel.visible = !1, this.scoreText.visible = !1, this.scoreBestLabel.visible = !1, this.scoreBestText.visible = !1));
            t = this.manager.showAdditionalGUI();
            1 === t ? (this.popup = new v.PopupGUI(!1), this.popup.signalOk.addOnce(this.onOk, this), this.world.addChild(this.popup)) : 2 === t && (this.popup = new v.PopupGUI(!0), this.world.addChild(this.popup), e = this.game.add.group(this.popup.popup), t = void 0, (t = this.game.add.image(-55, 30, r.Atlases.Interface, "loginSelect0000")).anchor.set(.5), e.addChild(t), (t = this.game.add.image(45, 30, r.Atlases.Interface, "loginSelect0000")).anchor.set(.5), e.addChild(t), (t = this.game.add.image(-53, 122, r.Atlases.Gameplay, "btn_bg0000")).anchor.set(.5), t.scale.set(.43), e.addChild(t), (t = this.game.add.image(48, 122, r.Atlases.Gameplay, "btn_bg0000")).anchor.set(.5), t.scale.set(.43), e.addChild(t), (t = this.game.add.image(-53, 122, r.Atlases.Gameplay, "icon_ball0002")).anchor.set(.5), t.scale.set(.5), e.addChild(t), (t = this.game.add.image(48, 122, r.Atlases.Gameplay, "icon_ball0003")).anchor.set(.5), t.scale.set(.5), e.addChild(t), this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay.x = -50, this._armatureDisplay.y = 90, this._armatureDisplay.animation.play("idle", 0), e.addChild(this._armatureDisplay), u.PlayersData.switchPlayer(this._armatureDisplay.armature, 32, 32), this._armatureDisplay2 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay2.x = 50, this._armatureDisplay2.y = 90, this._armatureDisplay2.animation.play("idle", 0), e.addChild(this._armatureDisplay2), u.PlayersData.switchPlayer(this._armatureDisplay2.armature, 33, 32), this._armatureDisplay.scale.set(.65), this._armatureDisplay2.scale.set(.65), e.scale.set(.8))
        }, w.prototype.onOk = function() {
            u.Inventory.instance.checkForumAchievement(), window.open("https://forum.y8.com/t/basketball-legends/1741", "_blank")
        }, w.prototype.onMoreGames = function() {
            window.open(y.default.getInstance().getUrl(y.default.Current), "_blank")
        }, w.prototype.onScoreList = function() {
            o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.toggleMusic = function() {
            d.default.getInstance().music ? o.default.getInstance().toggleMusic() : d.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(r.Sounds.Click)
        }, w.prototype.updateSoundButtons = function() {
            var t = d.default.getInstance().music ? 0 : 1;
            t += d.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(r.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, w.prototype.onBack = function() {
            o.default.getInstance().play(r.Sounds.Click), u.Inventory.instance.matchData.resetScore(), new c.default(this.game, this, f.Gameplay.Name)
        }, w.prototype.onNextState = function() {
            o.default.getInstance().play(r.Sounds.Click), this.showBanner(), new c.default(this.game, this, this.nextState)
        }, w.prototype.showBanner = function() {
            "undefined" != typeof gdsdk && "undefined" !== gdsdk.showBanner && gdsdk.showBanner()
        }, w.prototype.resize = function() {
            a.prototype.resize.call(this);
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, this.popup && this.popup.resize(t)
        }, w.prototype.shutdown = function() {
            this.backgroundBase2 = null, this.backgroundBaseMask = null, this.backBtn = null, this.playBtn = null, this.musicBtn = null, this.armatureDisplay = null, this.armatureDisplay2 = null, a.prototype.shutdown.call(this)
        }, w.Name = "postmatchstate", w);

    function w() {
        var t = a.call(this) || this;
        return t.name = w.Name, t.player1 = null, t.player2 = null, t.armatureDisplay = null, t.armatureDisplay2 = null, t._armatureDisplay = null, t._armatureDisplay2 = null, t.manager = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(7),
        l = i(17),
        c = i(9),
        u = i(2),
        d = i(11),
        p = i(8),
        f = i(18),
        g = i(16),
        m = i(0),
        y = i(4),
        n = (a = Phaser.State, n(b, a), b.prototype.init = function() {
            this.game.world.removeAll(), this.manager = u.Inventory.instance, dragonBones.PhaserFactory.init(this.game)
        }, b.prototype.create = function() {
            a.prototype.create.call(this), this.background = this.game.add.sprite(0, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, c.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.background4 = this.game.add.sprite(200, 240, r.Atlases.Interface, "bg0000"), this.background4.anchor.set(.5), this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay.x = -50, this._armatureDisplay.y = 60, this._armatureDisplay.animation.play("idle", 0), this._armatureDisplay2 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay2.x = 50, this._armatureDisplay2.y = 60, this._armatureDisplay2.animation.play("idle", 0), this._armatureDisplay3 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay3.x = -50, this._armatureDisplay3.y = 60, this._armatureDisplay3.animation.play("idle", 0), this._armatureDisplay4 = dragonBones.PhaserFactory.factory.buildArmatureDisplay("player"), this._armatureDisplay4.x = 50, this._armatureDisplay4.y = 60, this._armatureDisplay4.animation.play("idle", 0), this._armatureDisplay4.visible = !1, this.world.addChild(this._armatureDisplay), this.world.addChild(this._armatureDisplay2), this.world.addChild(this._armatureDisplay3), this.world.addChild(this._armatureDisplay4), this.musicBtn = new h.default(this.game, "", {}, this.toggleMusic, this, r.Atlases.Gameplay), this.musicBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.musicBtn.sScale = 42 / this.musicBtn.btn.width, this.musicBtn.x = 772, this.musicBtn.y = 25, this.musicBtn.labelState = this.game.add.image(0, 0, r.Atlases.Gameplay, "InGameMusicButton0000"), this.backgroundBase2.addChild(this.musicBtn), this.backgroundBase2.addChild(this.background4), this.updateSoundButtons(), this.logo = this.game.add.sprite(400, 35, r.Atlases.Interface, "bg0000"), this.logo.anchor.set(.5), this.backgroundBase2.addChild(this.logo), this.playBtn = new p.default(this.game, "MENU", r.Constants.stylePlayGreen, this.onPlay, this, r.Atlases.Interface), this.playBtn.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.playBtn.x = 720, this.playBtn.y = 447, this.background4.addChild(this.playBtn), this.playBtn.setProp("#000000", 7, "#FFFFFF", 14), this.backgroundBase2.addChild(this.playBtn), this.branding2 = new h.default(this.game, "", null, this.onMoreGames, this, r.Atlases.Preloader), this.branding2.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.branding2.position.set(70, 420), this.backgroundBase2.addChild(this.branding2), this.leaderBoardBtn = new h.default(this.game, "", null, this.onScoreList, this, r.Atlases.Gameplay), this.leaderBoardBtn.setFrames("btn_bg0000", "btn_bg0000", "btn_bg0000", "btn_bg0000"), this.leaderBoardBtn.sScale = 1, this.leaderBoardBtn.sLabelScale = 1;
            var t = this.game.add.image(0, 0, r.Atlases.Interface, "lead_icon0000");
            t.anchor.set(.5), this.leaderBoardBtn.label.parent.addChild(t), this.leaderBoardBtn.x = this.branding2.x, this.leaderBoardBtn.y = this.branding2.y - 130, this.leaderBoardBtn.visible = !1, this.backgroundBase2.addChild(this.leaderBoardBtn), this.setUp(), this.manager.breakTournament(), this.resize(), new l.default(this.game, this, this.show)
        }, b.prototype.show = function() {
            var t = this.game.add.tween(this.place1);
            t.from({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.place2)).from({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.place3)).from({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.logo)).from({
                y: -100
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.tribune)).from({
                y: 800
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).from({
                x: -110
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.branding2)).from({
                x: -110
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).from({
                y: 600
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.branding2)).from({
                y: 600
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreLabel)).from({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreText)).from({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreBestLabel)).from({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.scoreTotalText)).from({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.playBtn)).from({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), this.player4 && ((t = this.game.add.tween(this.place4)).from({
                x: 900
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.tribune4)).from({
                x: 900
            }, y.default.PRELOADER_TIME, m.Easing.Back.Out), t.start())
        }, b.prototype.hide = function() {
            var t = this.game.add.tween(this.place1);
            t.to({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.place2)).to({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.place3)).to({
                y: -60
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.logo)).to({
                y: -100
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.tribune)).to({
                y: 800
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).to({
                x: -110
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                x: -110
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.leaderBoardBtn)).to({
                y: 600
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.branding2)).to({
                y: 600
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreLabel)).to({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreText)).to({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreBestLabel)).to({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.scoreTotalText)).to({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.playBtn)).to({
                y: 520
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), this.player4 && ((t = this.game.add.tween(this.place4)).to({
                x: 900
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.tribune4)).to({
                x: 900
            }, y.default.PRELOADER_TIME, m.Easing.Linear.None), t.start())
        }, b.prototype.onScoreList = function() {
            o.default.getInstance().play(r.Sounds.Click)
        }, b.prototype.setUp = function() {
            this.tribune = new Phaser.Sprite(this.game, 400, 448, r.Atlases.Interface, "TribuneFinal0000"), this.tribune.anchor.set(.58, 1.2), this.tribune4 = new Phaser.Sprite(this.game, 716, 380, r.Atlases.Interface, "bg0000"), this.tribune4.anchor.set(.5), this.player1 = new Phaser.Group(this.game), this.player1.x = 40, this.player1.y = -168, this.player2 = new Phaser.Group(this.game), this.player2.x = -147, this.player2.y = -155, this.player3 = new Phaser.Group(this.game), this.player3.x = 147, this.player3.y = -146, this.player1.scale.set(.8), this.player2.scale.set(.8), this.player3.scale.set(.8), this.backgroundBase2.addChild(this.tribune), this.backgroundBase2.addChild(this.tribune4), this.tribune.addChild(this.player3), this.tribune.addChild(this.player1), this.tribune.addChild(this.player2);
            this.manager.rounds;
            var t = this.manager.tournament.getFinalistsArray(),
                e = u.Inventory.instance.matchData.teams[0],
                i = u.Inventory.instance.matchData.players[0][0] + 1,
                s = "",
                n = t.pop();
            1 === n ? (u.PlayersData.switchPlayer(this._armatureDisplay.armature, 2 * (e - 1) + (i - 1), 2 * e - 2), this._armatureDisplay.armature.animation.play("happiness"), this.thePlayer = this._armatureDisplay.armature, this.frame = "cup1", s = "1st PLACE!!!") : (u.PlayersData.switchPlayer(this._armatureDisplay.armature, 2 * (t[0] - 1), 2 * t[0] - 2), this._armatureDisplay.armature.animation.gotoAndPlay("idle")), 2 === n ? (u.PlayersData.switchPlayer(this._armatureDisplay2.armature, 2 * (e - 1) + (i - 1), 2 * e - 2), this._armatureDisplay2.armature.animation.gotoAndPlay("happiness"), this.thePlayer = this._armatureDisplay2.armature, this.frame = "cup2", s = "2nd PLACE!!!") : (u.PlayersData.switchPlayer(this._armatureDisplay2.armature, 2 * (t[1] - 1), 2 * t[1] - 2), this._armatureDisplay2.armature.animation.gotoAndPlay("idle")), 3 === n ? (u.PlayersData.switchPlayer(this._armatureDisplay3.armature, 2 * (e - 1) + (i - 1), 2 * e - 2), this._armatureDisplay3.armature.animation.gotoAndPlay("happiness"), this.thePlayer = this._armatureDisplay3.armature, this.frame = "cup3", s = "3d PLACE!!!") : (u.PlayersData.switchPlayer(this._armatureDisplay3.armature, 2 * (t[2] - 1), 2 * t[2] - 2), this._armatureDisplay3.armature.animation.gotoAndPlay("idle")), 4 <= n && (s = 4 === n ? "4th PLACE" : "YOU LOST");
            var a = new p.default(this.game, s, r.Constants.styleTitleFinalTournamet, null, null, r.Atlases.Interface);
            a.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), a.setProp("#000000", 7, "#FFFFFF", 15), this.logo.addChild(a), this.player1.addChild(this._armatureDisplay.armature.display), this.player2.addChild(this._armatureDisplay2.armature.display), this.player3.addChild(this._armatureDisplay3.armature.display), this.place1 = this.game.add.sprite(400, 110, r.Atlases.Gameplay, "btn_bg20000"), this.place2 = this.game.add.sprite(294, 110, r.Atlases.Gameplay, "btn_bg20000"), this.place3 = this.game.add.sprite(506, 110, r.Atlases.Gameplay, "btn_bg20000"), this.place1.anchor.set(.5), this.place2.anchor.set(.5), this.place3.anchor.set(.5), this.backgroundBase2.addChild(this.place1), this.backgroundBase2.addChild(this.place2), this.backgroundBase2.addChild(this.place3);
            var o = this.game.add.image(0, 0),
                s = this.game.add.image(0, 0),
                a = this.game.add.image(0, 0);
            this.place1.addChild(o), this.place2.addChild(s), this.place3.addChild(a), o.loadTexture(r.Atlases.Interface, "Emblems00" + (t[0] - 1 < 10 ? "0" : "") + (t[0] - 1)), s.loadTexture(r.Atlases.Interface, "Emblems00" + (t[1] - 1 < 10 ? "0" : "") + (t[1] - 1)), a.loadTexture(r.Atlases.Interface, "Emblems00" + (t[2] - 1 < 10 ? "0" : "") + (t[2] - 1)), o.anchor.set(.5), o.scale.set(.25), s.anchor.set(.5), s.scale.set(.25), a.anchor.set(.5), a.scale.set(.25), n <= 3 ? (this.tribune4.visible = !1, this.thePlayer.getBone("effects stun").slot.childArmature.animation.gotoAndStop(this.frame, .1)) : (this.place4 = this.game.add.sprite(716, 160, r.Atlases.Gameplay, "btn_bg20000"), this.place4.anchor.set(.5), this.backgroundBase2.addChild(this.place4), (n = this.game.add.image(0, 0, r.Atlases.Interface, "Emblems00" + (e - 1 < 10 ? "0" : "") + (e - 1))).anchor.set(.5), n.scale.set(.25), this.place4.addChild(n), this.player4 = new Phaser.Group(this.game), this.player4.x = 40, this.player4.y = -72, this.player4.scale.set(-.8, .8), (n = new Phaser.Image(this.game, 0, -23, r.Atlases.Gameplay, "ShadowMC0002")).anchor.set(.5), n.scale.set(1.8), this.tribune4.addChild(n), this.tribune4.addChild(this.player4), this._armatureDisplay4.visible = !0, u.PlayersData.switchPlayer(this._armatureDisplay4.armature, 2 * (e - 1) + (i - 1), 2 * e - 2), this._armatureDisplay4.armature.animation.play("sad", -1), this.player4.addChild(this._armatureDisplay4.armature.display)), this.scoreLabel = new p.default(this.game, "SCORE:", r.Constants.styleIDnetScore, null, null, r.Atlases.Interface), this.scoreLabel.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreLabel.setProp("#000000", 5, "#FFFFFF", 10), this.scoreLabel.x = 250, this.scoreLabel.y = 460, this.backgroundBase2.addChild(this.scoreLabel), this.scoreBestLabel = new p.default(this.game, "TOTAL SCORE:", r.Constants.styleIDnetBestScore, null, null, r.Atlases.Interface), this.scoreBestLabel.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreBestLabel.setProp("#000000", 5, "#FFFFFF", 10), this.scoreBestLabel.x = 460, this.scoreBestLabel.y = 460, this.backgroundBase2.addChild(this.scoreBestLabel), this.scoreText = new p.default(this.game, "", r.Constants.styleIDnetScore2, null, null, r.Atlases.Interface), this.scoreText.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreText.x = 330, this.scoreText.y = 460, this.backgroundBase2.addChild(this.scoreText), this.scoreTotalText = new p.default(this.game, "", r.Constants.styleIDnetBestScore2, null, null, r.Atlases.Interface), this.scoreTotalText.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.scoreTotalText.x = 570, this.scoreTotalText.y = 460, this.backgroundBase2.addChild(this.scoreTotalText), this.scoreText.setText(this.manager.getTournamentScores().toString()), this.scoreTotalText.setText(this.manager.getTotalScores().toString()), this.scoreText.setProp("#000000", 5, "#FFFFFF", 10), this.scoreTotalText.setProp("#000000", 5, "#FFFFFF", 10)
        }, b.prototype.onMoreGames = function() {
            window.open(g.default.getInstance().getUrl(g.default.Current), "_blank")
        }, b.prototype.render = function() {
            dragonBones.PhaserFactory.factory.dragonBones.advanceTime(-1), a.prototype.render.call(this)
        }, b.prototype.toggleMusic = function() {
            d.default.getInstance().music ? o.default.getInstance().toggleMusic() : d.default.getInstance().sfx ? o.default.getInstance().toggleSfx() : (o.default.getInstance().toggleSfx(), o.default.getInstance().toggleMusic()), this.updateSoundButtons(), o.default.getInstance().play(r.Sounds.Click)
        }, b.prototype.updateSoundButtons = function() {
            var t = d.default.getInstance().music ? 0 : 1;
            t += d.default.getInstance().sfx ? 0 : 1, this.musicBtn.labelState.loadTexture(r.Atlases.Gameplay, "InGameMusicButton000" + t)
        }, b.prototype.onPlay = function() {
            o.default.getInstance().play(r.Sounds.Click), u.Inventory.instance.clearTournamentData(), new c.default(this.game, this, f.default.Name)
        }, b.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, a.prototype.resize.call(this)
        }, b.prototype.shutdown = function() {
            this.backgroundBase2 = null, this.backgroundBaseMask = null, this.playBtn = null, this.musicBtn = null, this._armatureDisplay = null, this._armatureDisplay2 = null, a.prototype.shutdown.call(this)
        }, b.Name = "finaltournamentstate", b);

    function b() {
        var t = a.call(this) || this;
        return t.name = b.Name, t._armatureDisplay = null, t._armatureDisplay2 = null, t._armatureDisplay3 = null, t._armatureDisplay4 = null, t.thePlayer = null, t.player1 = null, t.player2 = null, t.player3 = null, t.player4 = null, t.tribune = null, t.tribune4 = null, t.place1 = null, t.place2 = null, t.place3 = null, t.place4 = null, t.manager = null, t.frame = "", t.texts = ["1st place!!!", "2nd place!!!", "3rd place!!!", "4th place", "You lost"], t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(55), i(6), i(0);
    var a, o, r = i(60),
        h = i(12),
        l = i(3),
        c = i(50),
        u = i(18),
        d = i(52),
        p = i(53),
        f = i(33),
        g = i(30),
        m = i(4);

    function y() {
        var e = o.call(this, {
            enableDebug: !1,
            width: 1066,
            height: 640,
            renderer: Phaser.WEBGL,
            parent: "content",
            transparent: !0,
            antialias: !0,
            preserveDrawingBuffer: !1,
            physicsConfig: null,
            seed: "",
            state: null,
            forceSetTimeOut: !1
        }) || this;
        return e.clearBeforeRender = !1, Phaser.Device.whenReady(function() {
            m.default.isDesktop = e.device.desktop, e._isPad() && (m.default.isDesktop = !1), e.stage.disableVisibilityChange = !0;
            var t = m.default.isDesktop ? "click" : "touchstart";
            document.getElementById("content").addEventListener(t, function(t) {
                e.gameResumed(t)
            }), document.getElementById("content").addEventListener("SDK_GAME_START", function(t) {
                e.adsResume()
            }), document.getElementById("content").addEventListener("SDK_GAME_PAUSE", function(t) {
                e.adsPause()
            })
        }), e.state.add("game", {
            create: e.stateCreator.bind(e),
            preload: e.statePreloader.bind(e)
        }, !0), e
    }
    i = a = a || {}, o = Phaser.Game, n(y, o), y.prototype._isPad = function() {
        var t = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad");
        return !!(!t && navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints) || t
    }, y.prototype.statePreloader = function() {
        var e = this;
        ["https://cdn.jsdelivr.net/npm/@orange-games/phaser-cachebuster@2.0/build/phaser-cachebuster.min.js", "https://cdn.jsdelivr.net/npm/@orange-games/phaser-super-storage@1.0/build/phaser-super-storage.min.js", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/box2dweb/dragonBones.min.js"].forEach(function(t) {
            e.load.script(t, t)
        })
    }, y.prototype.stateCreator = function() {
        var t = this;
        this.plugins.add(PhaserSuperStorage.StoragePlugin), this.plugins.add(PhaserCachebuster.CacheBuster), this.storage.forcePromises = !0, this.state.add(h.Boot.Name, h.Boot, !1), this.state.add(l.default.Name, l.default, !1), this.state.add(c.default.Name, c.default, !1), this.state.add(h.RandomState.Name, h.RandomState, !1), this.state.add(h.TournamentState.Name, h.TournamentState, !1), this.state.add(d.default.Name, d.default, !1), this.state.add(p.default.Name, p.default, !1), this.state.add(u.default.Name, u.default, !1), this.state.add(h.Menu.Name, h.Menu, !1), this.state.add(f.default.Name, f.default, !1), this.state.add(h.Gameplay.Name, h.Gameplay, !1);

        function e() {
            t.recursiveUpdateText(t.stage)
        }
        r.load({
            custom: {
                families: ["Aller Display", "CfCrackBold", "Impact", "Impact2", "Impact3"],
                urls: ["https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/css/AllerDisplay.css", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/css/CfCrackBold.css", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/css/impact.css", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/css/impact2.css", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/css/impact3.css"]
            },
            active: e,
            inactive: e
        }), this.state.start(h.Boot.Name), this.state.remove("game")
    }, y.prototype.recursiveUpdateText = function(t) {
        var e = this;
        t instanceof Phaser.Text && (t.dirty = !0), t.children && 0 < t.children.length && t.children.forEach(function(t) {
            e.recursiveUpdateText(t)
        })
    }, y.prototype.adsResume = function() {
        this.sound.mute = !1, h.Gameplay.isAdsPause = !1
    }, y.prototype.adsPause = function() {
        this.sound.mute = !0, h.Gameplay.isAdsPause = !0, g.default.instance.signalPause && g.default.instance.signalPause.dispatch()
    }, n = y, i.Game = n, new a.Game
}, function(e, t, i) {
    (function(t) {
        e.exports = t.p2 = i(56)
    }).call(t, i(27))
}, function(t, e, i) {
    t.exports = function s(n, a, o) {
        function r(e, t) {
            if (!a[e]) {
                if (!n[e]) {
                    if (0, h) return h(e, !0);
                    throw new Error("Cannot find module '" + e + "'")
                }
                var i = a[e] = {
                    exports: {}
                };
                n[e][0].call(i.exports, function(t) {
                    return r(n[e][1][t] || t)
                }, i, i.exports, s, n, a, o)
            }
            return a[e].exports
        }
        for (var h = !1, t = 0; t < o.length; t++) r(o[t]);
        return r
    }({
        1: [function(t, e, i) {
            function s() {}
            var l = t("./Scalar");
            (e.exports = s).lineInt = function(t, e, i) {
                i = i || 0;
                var s = [0, 0],
                    n = t[1][1] - t[0][1],
                    a = t[0][0] - t[1][0],
                    o = n * t[0][0] + a * t[0][1],
                    r = e[1][1] - e[0][1],
                    h = e[0][0] - e[1][0],
                    t = r * e[0][0] + h * e[0][1],
                    e = n * h - r * a;
                return l.eq(e, 0, i) || (s[0] = (h * o - a * t) / e, s[1] = (n * t - r * o) / e), s
            }, s.segmentsIntersect = function(t, e, i, s) {
                var n = e[0] - t[0],
                    a = e[1] - t[1],
                    o = s[0] - i[0],
                    e = s[1] - i[1];
                if (o * a - e * n == 0) return !1;
                s = (n * (i[1] - t[1]) + a * (t[0] - i[0])) / (o * a - e * n), a = (o * (t[1] - i[1]) + e * (i[0] - t[0])) / (e * n - o * a);
                return 0 <= s && s <= 1 && 0 <= a && a <= 1
            }
        }, {
            "./Scalar": 4
        }],
        2: [function(t, e, i) {
            function r() {}(e.exports = r).area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            }, r.left = function(t, e, i) {
                return 0 < r.area(t, e, i)
            }, r.leftOn = function(t, e, i) {
                return 0 <= r.area(t, e, i)
            }, r.right = function(t, e, i) {
                return r.area(t, e, i) < 0
            }, r.rightOn = function(t, e, i) {
                return r.area(t, e, i) <= 0
            };
            var h = [],
                l = [];
            r.collinear = function(t, e, i, s) {
                if (s) {
                    var n = h,
                        a = l;
                    n[0] = e[0] - t[0], n[1] = e[1] - t[1], a[0] = i[0] - e[0], a[1] = i[1] - e[1];
                    var o = n[0] * a[0] + n[1] * a[1],
                        n = Math.sqrt(n[0] * n[0] + n[1] * n[1]),
                        a = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
                    return Math.acos(o / (n * a)) < s
                }
                return 0 == r.area(t, e, i)
            }, r.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    t = e[1] - t[1];
                return i * i + t * t
            }
        }, {}],
        3: [function(t, e, i) {
            function w() {
                this.vertices = []
            }

            function P(t, e, i, s, n) {
                n = n || 0;
                var a = e[1] - t[1],
                    o = t[0] - e[0],
                    r = a * t[0] + o * t[1],
                    e = s[1] - i[1],
                    t = i[0] - s[0],
                    s = e * i[0] + t * i[1],
                    i = a * t - e * o;
                return h.eq(i, 0, n) ? [0, 0] : [(t * r - o * s) / i, (a * s - e * r) / i]
            }
            var r = t("./Line"),
                T = t("./Point"),
                h = t("./Scalar");
            (e.exports = w).prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, w.prototype.first = function() {
                return this.vertices[0]
            }, w.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }, w.prototype.clear = function() {
                this.vertices.length = 0
            }, w.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var s = e; s < i; s++) this.vertices.push(t.vertices[s])
            }, w.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                T.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, w.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, w.prototype.isReflex = function(t) {
                return T.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var l = [],
                c = [];
            w.prototype.canSee = function(t, e) {
                var i, s, n = l,
                    a = c;
                if (T.leftOn(this.at(t + 1), this.at(t), this.at(e)) && T.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                s = T.sqdist(this.at(t), this.at(e));
                for (var o = 0; o !== this.vertices.length; ++o)
                    if ((o + 1) % this.vertices.length !== t && o !== t && T.leftOn(this.at(t), this.at(e), this.at(o + 1)) && T.rightOn(this.at(t), this.at(e), this.at(o)) && (n[0] = this.at(t), n[1] = this.at(e), a[0] = this.at(o), a[1] = this.at(o + 1), i = r.lineInt(n, a), T.sqdist(this.at(t), i) < s)) return !1;
                return !0
            }, w.prototype.copy = function(t, e, i) {
                var s = i || new w;
                if (s.clear(), t < e)
                    for (var n = t; n <= e; n++) s.vertices.push(this.vertices[n]);
                else {
                    for (n = 0; n <= e; n++) s.vertices.push(this.vertices[n]);
                    for (n = t; n < this.vertices.length; n++) s.vertices.push(this.vertices[n])
                }
                return s
            }, w.prototype.getCutEdges = function() {
                for (var t, e = [], i = [], s = new w, n = Number.MAX_VALUE, a = 0; a < this.vertices.length; ++a)
                    if (this.isReflex(a))
                        for (var o = 0; o < this.vertices.length; ++o)
                            if (this.canSee(a, o)) {
                                i = this.copy(a, o, s).getCutEdges(), t = this.copy(o, a, s).getCutEdges();
                                for (var r = 0; r < t.length; r++) i.push(t[r]);
                                i.length < n && (n = (e = i).length, e.push([this.at(a), this.at(o)]))
                            }
                return e
            }, w.prototype.decomp = function() {
                var t = this.getCutEdges();
                return 0 < t.length ? this.slice(t) : [this]
            }, w.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var s = t[i], n = 0; n < e.length; n++) {
                            var a = e[n].slice(s);
                            if (a) {
                                e.splice(n, 1), e.push(a[0], a[1]);
                                break
                            }
                        }
                    return e
                }
                s = t, i = this.vertices.indexOf(s[0]), n = this.vertices.indexOf(s[1]);
                return -1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)]
            }, w.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (r.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (r.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, w.prototype.quickDecomp = function(t, e, i, s, n, a) {
                n = n || 100, a = a || 0, s = s || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var o = [0, 0],
                    r = [0, 0],
                    h = [0, 0],
                    l = 0,
                    c = 0,
                    u = 0,
                    d = 0,
                    p = 0,
                    f = 0,
                    g = 0,
                    m = new w,
                    y = new w,
                    b = this,
                    v = this.vertices;
                if (v.length < 3) return t;
                if (++a > n) return t;
                for (var _ = 0; _ < this.vertices.length; ++_)
                    if (b.isReflex(_)) {
                        e.push(b.vertices[_]), l = c = Number.MAX_VALUE;
                        for (var x = 0; x < this.vertices.length; ++x) T.left(b.at(_ - 1), b.at(_), b.at(x)) && T.rightOn(b.at(_ - 1), b.at(_), b.at(x - 1)) && (h = P(b.at(_ - 1), b.at(_), b.at(x), b.at(x - 1)), T.right(b.at(_ + 1), b.at(_), h) && (u = T.sqdist(b.vertices[_], h)) < c && (c = u, r = h, f = x)), T.left(b.at(_ + 1), b.at(_), b.at(x + 1)) && T.rightOn(b.at(_ + 1), b.at(_), b.at(x)) && (h = P(b.at(_ + 1), b.at(_), b.at(x), b.at(x + 1)), T.left(b.at(_ - 1), b.at(_), h) && (u = T.sqdist(b.vertices[_], h)) < l && (l = u, o = h, p = x));
                        if (f == (p + 1) % this.vertices.length) h[0] = (r[0] + o[0]) / 2, h[1] = (r[1] + o[1]) / 2, i.push(h), _ < p ? (m.append(b, _, p + 1), m.vertices.push(h), y.vertices.push(h), 0 != f && y.append(b, f, b.vertices.length), y.append(b, 0, _ + 1)) : (0 != _ && m.append(b, _, b.vertices.length), m.append(b, 0, p + 1), m.vertices.push(h), y.vertices.push(h), y.append(b, f, _ + 1));
                        else {
                            if (p < f && (p += this.vertices.length), d = Number.MAX_VALUE, p < f) return t;
                            for (x = f; x <= p; ++x) T.leftOn(b.at(_ - 1), b.at(_), b.at(x)) && T.rightOn(b.at(_ + 1), b.at(_), b.at(x)) && (u = T.sqdist(b.at(_), b.at(x))) < d && (d = u, g = x % this.vertices.length);
                            _ < g ? (m.append(b, _, g + 1), 0 != g && y.append(b, g, v.length), y.append(b, 0, _ + 1)) : (0 != _ && m.append(b, _, v.length), m.append(b, 0, g + 1), y.append(b, g, _ + 1))
                        }
                        return m.vertices.length < y.vertices.length ? (m.quickDecomp(t, e, i, s, n, a), y.quickDecomp(t, e, i, s, n, a)) : (y.quickDecomp(t, e, i, s, n, a), m.quickDecomp(t, e, i, s, n, a)), t
                    }
                return t.push(this), t
            }, w.prototype.removeCollinearPoints = function(t) {
                for (var e = 0, i = this.vertices.length - 1; 3 < this.vertices.length && 0 <= i; --i) T.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(t, e, i) {
            function s() {}(e.exports = s).eq = function(t, e, i) {
                return i = i || 0, Math.abs(t - e) < i
            }
        }, {}],
        5: [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        }, {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            }
        }, {}],
        7: [function(t, e, i) {
            function s(t) {
                this.lowerBound = p.create(), t && t.lowerBound && p.copy(this.lowerBound, t.lowerBound), this.upperBound = p.create(), t && t.upperBound && p.copy(this.upperBound, t.upperBound)
            }
            var p = t("../math/vec2");
            t("../utils/Utils");
            e.exports = s;
            var f = p.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var n = this.lowerBound,
                    a = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? p.rotate(n, t[0], i) : p.copy(n, t[0]), p.copy(a, n);
                for (var o = Math.cos(i), r = Math.sin(i), h = 1; h < t.length; h++) {
                    var l, c, u = t[h];
                    0 !== i && (l = u[0], c = u[1], f[0] = o * l - r * c, f[1] = r * l + o * c, u = f);
                    for (var d = 0; d < 2; d++) u[d] > a[d] && (a[d] = u[d]), u[d] < n[d] && (n[d] = u[d])
                }
                e && (p.add(this.lowerBound, this.lowerBound, e), p.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            }, s.prototype.copy = function(t) {
                p.copy(this.lowerBound, t.lowerBound), p.copy(this.upperBound, t.upperBound)
            }, s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    i = t.upperBound[e];
                    this.upperBound[e] < i && (this.upperBound[e] = i)
                }
            }, s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    s = t.lowerBound,
                    t = t.upperBound;
                return (s[0] <= i[0] && i[0] <= t[0] || e[0] <= t[0] && t[0] <= i[0]) && (s[1] <= i[1] && i[1] <= t[1] || e[1] <= t[1] && t[1] <= i[1])
            }, s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    s = (this.lowerBound[0] - t.from[0]) * e,
                    n = (this.upperBound[0] - t.from[0]) * e,
                    e = (this.lowerBound[1] - t.from[1]) * i,
                    t = (this.upperBound[1] - t.from[1]) * i,
                    i = Math.max(Math.max(Math.min(s, n), Math.min(e, t))),
                    t = Math.min(Math.min(Math.max(s, n), Math.max(e, t)));
                return t < 0 || t < i ? -1 : i
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(t, e, i) {
            function s(t) {
                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = s.AABB
            }
            var n = t("../math/vec2"),
                a = t("../objects/Body");
            (e.exports = s).AABB = 1, s.BOUNDING_CIRCLE = 2, s.prototype.setWorld = function(t) {
                this.world = t
            }, s.prototype.getCollisionPairs = function(t) {};
            var o = n.create();
            s.boundingRadiusCheck = function(t, e) {
                n.sub(o, t.position, e.position);
                var i = n.squaredLength(o),
                    e = t.boundingRadius + e.boundingRadius;
                return i <= e * e
            }, s.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            }, s.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case s.BOUNDING_CIRCLE:
                        i = s.boundingRadiusCheck(t, e);
                        break;
                    case s.AABB:
                        i = s.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, s.canCollide = function(t, e) {
                var i = a.KINEMATIC,
                    s = a.STATIC;
                return !(t.type === s && e.type === s || t.type === i && e.type === s || t.type === s && e.type === i || t.type === i && e.type === i || t.sleepState === a.SLEEPING && e.sleepState === a.SLEEPING || t.sleepState === a.SLEEPING && e.type === s || e.sleepState === a.SLEEPING && t.type === s)
            }, s.NAIVE = 1, s.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(t, e, i) {
            function s() {
                h.call(this, h.NAIVE)
            }
            t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle");
            var h = t("../collision/Broadphase");
            t("../math/vec2");
            (((e.exports = s).prototype = new h).constructor = s).prototype.getCollisionPairs = function(t) {
                for (var e = t.bodies, i = this.result, s = i.length = 0, n = e.length; s !== n; s++)
                    for (var a = e[s], o = 0; o < s; o++) {
                        var r = e[o];
                        h.canCollide(a, r) && this.boundingVolumeCheck(a, r) && i.push(a, r)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var s = t.bodies, n = 0; n < s.length; n++) {
                    var a = s[n];
                    a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(t, e, i) {
            function U() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new s({
                    size: 32
                }), this.frictionEquationPool = new n({
                    size: 64
                }), this.restitution = 0, this.stiffness = o.DEFAULT_STIFFNESS, this.relaxation = o.DEFAULT_RELAXATION, this.frictionStiffness = o.DEFAULT_STIFFNESS, this.frictionRelaxation = o.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new a, this.contactSkinSize = .01
            }

            function b(t, e) {
                j.set(t.vertices[0], .5 * -e.length, -e.radius), j.set(t.vertices[1], .5 * e.length, -e.radius), j.set(t.vertices[2], .5 * e.length, e.radius), j.set(t.vertices[3], .5 * -e.length, e.radius)
            }

            function I(t, e, i, s) {
                for (var n = f, a = g, o = m, r = y, h = t, l = e.vertices, c = null, u = 0; u !== l.length + 1; u++) {
                    var d = l[u % l.length],
                        p = l[(u + 1) % l.length];
                    j.rotate(n, d, s), j.rotate(a, p, s), W(n, n, i), W(a, a, i), X(o, n, h), X(r, a, h);
                    p = j.crossLength(o, r);
                    if (null === c && (c = p), p * c <= 0) return;
                    c = p
                }
                return 1
            }
            var j = t("../math/vec2"),
                X = j.sub,
                W = j.add,
                H = j.dot,
                s = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                n = t("../utils/FrictionEquationPool"),
                a = t("../utils/TupleDictionary"),
                o = t("../equations/Equation"),
                r = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                h = t("../shapes/Convex"),
                l = t("../shapes/Shape"),
                P = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = U;
            var T = j.fromValues(0, 1),
                V = j.fromValues(0, 0),
                Y = j.fromValues(0, 0),
                q = j.fromValues(0, 0),
                z = j.fromValues(0, 0),
                K = j.fromValues(0, 0),
                B = j.fromValues(0, 0),
                J = j.fromValues(0, 0),
                Z = j.fromValues(0, 0),
                Q = j.fromValues(0, 0),
                M = j.fromValues(0, 0),
                k = j.fromValues(0, 0),
                O = j.fromValues(0, 0),
                D = j.fromValues(0, 0),
                L = j.fromValues(0, 0),
                R = j.fromValues(0, 0),
                F = j.fromValues(0, 0),
                C = j.fromValues(0, 0),
                A = j.fromValues(0, 0),
                G = [],
                c = j.create(),
                u = j.create();
            U.prototype.bodiesOverlap = function(t, e) {
                for (var i = c, s = u, n = 0, a = t.shapes.length; n !== a; n++) {
                    var o = t.shapes[n];
                    t.toWorldFrame(i, o.position);
                    for (var r = 0, h = e.shapes.length; r !== h; r++) {
                        var l = e.shapes[r];
                        if (e.toWorldFrame(s, l.position), this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return !0
                    }
                }
                return !1
            }, U.prototype.collidedLastStep = function(t, e) {
                t = 0 | t.id, e = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(t, e)
            }, U.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        s = i.bodyA.id,
                        i = i.bodyB.id;
                    this.collidingBodiesLastStep.set(s, i, !0)
                }
                for (var n = this.contactEquations, a = this.frictionEquations, o = 0; o < n.length; o++) this.contactEquationPool.release(n[o]);
                for (o = 0; o < a.length; o++) this.frictionEquationPool.release(a[o]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, U.prototype.createContactEquation = function(t, e, i, s) {
                var n = this.contactEquationPool.get();
                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.restitution = this.restitution, n.firstImpact = !this.collidedLastStep(t, e), n.stiffness = this.stiffness, n.relaxation = this.relaxation, n.needsUpdate = !0, n.enabled = this.enabledEquations, n.offset = this.contactSkinSize, n
            }, U.prototype.createFrictionEquation = function(t, e, i, s) {
                var n = this.frictionEquationPool.get();
                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.setSlipForce(this.slipForce), n.frictionCoefficient = this.frictionCoefficient, n.relativeVelocity = this.surfaceVelocity, n.enabled = this.enabledEquations, n.needsUpdate = !0, n.stiffness = this.frictionStiffness, n.relaxation = this.frictionRelaxation, n.contactEquations.length = 0, n
            }, U.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return j.copy(e.contactPointA, t.contactPointA), j.copy(e.contactPointB, t.contactPointB), j.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
            }, U.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    s = e.bodyA;
                e.bodyB;
                j.set(i.contactPointA, 0, 0), j.set(i.contactPointB, 0, 0), j.set(i.t, 0, 0);
                for (var n = 0; n !== t; n++)(e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === s ? (j.add(i.t, i.t, e.normalA), j.add(i.contactPointA, i.contactPointA, e.contactPointA), j.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (j.sub(i.t, i.t, e.normalA), j.add(i.contactPointA, i.contactPointA, e.contactPointB), j.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var a = 1 / t;
                return j.scale(i.contactPointA, i.contactPointA, a), j.scale(i.contactPointB, i.contactPointB, a), j.normalize(i.t, i.t), j.rotate90cw(i.t, i.t), i
            }, U.prototype[l.LINE | l.CONVEX] = U.prototype.convexLine = function(t, e, i, s, n, a, o, r, h) {
                return !h && 0
            }, U.prototype[l.LINE | l.BOX] = U.prototype.lineBox = function(t, e, i, s, n, a, o, r, h) {
                return !h && 0
            };
            var d = new P({
                    width: 1,
                    height: 1
                }),
                p = j.create();
            U.prototype[l.CAPSULE | l.CONVEX] = U.prototype[l.CAPSULE | l.BOX] = U.prototype.convexCapsule = function(t, e, i, s, n, a, o, r, h) {
                var l = p;
                j.set(l, a.length / 2, 0), j.rotate(l, l, r), j.add(l, l, o);
                var c = this.circleConvex(n, a, l, r, t, e, i, s, h, a.radius);
                j.set(l, -a.length / 2, 0), j.rotate(l, l, r), j.add(l, l, o);
                var u = this.circleConvex(n, a, l, r, t, e, i, s, h, a.radius);
                if (h && (c || u)) return !0;
                l = d;
                return b(l, a), this.convexConvex(t, e, i, s, n, l, o, r, h) + c + u
            }, U.prototype[l.CAPSULE | l.LINE] = U.prototype.lineCapsule = function(t, e, i, s, n, a, o, r, h) {
                return !h && 0
            };
            var v = j.create(),
                _ = j.create(),
                x = new P({
                    width: 1,
                    height: 1
                });
            U.prototype[l.CAPSULE | l.CAPSULE] = U.prototype.capsuleCapsule = function(t, e, i, s, n, a, o, r, h) {
                for (var l = v, c = _, u = 0, d = 0; d < 2; d++) {
                    j.set(l, (0 === d ? -1 : 1) * e.length / 2, 0), j.rotate(l, l, s), j.add(l, l, i);
                    for (var p = 0; p < 2; p++) {
                        j.set(c, (0 === p ? -1 : 1) * a.length / 2, 0), j.rotate(c, c, r), j.add(c, c, o), this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1);
                        var f = this.circleCircle(t, e, l, s, n, a, c, r, h, e.radius, a.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = m), h && f) return !0;
                        u += f
                    }
                }
                this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1);
                var g = x;
                b(g, e);
                var m, y = this.convexCapsule(t, g, i, s, n, a, o, r, h);
                if (this.enableFrictionReduction && (this.enableFriction = m), h && y) return !0;
                u += y, this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1), b(g, a);
                g = this.convexCapsule(n, g, o, r, t, e, i, s, h);
                return this.enableFrictionReduction && (this.enableFriction = m), !(!h || !g) || (u += g, this.enableFrictionReduction && u && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(u)), u)
            }, U.prototype[l.LINE | l.LINE] = U.prototype.lineLine = function(t, e, i, s, n, a, o, r, h) {
                return !h && 0
            }, U.prototype[l.PLANE | l.LINE] = U.prototype.planeLine = function(t, e, i, s, n, a, o, r, h) {
                var l = V,
                    c = Y,
                    u = q,
                    d = z,
                    p = K,
                    f = B,
                    g = J,
                    m = Z,
                    y = Q,
                    b = G,
                    v = 0;
                j.set(l, -a.length / 2, 0), j.set(c, a.length / 2, 0), j.rotate(u, l, r), j.rotate(d, c, r), W(u, u, o), W(d, d, o), j.copy(l, u), j.copy(c, d), X(p, c, l), j.normalize(f, p), j.rotate90cw(y, f), j.rotate(m, T, s), b[0] = l, b[1] = c;
                for (var _ = 0; _ < b.length; _++) {
                    var x = b[_];
                    X(g, x, i);
                    var w = H(g, m);
                    if (w < 0) {
                        if (h) return !0;
                        var P = this.createContactEquation(t, n, e, a);
                        v++, j.copy(P.normalA, m), j.normalize(P.normalA, P.normalA), j.scale(g, m, w), X(P.contactPointA, x, g), X(P.contactPointA, P.contactPointA, t.position), X(P.contactPointB, x, o), W(P.contactPointB, P.contactPointB, o), X(P.contactPointB, P.contactPointB, n.position), this.contactEquations.push(P), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P))
                    }
                }
                return !h && (this.enableFrictionReduction || v && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(v)), v)
            }, U.prototype[l.PARTICLE | l.CAPSULE] = U.prototype.particleCapsule = function(t, e, i, s, n, a, o, r, h) {
                return this.circleLine(t, e, i, s, n, a, o, r, h, a.radius, 0)
            }, U.prototype[l.CIRCLE | l.LINE] = U.prototype.circleLine = function(t, e, i, s, n, a, o, r, h, l, c) {
                var l = l || 0,
                    c = void 0 !== c ? c : e.radius,
                    u = V,
                    d = Y,
                    p = q,
                    f = z,
                    g = K,
                    m = B,
                    y = J,
                    b = Z,
                    v = Q,
                    _ = M,
                    x = k,
                    w = O,
                    P = D,
                    T = L,
                    S = G;
                j.set(b, -a.length / 2, 0), j.set(v, a.length / 2, 0), j.rotate(_, b, r), j.rotate(x, v, r), W(_, _, o), W(x, x, o), j.copy(b, _), j.copy(v, x), X(m, v, b), j.normalize(y, m), j.rotate90cw(g, y), X(w, i, b);
                m = H(w, g);
                X(f, b, o), X(P, i, o);
                var C = c + l;
                if (Math.abs(m) < C) {
                    j.scale(u, g, m), X(p, i, u), j.scale(d, g, H(g, P)), j.normalize(d, d), j.scale(d, d, l), W(p, p, d);
                    P = H(y, p), d = H(y, b), y = H(y, v);
                    if (d < P && P < y) {
                        if (h) return !0;
                        var A = this.createContactEquation(t, n, e, a);
                        return j.scale(A.normalA, u, -1), j.normalize(A.normalA, A.normalA), j.scale(A.contactPointA, A.normalA, c), W(A.contactPointA, A.contactPointA, i), X(A.contactPointA, A.contactPointA, t.position), X(A.contactPointB, p, o), W(A.contactPointB, A.contactPointB, o), X(A.contactPointB, A.contactPointB, n.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                    }
                }
                S[0] = b, S[1] = v;
                for (var E = 0; E < S.length; E++) {
                    var I = S[E];
                    if (X(w, I, i), j.squaredLength(w) < Math.pow(C, 2)) {
                        if (h) return !0;
                        A = this.createContactEquation(t, n, e, a);
                        return j.copy(A.normalA, w), j.normalize(A.normalA, A.normalA), j.scale(A.contactPointA, A.normalA, c), W(A.contactPointA, A.contactPointA, i), X(A.contactPointA, A.contactPointA, t.position), X(A.contactPointB, I, o), j.scale(T, A.normalA, -l), W(A.contactPointB, A.contactPointB, T), W(A.contactPointB, A.contactPointB, o), X(A.contactPointB, A.contactPointB, n.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                    }
                }
                return 0
            }, U.prototype[l.CIRCLE | l.CAPSULE] = U.prototype.circleCapsule = function(t, e, i, s, n, a, o, r, h) {
                return this.circleLine(t, e, i, s, n, a, o, r, h, a.radius)
            }, U.prototype[l.CIRCLE | l.CONVEX] = U.prototype[l.CIRCLE | l.BOX] = U.prototype.circleConvex = function(t, e, i, s, n, a, o, r, h, l) {
                for (var l = "number" == typeof l ? l : e.radius, c = V, u = Y, d = q, p = z, f = K, g = M, m = k, y = D, b = L, v = R, _ = F, x = !1, w = Number.MAX_VALUE, P = a.vertices, T = 0; T !== P.length + 1; T++) {
                    var S = P[T % P.length],
                        C = P[(T + 1) % P.length];
                    j.rotate(c, S, r), j.rotate(u, C, r), W(c, c, o), W(u, u, o), X(d, u, c), j.normalize(p, d), j.rotate90cw(f, p), j.scale(b, f, -e.radius), W(b, b, i), I(b, a, o, r) && (j.sub(v, c, b), (C = Math.abs(j.dot(v, f))) < w && (j.copy(_, b), w = C, j.scale(y, f, C), j.add(y, y, b), x = !0))
                }
                if (x) {
                    if (h) return !0;
                    var A = this.createContactEquation(t, n, e, a);
                    return j.sub(A.normalA, _, i), j.normalize(A.normalA, A.normalA), j.scale(A.contactPointA, A.normalA, l), W(A.contactPointA, A.contactPointA, i), X(A.contactPointA, A.contactPointA, t.position), X(A.contactPointB, y, o), W(A.contactPointB, A.contactPointB, o), X(A.contactPointB, A.contactPointB, n.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                }
                if (0 < l)
                    for (T = 0; T < P.length; T++) {
                        var E = P[T];
                        if (j.rotate(m, E, r), W(m, m, o), X(g, m, i), j.squaredLength(g) < Math.pow(l, 2)) {
                            if (h) return !0;
                            A = this.createContactEquation(t, n, e, a);
                            return j.copy(A.normalA, g), j.normalize(A.normalA, A.normalA), j.scale(A.contactPointA, A.normalA, l), W(A.contactPointA, A.contactPointA, i), X(A.contactPointA, A.contactPointA, t.position), X(A.contactPointB, m, o), W(A.contactPointB, A.contactPointB, o), X(A.contactPointB, A.contactPointB, n.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                        }
                    }
                return 0
            };
            var f = j.create(),
                g = j.create(),
                m = j.create(),
                y = j.create();
            U.prototype[l.PARTICLE | l.CONVEX] = U.prototype[l.PARTICLE | l.BOX] = U.prototype.particleConvex = function(t, e, i, s, n, a, o, r, h) {
                var l = V,
                    c = Y,
                    u = q,
                    d = z,
                    p = K,
                    f = B,
                    g = J,
                    m = M,
                    y = D,
                    b = C,
                    v = A,
                    _ = Number.MAX_VALUE,
                    x = !1,
                    w = a.vertices;
                if (!I(i, a, o, r)) return 0;
                if (h) return !0;
                for (var P = 0; P !== w.length + 1; P++) {
                    var T = w[P % w.length],
                        S = w[(P + 1) % w.length];
                    j.rotate(l, T, r), j.rotate(c, S, r), W(l, l, o), W(c, c, o), X(u, c, l), j.normalize(d, u), j.rotate90cw(p, d), X(m, i, l);
                    H(m, p);
                    X(f, l, o), X(g, i, o), j.sub(b, l, i);
                    S = Math.abs(j.dot(b, p));
                    S < _ && (_ = S, j.scale(y, p, S), j.add(y, y, i), j.copy(v, p), x = !0)
                }
                if (x) {
                    a = this.createContactEquation(t, n, e, a);
                    return j.scale(a.normalA, v, -1), j.normalize(a.normalA, a.normalA), j.set(a.contactPointA, 0, 0), W(a.contactPointA, a.contactPointA, i), X(a.contactPointA, a.contactPointA, t.position), X(a.contactPointB, y, o), W(a.contactPointB, a.contactPointB, o), X(a.contactPointB, a.contactPointB, n.position), this.contactEquations.push(a), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(a)), 1
                }
                return 0
            }, U.prototype[l.CIRCLE] = U.prototype.circleCircle = function(t, e, i, s, n, a, o, r, h, l, c) {
                var u = V,
                    l = l || e.radius,
                    c = c || a.radius;
                X(u, i, o);
                var d = l + c;
                if (j.squaredLength(u) > Math.pow(d, 2)) return 0;
                if (h) return !0;
                a = this.createContactEquation(t, n, e, a);
                return X(a.normalA, o, i), j.normalize(a.normalA, a.normalA), j.scale(a.contactPointA, a.normalA, l), j.scale(a.contactPointB, a.normalA, -c), W(a.contactPointA, a.contactPointA, i), X(a.contactPointA, a.contactPointA, t.position), W(a.contactPointB, a.contactPointB, o), X(a.contactPointB, a.contactPointB, n.position), this.contactEquations.push(a), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(a)), 1
            }, U.prototype[l.PLANE | l.CONVEX] = U.prototype[l.PLANE | l.BOX] = U.prototype.planeConvex = function(t, e, i, s, n, a, o, r, h) {
                var l = V,
                    c = Y,
                    u = q,
                    d = 0;
                j.rotate(c, T, s);
                for (var p = 0; p !== a.vertices.length; p++) {
                    var f = a.vertices[p];
                    if (j.rotate(l, f, r), W(l, l, o), X(u, l, i), H(u, c) <= 0) {
                        if (h) return !0;
                        d++;
                        var g = this.createContactEquation(t, n, e, a);
                        X(u, l, i), j.copy(g.normalA, c);
                        f = H(u, g.normalA);
                        j.scale(u, g.normalA, f), X(g.contactPointB, l, n.position), X(g.contactPointA, l, u), X(g.contactPointA, g.contactPointA, t.position), this.contactEquations.push(g), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && d && this.frictionEquations.push(this.createFrictionFromAverage(d)), d
            }, U.prototype[l.PARTICLE | l.PLANE] = U.prototype.particlePlane = function(t, e, i, s, n, a, o, r, h) {
                var l = V,
                    c = Y;
                r = r || 0, X(l, i, o), j.rotate(c, T, r);
                r = H(l, c);
                if (0 < r) return 0;
                if (h) return !0;
                e = this.createContactEquation(n, t, a, e);
                return j.copy(e.normalA, c), j.scale(l, e.normalA, r), X(e.contactPointA, i, l), X(e.contactPointA, e.contactPointA, n.position), X(e.contactPointB, i, t.position), this.contactEquations.push(e), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(e)), 1
            }, U.prototype[l.CIRCLE | l.PARTICLE] = U.prototype.circleParticle = function(t, e, i, s, n, a, o, r, h) {
                var l = V;
                if (X(l, o, i), j.squaredLength(l) > Math.pow(e.radius, 2)) return 0;
                if (h) return !0;
                a = this.createContactEquation(t, n, e, a);
                return j.copy(a.normalA, l), j.normalize(a.normalA, a.normalA), j.scale(a.contactPointA, a.normalA, e.radius), W(a.contactPointA, a.contactPointA, i), X(a.contactPointA, a.contactPointA, t.position), X(a.contactPointB, o, n.position), this.contactEquations.push(a), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(a)), 1
            };
            var w = new r({
                    radius: 1
                }),
                S = j.create(),
                E = j.create();
            j.create();
            U.prototype[l.PLANE | l.CAPSULE] = U.prototype.planeCapsule = function(t, e, i, s, n, a, o, r, h) {
                var l, c = S,
                    u = E,
                    d = w;
                j.set(c, -a.length / 2, 0), j.rotate(c, c, r), W(c, c, o), j.set(u, a.length / 2, 0), j.rotate(u, u, r), W(u, u, o), d.radius = a.radius, this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                c = this.circlePlane(n, d, c, 0, t, e, i, s, h), s = this.circlePlane(n, d, u, 0, t, e, i, s, h);
                if (this.enableFrictionReduction && (this.enableFriction = l), h) return c || s;
                s = c + s;
                return this.enableFrictionReduction && s && this.frictionEquations.push(this.createFrictionFromAverage(s)), s
            }, U.prototype[l.CIRCLE | l.PLANE] = U.prototype.circlePlane = function(t, e, i, s, n, a, o, r, h) {
                var l = t,
                    c = e,
                    u = i,
                    d = n,
                    t = o,
                    i = (i = r) || 0,
                    n = V,
                    o = Y,
                    r = q;
                X(n, u, t), j.rotate(o, T, i);
                i = H(o, n);
                if (i > c.radius) return 0;
                if (h) return !0;
                e = this.createContactEquation(d, l, a, e);
                return j.copy(e.normalA, o), j.scale(e.contactPointB, e.normalA, -c.radius), W(e.contactPointB, e.contactPointB, u), X(e.contactPointB, e.contactPointB, l.position), j.scale(r, e.normalA, i), X(e.contactPointA, n, r), W(e.contactPointA, e.contactPointA, t), X(e.contactPointA, e.contactPointA, d.position), this.contactEquations.push(e), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(e)), 1
            }, U.prototype[l.CONVEX] = U.prototype[l.CONVEX | l.BOX] = U.prototype[l.BOX] = U.prototype.convexConvex = function(t, e, i, s, n, a, o, r, h, l) {
                var c = V,
                    u = Y,
                    d = q,
                    p = z,
                    f = K,
                    g = J,
                    m = Z,
                    y = Q,
                    b = 0,
                    l = "number" == typeof l ? l : 0;
                if (!U.findSeparatingAxis(e, i, s, a, o, r, c)) return 0;
                X(m, o, i), 0 < H(c, m) && j.scale(c, c, -1);
                var v = U.getClosestEdge(e, s, c, !0),
                    _ = U.getClosestEdge(a, r, c);
                if (-1 === v || -1 === _) return 0;
                for (var x = 0; x < 2; x++) {
                    var w, P = v,
                        T = _,
                        S = e,
                        C = a,
                        A = i,
                        E = o,
                        I = s,
                        B = r,
                        M = t,
                        k = n;
                    0 === x && (w = P, P = T, T = w, w = S, S = C, C = w, w = A, A = E, E = w, w = I, I = B, B = w, w = M, M = k, k = w);
                    for (var O = T; O < T + 2; O++) {
                        var D = C.vertices[(O + C.vertices.length) % C.vertices.length];
                        j.rotate(u, D, B), W(u, u, E);
                        for (var L = 0, R = P - 1; R < P + 2; R++) {
                            var F = S.vertices[(R + S.vertices.length) % S.vertices.length],
                                G = S.vertices[(R + 1 + S.vertices.length) % S.vertices.length];
                            j.rotate(d, F, I), j.rotate(p, G, I), W(d, d, A), W(p, p, A), X(f, p, d), j.rotate90cw(y, f), j.normalize(y, y), X(m, u, d);
                            var N = H(y, m);
                            (R === P && N <= l || R !== P && N <= 0) && L++
                        }
                        if (3 <= L) {
                            if (h) return !0;
                            D = this.createContactEquation(M, k, S, C);
                            b++;
                            F = S.vertices[P % S.vertices.length], G = S.vertices[(P + 1) % S.vertices.length];
                            j.rotate(d, F, I), j.rotate(p, G, I), W(d, d, A), W(p, p, A), X(f, p, d), j.rotate90cw(D.normalA, f), j.normalize(D.normalA, D.normalA), X(m, u, d);
                            N = H(D.normalA, m);
                            j.scale(g, D.normalA, N), X(D.contactPointA, u, A), X(D.contactPointA, D.contactPointA, g), W(D.contactPointA, D.contactPointA, A), X(D.contactPointA, D.contactPointA, M.position), X(D.contactPointB, u, E), W(D.contactPointB, D.contactPointB, E), X(D.contactPointB, D.contactPointB, k.position), this.contactEquations.push(D), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && b && this.frictionEquations.push(this.createFrictionFromAverage(b)), b
            };
            var N = j.fromValues(0, 0);
            U.projectConvexOntoAxis = function(t, e, i, s, n) {
                var a, o = null,
                    r = null,
                    h = N;
                j.rotate(h, s, -i);
                for (var l = 0; l < t.vertices.length; l++) a = t.vertices[l], a = H(a, h), (null === o || o < a) && (o = a), (null === r || a < r) && (r = a);
                o < r && (i = r, r = o, o = i);
                s = H(e, s);
                j.set(n, r + s, o + s)
            };
            var $ = j.fromValues(0, 0),
                tt = j.fromValues(0, 0),
                et = j.fromValues(0, 0),
                it = j.fromValues(0, 0),
                st = j.fromValues(0, 0),
                nt = j.fromValues(0, 0);
            U.findSeparatingAxis = function(t, e, i, s, n, a, o) {
                var r = null,
                    h = !1,
                    l = !1,
                    c = $,
                    u = tt,
                    d = et,
                    p = it,
                    f = st,
                    g = nt;
                if (t instanceof P && s instanceof P)
                    for (var m = 0; 2 !== m; m++) {
                        var y = t,
                            b = i;
                        1 === m && (y = s, b = a);
                        for (var v = 0; 2 !== v; v++) {
                            0 === v ? j.set(p, 0, 1) : 1 === v && j.set(p, 1, 0), 0 !== b && j.rotate(p, p, b), U.projectConvexOntoAxis(t, e, i, p, f), U.projectConvexOntoAxis(s, n, a, p, g);
                            var _ = f,
                                x = g;
                            f[0] > g[0] && (x = f, _ = g, 0);
                            h = (w = x[0] - _[1]) <= 0;
                            (null === r || r < w) && (j.copy(o, p), r = w, l = h)
                        }
                    } else
                        for (m = 0; 2 !== m; m++) {
                            y = t, b = i;
                            1 === m && (y = s, b = a);
                            for (v = 0; v !== y.vertices.length; v++) {
                                j.rotate(u, y.vertices[v], b), j.rotate(d, y.vertices[(v + 1) % y.vertices.length], b), X(c, d, u), j.rotate90cw(p, c), j.normalize(p, p), U.projectConvexOntoAxis(t, e, i, p, f), U.projectConvexOntoAxis(s, n, a, p, g);
                                var w, _ = f,
                                    x = g;
                                f[0] > g[0] && (x = f, _ = g, 0), h = (w = x[0] - _[1]) <= 0, (null === r || r < w) && (j.copy(o, p), r = w, l = h)
                            }
                        }
                return l
            };
            var at = j.fromValues(0, 0),
                ot = j.fromValues(0, 0),
                rt = j.fromValues(0, 0);
            U.getClosestEdge = function(t, e, i, s) {
                var n = at,
                    a = ot,
                    o = rt;
                j.rotate(n, i, -e), s && j.scale(n, n, -1);
                for (var r = -1, h = t.vertices.length, l = -1, c = 0; c !== h; c++) {
                    X(a, t.vertices[(c + 1) % h], t.vertices[c % h]), j.rotate90cw(o, a), j.normalize(o, o);
                    var u = H(o, n);
                    (-1 === r || l < u) && (r = c % h, l = u)
                }
                return r
            };
            var ht = j.create(),
                lt = j.create(),
                ct = j.create(),
                ut = j.create(),
                dt = j.create(),
                pt = j.create(),
                ft = j.create();
            U.prototype[l.CIRCLE | l.HEIGHTFIELD] = U.prototype.circleHeightfield = function(t, e, i, s, n, a, o, r, h, l) {
                var c = a.heights,
                    l = l || e.radius,
                    u = a.elementWidth,
                    d = lt,
                    p = ht,
                    f = dt,
                    g = ft,
                    m = pt,
                    y = ct,
                    b = ut,
                    v = Math.floor((i[0] - l - o[0]) / u),
                    _ = Math.ceil((i[0] + l - o[0]) / u);
                v < 0 && (v = 0), _ >= c.length && (_ = c.length - 1);
                for (var x = c[v], w = c[_], P = v; P < _; P++) c[P] < w && (w = c[P]), c[P] > x && (x = c[P]);
                if (i[1] - l > x) return !h && 0;
                for (var T = !1, P = v; P < _; P++) {
                    j.set(y, P * u, c[P]), j.set(b, (P + 1) * u, c[P + 1]), j.add(y, y, o), j.add(b, b, o), j.sub(m, b, y), j.rotate(m, m, Math.PI / 2), j.normalize(m, m), j.scale(p, m, -l), j.add(p, p, i), j.sub(d, p, y);
                    var S = j.dot(d, m);
                    if (p[0] >= y[0] && p[0] < b[0] && S <= 0) {
                        if (h) return !0;
                        T = !0, j.scale(d, m, -S), j.add(f, p, d), j.copy(g, m);
                        var C = this.createContactEquation(n, t, a, e);
                        j.copy(C.normalA, g), j.scale(C.contactPointB, C.normalA, -l), W(C.contactPointB, C.contactPointB, i), X(C.contactPointB, C.contactPointB, t.position), j.copy(C.contactPointA, f), j.sub(C.contactPointA, C.contactPointA, n.position), this.contactEquations.push(C), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C))
                    }
                }
                if (T = !1, 0 < l)
                    for (P = v; P <= _; P++)
                        if (j.set(y, P * u, c[P]), j.add(y, y, o), j.sub(d, i, y), j.squaredLength(d) < Math.pow(l, 2)) {
                            if (h) return !0;
                            T = !0;
                            C = this.createContactEquation(n, t, a, e);
                            j.copy(C.normalA, d), j.normalize(C.normalA, C.normalA), j.scale(C.contactPointB, C.normalA, -l), W(C.contactPointB, C.contactPointB, i), X(C.contactPointB, C.contactPointB, t.position), X(C.contactPointA, y, o), W(C.contactPointA, C.contactPointA, o), X(C.contactPointA, C.contactPointA, n.position), this.contactEquations.push(C), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C))
                        }
                return T ? 1 : 0
            };
            var gt = j.create(),
                mt = j.create(),
                yt = j.create(),
                bt = new h({
                    vertices: [j.create(), j.create(), j.create(), j.create()]
                });
            U.prototype[l.BOX | l.HEIGHTFIELD] = U.prototype[l.CONVEX | l.HEIGHTFIELD] = U.prototype.convexHeightfield = function(t, e, i, s, n, a, o, r, h) {
                var l = a.heights,
                    c = a.elementWidth,
                    u = gt,
                    d = mt,
                    p = yt,
                    f = bt,
                    a = Math.floor((t.aabb.lowerBound[0] - o[0]) / c),
                    g = Math.ceil((t.aabb.upperBound[0] - o[0]) / c);
                a < 0 && (a = 0), g >= l.length && (g = l.length - 1);
                for (var m = l[a], y = l[g], b = a; b < g; b++) l[b] < y && (y = l[b]), l[b] > m && (m = l[b]);
                if (t.aabb.lowerBound[1] > m) return !h && 0;
                for (var v = 0, b = a; b < g; b++) {
                    j.set(u, b * c, l[b]), j.set(d, (b + 1) * c, l[b + 1]), j.add(u, u, o), j.add(d, d, o);
                    j.set(p, .5 * (d[0] + u[0]), .5 * (d[1] + u[1] - 100)), j.sub(f.vertices[0], d, p), j.sub(f.vertices[1], u, p), j.copy(f.vertices[2], f.vertices[1]), j.copy(f.vertices[3], f.vertices[0]), f.vertices[2][1] -= 100, f.vertices[3][1] -= 100, v += this.convexConvex(t, e, i, s, n, f, p, 0, h)
                }
                return v
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(t, e, i) {
            function o(t) {
                t = t || {}, this.from = t.from ? h.fromValues(t.from[0], t.from[1]) : h.create(), this.to = t.to ? h.fromValues(t.to[0], t.to[1]) : h.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : o.ANY, this.callback = t.callback || function(t) {}, this.direction = h.create(), this.length = 1, this.update()
            }
            e.exports = o;
            var h = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB");
            (o.prototype.constructor = o).CLOSEST = 1, o.ANY = 2, o.ALL = 4, o.prototype.update = function() {
                var t = this.direction;
                h.sub(t, this.to, this.from), this.length = h.length(t), h.normalize(t, t)
            }, o.prototype.intersectBodies = function(t, e) {
                for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                    var n = e[i],
                        a = n.getAABB();
                    (0 <= a.overlapsRay(this) || a.containsPoint(this.from)) && this.intersectBody(t, n)
                }
            };
            var l = h.create();
            o.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var s = l, n = 0, a = e.shapes.length; n < a; n++) {
                        var o = e.shapes[n];
                        if ((!i || o.collisionResponse) && 0 != (this.collisionGroup & o.collisionMask) && 0 != (o.collisionGroup & this.collisionMask)) {
                            h.rotate(s, o.position, e.angle), h.add(s, s, e.position);
                            var r = o.angle + e.angle;
                            if (this.intersectShape(t, o, r, s, e), t.shouldStop(this)) break
                        }
                    }
            }, o.prototype.intersectShape = function(t, e, i, s, n) {
                (function(t, e, i) {
                    h.sub(a, i, t);
                    var s = h.dot(a, e);
                    return h.scale(r, e, s), h.add(r, r, t), h.squaredDistance(i, r)
                })(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = n, (this._currentShape = e).raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            }, o.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                h.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), h.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            };
            h.create();
            o.prototype.reportIntersection = function(t, e, i, s) {
                this.from, this.to;
                var n = this._currentShape,
                    a = this._currentBody;
                if (!(this.skipBackfaces && 0 < h.dot(i, this.direction))) switch (this.mode) {
                    case o.ALL:
                        t.set(i, n, a, e, s), this.callback(t);
                        break;
                    case o.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, n, a, e, s);
                        break;
                    case o.ANY:
                        t.set(i, n, a, e, s)
                }
            };
            var a = h.create(),
                r = h.create()
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(t, e, i) {
            function s() {
                this.normal = a.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }
            var a = t("../math/vec2"),
                n = t("../collision/Ray");
            (e.exports = s).prototype.reset = function() {
                a.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }, s.prototype.getHitDistance = function(t) {
                return a.distance(t.from, t.to) * this.fraction
            }, s.prototype.hasHit = function() {
                return -1 !== this.fraction
            }, s.prototype.getHitPoint = function(t, e) {
                a.lerp(t, e.from, e.to, this.fraction)
            }, s.prototype.stop = function() {
                this.isStopped = !0
            }, s.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === n.ANY
            }, s.prototype.set = function(t, e, i, s, n) {
                a.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = n
            }
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(t, e, i) {
            function s() {
                u.call(this, u.SAP), this.axisList = [], this.axisIndex = 0;
                var e = this;
                this._addBodyHandler = function(t) {
                    e.axisList.push(t.body)
                }, this._removeBodyHandler = function(t) {
                    t = e.axisList.indexOf(t.body); - 1 !== t && e.axisList.splice(t, 1)
                }
            }
            var n = t("../utils/Utils"),
                u = t("../collision/Broadphase");
            (((e.exports = s).prototype = new u).constructor = s).prototype.setWorld = function(t) {
                this.axisList.length = 0, n.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
            }, s.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, s = t.length; i < s; i++) {
                    for (var n = t[i], a = i - 1; 0 <= a && !(t[a].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); a--) t[a + 1] = t[a];
                    t[a + 1] = n
                }
                return t
            }, s.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                s.sortAxisList(t, e)
            }, s.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    s = this.axisIndex;
                i.length = 0;
                for (var n = e.length; n--;) {
                    var a = e[n];
                    a.aabbNeedsUpdate && a.updateAABB()
                }
                this.sortList();
                for (var o = 0, r = 0 | e.length; o !== r; o++)
                    for (var h = e[o], l = o + 1; l < r; l++) {
                        var c = e[l];
                        if (!(c.aabb.lowerBound[s] <= h.aabb.upperBound[s])) break;
                        u.canCollide(h, c) && this.boundingVolumeCheck(h, c) && i.push(h, c)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                for (var s = this.axisIndex, s = 2 === s ? "z" : 1 === s ? "y" : "x", n = this.axisList, a = (e.lowerBound[s], e.upperBound[s], 0); a < n.length; a++) {
                    var o = n[a];
                    o.aabbNeedsUpdate && o.updateAABB(), o.aabb.overlaps(e) && i.push(o)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(t, e, i) {
            function s(t, e, i, s) {
                this.type = i, s = n.defaults(s, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            e.exports = s;
            var n = t("../utils/Utils");
            s.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.stiffness = t, s.needsUpdate = !0
                }
            }, s.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.relaxation = t, s.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 57
        }],
        15: [function(t, e, i) {
            function s(t, e, i) {
                i = f.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }), u.call(this, t, e, u.DISTANCE, i), this.localAnchorA = p.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = p.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var s, n, a = this.localAnchorA,
                    o = this.localAnchorB;
                this.distance = 0, "number" == typeof i.distance ? this.distance = i.distance : (s = p.create(), n = p.create(), r = p.create(), p.rotate(s, a, t.angle), p.rotate(n, o, e.angle), p.add(r, e.position, n), p.sub(r, r, s), p.sub(r, r, t.position), this.distance = p.length(r)), i = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                e = new d(t, e, -i, i);
                this.equations = [e], this.maxForce = i;
                var r = p.create(),
                    h = p.create(),
                    l = p.create(),
                    c = this;
                e.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        s = e.position;
                    return p.rotate(h, a, t.angle), p.rotate(l, o, e.angle), p.add(r, s, l), p.sub(r, r, h), p.sub(r, r, i), p.length(r) - c.distance
                }, this.setMaxForce(i), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }
            var u = t("./Constraint"),
                d = t("../equations/Equation"),
                p = t("../math/vec2"),
                f = t("../utils/Utils");
            ((e.exports = s).prototype = new u).constructor = s;
            var o = p.create(),
                r = p.create(),
                h = p.create();
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (this.distance, e.position),
                    n = i.position,
                    a = this.equations[0],
                    t = t.G;
                p.rotate(r, this.localAnchorA, e.angle), p.rotate(h, this.localAnchorB, i.angle), p.add(o, n, h), p.sub(o, o, r), p.sub(o, o, s), this.position = p.length(o);
                n = !1;
                this.upperLimitEnabled && this.position > this.upperLimit && (a.maxForce = 0, a.minForce = -this.maxForce, this.distance = this.upperLimit, n = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (a.maxForce = this.maxForce, a.minForce = 0, this.distance = this.lowerLimit, n = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || n ? (a.enabled = !0, p.normalize(o, o), s = p.crossLength(r, o), n = p.crossLength(h, o), t[0] = -o[0], t[1] = -o[1], t[2] = -s, t[3] = o[0], t[4] = o[1], t[5] = n) : a.enabled = !1
            }, s.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, n.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new a(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }
            var n = t("./Constraint"),
                a = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, s.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            }, s.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, d.call(this, t, e, d.LOCK, i);
                var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    n = (i.localAngleB, new f(t, e, -s, s)),
                    a = new f(t, e, -s, s),
                    o = new f(t, e, -s, s),
                    r = p.create(),
                    h = p.create(),
                    l = this;
                n.computeGq = function() {
                    return p.rotate(r, l.localOffsetB, t.angle), p.sub(h, e.position, t.position), p.sub(h, h, r), h[0]
                }, a.computeGq = function() {
                    return p.rotate(r, l.localOffsetB, t.angle), p.sub(h, e.position, t.position), p.sub(h, h, r), h[1]
                };
                var c = p.create(),
                    u = p.create();
                o.computeGq = function() {
                    return p.rotate(c, l.localOffsetB, e.angle - l.localAngleB), p.scale(c, c, -1), p.sub(h, t.position, e.position), p.add(h, h, c), p.rotate(u, c, -Math.PI / 2), p.normalize(u, u), p.dot(h, u)
                }, this.localOffsetB = p.create(), i.localOffsetB ? p.copy(this.localOffsetB, i.localOffsetB) : (p.sub(this.localOffsetB, e.position, t.position), p.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(n, a, o), this.setMaxForce(s)
            }
            var d = t("./Constraint"),
                p = t("../math/vec2"),
                f = t("../equations/Equation");
            (((e.exports = s).prototype = new d).constructor = s).prototype.setMaxForce = function(t) {
                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var a = p.create(),
                o = p.create(),
                r = p.create(),
                h = p.fromValues(1, 0),
                l = p.fromValues(0, 1);
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    s = this.bodyA,
                    n = this.bodyB;
                p.rotate(a, this.localOffsetB, s.angle), p.rotate(o, this.localOffsetB, n.angle - this.localAngleB), p.scale(o, o, -1), p.rotate(r, o, Math.PI / 2), p.normalize(r, r), t.G[0] = -1, t.G[1] = 0, t.G[2] = -p.crossLength(a, h), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -p.crossLength(a, l), e.G[4] = 1, i.G[0] = -r[0], i.G[1] = -r[1], i.G[3] = r[0], i.G[4] = r[1], i.G[5] = p.crossLength(o, r)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(t, e, i) {
            function s(s, n, t) {
                t = t || {}, p.call(this, s, n, p.PRISMATIC, t);
                var a = m.fromValues(0, 0),
                    o = m.fromValues(1, 0),
                    r = m.fromValues(0, 0);
                t.localAnchorA && m.copy(a, t.localAnchorA), t.localAxisA && m.copy(o, t.localAxisA), t.localAnchorB && m.copy(r, t.localAnchorB), this.localAnchorA = a, this.localAnchorB = r, this.localAxisA = o;
                var e = this.maxForce = void 0 !== t.maxForce ? t.maxForce : Number.MAX_VALUE,
                    i = new g(s, n, -e, e),
                    h = new m.create,
                    l = new m.create,
                    c = new m.create,
                    u = new m.create;
                i.computeGq = function() {
                    return m.dot(c, u)
                }, i.updateJacobian = function() {
                    var t = this.G,
                        e = s.position,
                        i = n.position;
                    m.rotate(h, a, s.angle), m.rotate(l, r, n.angle), m.add(c, i, l), m.sub(c, c, e), m.sub(c, c, h), m.rotate(u, o, s.angle + Math.PI / 2), t[0] = -u[0], t[1] = -u[1], t[2] = -m.crossLength(h, u) + m.crossLength(u, c), t[3] = u[0], t[4] = u[1], t[5] = m.crossLength(l, u)
                }, this.equations.push(i), t.disableRotationalLock || (i = new y(s, n, -e, e), this.equations.push(i)), this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== t.lowerLimit, this.upperLimitEnabled = void 0 !== t.upperLimit, this.lowerLimit = void 0 !== t.lowerLimit ? t.lowerLimit : 0, this.upperLimit = void 0 !== t.upperLimit ? t.upperLimit : 1, this.upperLimitEquation = new f(s, n), this.lowerLimitEquation = new f(s, n), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = e, this.motorEquation = new g(s, n), this.motorEnabled = !1, this.motorSpeed = 0;
                var d = this,
                    e = this.motorEquation;
                e.computeGW;
                e.computeGq = function() {
                    return 0
                }, e.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.velocity,
                        n = i.velocity,
                        e = e.angularVelocity,
                        i = i.angularVelocity;
                    return this.gmult(t, s, e, n, i) + d.motorSpeed
                }
            }
            var p = t("./Constraint"),
                f = t("../equations/ContactEquation"),
                g = t("../equations/Equation"),
                m = t("../math/vec2"),
                y = t("../equations/RotationalLockEquation");
            ((e.exports = s).prototype = new p).constructor = s;
            var d = m.create(),
                b = m.create(),
                v = m.create(),
                _ = m.create(),
                x = m.create(),
                w = m.create();
            s.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    s = this.lowerLimit,
                    n = this.upperLimitEquation,
                    a = this.lowerLimitEquation,
                    o = this.bodyA,
                    r = this.bodyB,
                    h = this.localAxisA,
                    l = this.localAnchorA,
                    c = this.localAnchorB;
                e.updateJacobian(), m.rotate(d, h, o.angle), m.rotate(_, l, o.angle), m.add(b, _, o.position), m.rotate(x, c, r.angle), m.add(v, x, r.position);
                var u, l = this.position = m.dot(v, d) - m.dot(b, d);
                this.motorEnabled && ((c = this.motorEquation.G)[0] = d[0], c[1] = d[1], c[2] = m.crossLength(d, x), c[3] = -d[0], c[4] = -d[1], c[5] = -m.crossLength(d, _)), this.upperLimitEnabled && i < l ? (m.scale(n.normalA, d, -1), m.sub(n.contactPointA, b, o.position), m.sub(n.contactPointB, v, r.position), m.scale(w, d, i), m.add(n.contactPointA, n.contactPointA, w), -1 === t.indexOf(n) && t.push(n)) : -1 !== (u = t.indexOf(n)) && t.splice(u, 1), this.lowerLimitEnabled && l < s ? (m.scale(a.normalA, d, 1), m.sub(a.contactPointA, b, o.position), m.sub(a.contactPointB, v, r.position), m.scale(w, d, s), m.sub(a.contactPointB, a.contactPointB, w), -1 === t.indexOf(a) && t.push(a)) : -1 !== (u = t.indexOf(a)) && t.splice(u, 1)
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                var t;
                this.motorEnabled && (t = this.equations.indexOf(this.motorEquation), this.equations.splice(t, 1), this.motorEnabled = !1)
            }, s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, o.REVOLUTE, i);
                var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = p.create(), this.pivotB = p.create(), i.worldPivot ? (p.sub(this.pivotA, i.worldPivot, t.position), p.sub(this.pivotB, i.worldPivot, e.position), p.rotate(this.pivotA, this.pivotA, -t.angle), p.rotate(this.pivotB, this.pivotB, -e.angle)) : (p.copy(this.pivotA, i.localPivotA), p.copy(this.pivotB, i.localPivotB));
                var n = this.equations = [new r(t, e, -s, s), new r(t, e, -s, s)],
                    i = n[0],
                    n = n[1],
                    a = this;
                i.computeGq = function() {
                    return p.rotate(f, a.pivotA, t.angle), p.rotate(g, a.pivotB, e.angle), p.add(c, e.position, g), p.sub(c, c, t.position), p.sub(c, c, f), p.dot(c, m)
                }, n.computeGq = function() {
                    return p.rotate(f, a.pivotA, t.angle), p.rotate(g, a.pivotB, e.angle), p.add(c, e.position, g), p.sub(c, c, t.position), p.sub(c, c, f), p.dot(c, y)
                }, n.minForce = i.minForce = -s, n.maxForce = i.maxForce = s, this.motorEquation = new h(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new l(t, e), this.lowerLimitEquation = new l(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }
            var o = t("./Constraint"),
                r = t("../equations/Equation"),
                h = t("../equations/RotationalVelocityEquation"),
                l = t("../equations/RotationalLockEquation"),
                p = t("../math/vec2");
            e.exports = s;
            var f = p.create(),
                g = p.create(),
                m = p.fromValues(1, 0),
                y = p.fromValues(0, 1),
                c = p.create();
            ((s.prototype = new o).constructor = s).prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }, s.prototype.update = function() {
                var t, e = this.bodyA,
                    i = this.bodyB,
                    s = this.pivotA,
                    n = this.pivotB,
                    a = this.equations,
                    o = (a[0], a[1], a[0]),
                    r = a[1],
                    h = this.upperLimit,
                    l = this.lowerLimit,
                    c = this.upperLimitEquation,
                    u = this.lowerLimitEquation,
                    d = this.angle = i.angle - e.angle;
                this.upperLimitEnabled && h < d ? (c.angle = h, -1 === a.indexOf(c) && a.push(c)) : -1 !== (t = a.indexOf(c)) && a.splice(t, 1), this.lowerLimitEnabled && d < l ? (u.angle = l, -1 === a.indexOf(u) && a.push(u)) : -1 !== (t = a.indexOf(u)) && a.splice(t, 1), p.rotate(f, s, e.angle), p.rotate(g, n, i.angle), o.G[0] = -1, o.G[1] = 0, o.G[2] = -p.crossLength(f, m), o.G[3] = 1, o.G[4] = 0, o.G[5] = p.crossLength(g, m), r.G[0] = 0, r.G[1] = -1, r.G[2] = -p.crossLength(f, y), r.G[3] = 0, r.G[4] = 1, r.G[5] = p.crossLength(g, y)
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                var t;
                this.motorEnabled && (t = this.equations.indexOf(this.motorEquation), this.equations.splice(t, 1), this.motorEnabled = !1)
            }, s.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            }, s.prototype.setMotorSpeed = function(t) {
                var e;
                this.motorEnabled && (e = this.equations.indexOf(this.motorEquation), this.equations[e].relativeVelocity = t)
            }, s.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
            }
            var n = t("./Equation");
            t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }, s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, s.prototype.setMaxTorque = function(t) {
                this.maxForce = t, this.minForce = -t
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = p.create(), this.penetrationVec = p.create(), this.contactPointB = p.create(), this.normalA = p.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
            }
            var n = t("./Equation"),
                p = t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeB = function(t, e, i) {
                var s, n = this.bodyA,
                    a = this.bodyB,
                    o = this.contactPointA,
                    r = this.contactPointB,
                    h = n.position,
                    l = a.position,
                    c = this.penetrationVec,
                    u = this.normalA,
                    d = this.G,
                    n = p.crossLength(o, u),
                    a = p.crossLength(r, u);
                return d[0] = -u[0], d[1] = -u[1], d[2] = -n, d[3] = u[0], d[4] = u[1], d[5] = a, p.add(c, l, r), p.sub(c, c, h), p.sub(c, c, o), c = this.firstImpact && 0 !== this.restitution ? (s = 0, 1 / e * (1 + this.restitution) * this.computeGW()) : (s = p.dot(u, c) + this.offset, this.computeGW()), -s * t - c * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(t, e, i) {
            function a(t, e, i, s) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === s ? Number.MAX_VALUE : s, this.bodyA = t, this.bodyB = e, this.stiffness = a.DEFAULT_STIFFNESS, this.relaxation = a.DEFAULT_RELAXATION, this.G = new o.ARRAY_TYPE(6);
                for (var n = 0; n < 6; n++) this.G[n] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }
            e.exports = a;
            var u = t("../math/vec2"),
                o = t("../utils/Utils");
            t("../objects/Body");
            (a.prototype.constructor = a).DEFAULT_STIFFNESS = 1e6, a.DEFAULT_RELAXATION = 4, a.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, a.prototype.gmult = function(t, e, i, s, n) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
            }, a.prototype.computeB = function(t, e, i) {
                var s = this.computeGW();
                return -this.computeGq() * t - s * e - this.computeGiMf() * i
            };
            var s = u.create(),
                n = u.create();
            a.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    e = (e.position, i.position, e.angle),
                    i = i.angle;
                return this.gmult(t, s, e, n, i) + this.offset
            }, a.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.velocity,
                    n = i.velocity,
                    e = e.angularVelocity,
                    i = i.angularVelocity;
                return this.gmult(t, s, e, n, i) + this.relativeVelocity
            }, a.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.vlambda,
                    n = i.vlambda,
                    e = e.wlambda,
                    i = i.wlambda;
                return this.gmult(t, s, e, n, i)
            };
            var d = u.create(),
                p = u.create();
            a.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    s = t.angularForce,
                    n = e.force,
                    a = e.angularForce,
                    o = t.invMassSolve,
                    r = e.invMassSolve,
                    h = t.invInertiaSolve,
                    l = e.invInertiaSolve,
                    c = this.G;
                return u.scale(d, i, o), u.multiply(d, t.massMultiplier, d), u.scale(p, n, r), u.multiply(p, e.massMultiplier, p), this.gmult(c, d, s * h, p, a * l)
            }, a.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    s = e.invMassSolve,
                    n = t.invInertiaSolve,
                    a = e.invInertiaSolve,
                    o = this.G;
                return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * n + o[3] * o[3] * s * e.massMultiplier[0] + o[4] * o[4] * s * e.massMultiplier[1] + o[5] * o[5] * a
            };
            var f = u.create(),
                g = u.create(),
                m = u.create();
            u.create(), u.create(), u.create();
            a.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    s = f,
                    n = g,
                    a = m,
                    o = e.invMassSolve,
                    r = i.invMassSolve,
                    h = e.invInertiaSolve,
                    l = i.invInertiaSolve,
                    c = this.G;
                n[0] = c[0], n[1] = c[1], a[0] = c[3], a[1] = c[4], u.scale(s, n, o * t), u.multiply(s, s, e.massMultiplier), u.add(e.vlambda, e.vlambda, s), e.wlambda += h * c[2] * t, u.scale(s, a, r * t), u.multiply(s, s, i.massMultiplier), u.add(i.vlambda, i.vlambda, s), i.wlambda += l * c[5] * t
            }, a.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(t, e, i) {
            function s(t, e, i) {
                n.call(this, t, e, -i, i), this.contactPointA = r.create(), this.contactPointB = r.create(), this.t = r.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
            }
            var r = t("../math/vec2"),
                n = t("./Equation");
            t("../utils/Utils");
            (((e.exports = s).prototype = new n).constructor = s).prototype.setSlipForce = function(t) {
                this.maxForce = t, this.minForce = -t
            }, s.prototype.getSlipForce = function() {
                return this.maxForce
            }, s.prototype.computeB = function(t, e, i) {
                this.bodyA, this.bodyB;
                var s = this.contactPointA,
                    n = this.contactPointB,
                    a = this.t,
                    o = this.G;
                return o[0] = -a[0], o[1] = -a[1], o[2] = -r.crossLength(s, a), o[3] = a[0], o[4] = a[1], o[5] = r.crossLength(n, a), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                i = this.G;
                i[2] = 1, i[5] = -1
            }
            var n = t("./Equation"),
                a = t("../math/vec2");
            ((e.exports = s).prototype = new n).constructor = s;
            var o = a.create(),
                r = a.create(),
                h = a.fromValues(1, 0),
                l = a.fromValues(0, 1);
            s.prototype.computeGq = function() {
                return a.rotate(o, h, this.bodyA.angle + this.angle), a.rotate(r, l, this.bodyB.angle), a.dot(o, r)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
            }
            var n = t("./Equation");
            t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeB = function(t, e, i) {
                var s = this.G;
                s[2] = -1, s[5] = this.ratio;
                s = this.computeGiMf();
                return -this.computeGW() * e - i * s
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(t, e, i) {
            function s() {}(e.exports = s).prototype = {
                constructor: s,
                on: function(t, e, i) {
                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                    i = this._listeners;
                    return void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e), this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                    } else if (void 0 !== i[t]) return !0;
                    return !1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        e = i[t].indexOf(e);
                    return -1 !== e && i[t].splice(e, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, s = e.length; i < s; i++) {
                            var n = e[i];
                            n.call(n.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            function s(t, e, i) {
                if (i = i || {}, !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                this.id = s.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : a.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : a.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : a.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : a.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }
            var n = t("./Material"),
                a = t("../equations/Equation");
            (e.exports = s).idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(t, e, i) {
            function s(t) {
                this.id = t || s.idCounter++
            }(e.exports = s).idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var b = {
                GetArea: function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                    return .5 * -(i + (t[0] - t[e]) * (t[1 + e] + t[1]))
                },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], s = [], n = 0; n < e; n++) s.push(n);
                    for (var n = 0, a = e; 3 < a;) {
                        var o = s[(n + 0) % a],
                            r = s[(n + 1) % a],
                            h = s[(n + 2) % a],
                            l = t[2 * o],
                            c = t[2 * o + 1],
                            u = t[2 * r],
                            d = t[2 * r + 1],
                            p = t[2 * h],
                            f = t[2 * h + 1],
                            g = !1;
                        if (b._convex(l, c, u, d, p, f)) {
                            g = !0;
                            for (var m = 0; m < a; m++) {
                                var y = s[m];
                                if (y != o && y != r && y != h && b._PointInTriangle(t[2 * y], t[2 * y + 1], l, c, u, d, p, f)) {
                                    g = !1;
                                    break
                                }
                            }
                        }
                        if (g) i.push(o, r, h), s.splice((n + 1) % a, 1), a--, n = 0;
                        else if (n++ > 3 * a) break
                    }
                    return i.push(s[0], s[1], s[2]), i
                },
                _PointInTriangle: function(t, e, i, s, n, a, o, r) {
                    o -= i, r -= s, n -= i, a -= s, t -= i, i = e - s, e = o * o + r * r, s = o * n + r * a, o = o * t + r * i, r = n * n + a * a, a = n * t + a * i, i = 1 / (e * r - s * s), r = (r * o - s * a) * i, i *= e * a - s * o;
                    return 0 <= r && 0 <= i && r + i < 1
                },
                _convex: function(t, e, i, s, n, a) {
                    return 0 <= (e - s) * (n - i) + (i - t) * (a - s)
                }
            };
            e.exports = b
        }, {}],
        30: [function(t, e, i) {
            var a = e.exports = {},
                s = t("../utils/Utils");
            a.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            }, a.crossVZ = function(t, e, i) {
                return a.rotate(t, e, -Math.PI / 2), a.scale(t, t, i), t
            }, a.crossZV = function(t, e, i) {
                return a.rotate(t, i, Math.PI / 2), a.scale(t, t, e), t
            }, a.rotate = function(t, e, i) {
                var s, n, a;
                0 !== i ? (s = Math.cos(i), n = Math.sin(i), a = e[0], i = e[1], t[0] = s * a - n * i, t[1] = n * a + s * i) : (t[0] = e[0], t[1] = e[1])
            }, a.rotate90cw = function(t, e) {
                var i = e[0],
                    e = e[1];
                t[0] = e, t[1] = -i
            }, a.toLocalFrame = function(t, e, i, s) {
                a.copy(t, e), a.sub(t, t, i), a.rotate(t, t, -s)
            }, a.toGlobalFrame = function(t, e, i, s) {
                a.copy(t, e), a.rotate(t, t, s), a.add(t, t, i)
            }, a.vectorToLocalFrame = function(t, e, i) {
                a.rotate(t, e, -i)
            }, a.vectorToGlobalFrame = function(t, e, i) {
                a.rotate(t, e, i)
            }, a.centroid = function(t, e, i, s) {
                return a.add(t, e, i), a.add(t, t, s), a.scale(t, t, 1 / 3), t
            }, a.create = function() {
                var t = new s.ARRAY_TYPE(2);
                return t[0] = 0, t[1] = 0, t
            }, a.clone = function(t) {
                var e = new s.ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e
            }, a.fromValues = function(t, e) {
                var i = new s.ARRAY_TYPE(2);
                return i[0] = t, i[1] = e, i
            }, a.copy = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, a.set = function(t, e, i) {
                return t[0] = e, t[1] = i, t
            }, a.add = function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, a.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, a.sub = a.subtract, a.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, a.mul = a.multiply, a.divide = function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, a.div = a.divide, a.scale = function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, a.distance = function(t, e) {
                var i = e[0] - t[0],
                    t = e[1] - t[1];
                return Math.sqrt(i * i + t * t)
            }, a.dist = a.distance, a.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    t = e[1] - t[1];
                return i * i + t * t
            }, a.sqrDist = a.squaredDistance, a.length = function(t) {
                var e = t[0],
                    t = t[1];
                return Math.sqrt(e * e + t * t)
            }, a.len = a.length, a.squaredLength = function(t) {
                var e = t[0],
                    t = t[1];
                return e * e + t * t
            }, a.sqrLen = a.squaredLength, a.negate = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, a.normalize = function(t, e) {
                var i = e[0],
                    s = e[1],
                    s = i * i + s * s;
                return 0 < s && (s = 1 / Math.sqrt(s), t[0] = e[0] * s, t[1] = e[1] * s), t
            }, a.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, a.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }, a.lerp = function(t, e, i, s) {
                var n = e[0],
                    e = e[1];
                return t[0] = n + s * (i[0] - n), t[1] = e + s * (i[1] - e), t
            }, a.reflect = function(t, e, i) {
                var s = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * s, t[1] = e[1] - 2 * i[1] * s
            }, a.getLineSegmentsIntersection = function(t, e, i, s, n) {
                n = a.getLineSegmentsIntersectionFraction(e, i, s, n);
                return !(n < 0 || (t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), 0))
            }, a.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                var n = e[0] - t[0],
                    a = e[1] - t[1],
                    o = s[0] - i[0],
                    e = s[1] - i[1],
                    s = (-a * (t[0] - i[0]) + n * (t[1] - i[1])) / (-o * a + n * e),
                    e = (o * (t[1] - i[1]) - e * (t[0] - i[0])) / (-o * a + n * e);
                return 0 <= s && s <= 1 && 0 <= e && e <= 1 ? e : -1
            }
        }, {
            "../utils/Utils": 57
        }],
        31: [function(t, e, i) {
            function r(t) {
                t = t || {}, o.call(this), this.id = t.id || ++r._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = u.create(), this.position = u.fromValues(0, 0), t.position && u.copy(this.position, t.position), this.interpolatedPosition = u.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = u.fromValues(0, 0), this.previousAngle = 0, this.velocity = u.fromValues(0, 0), t.velocity && u.copy(this.velocity, t.velocity), this.vlambda = u.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = u.create(), t.force && u.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = r.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = r.DYNAMIC : this.type = r.STATIC, this.boundingRadius = 0, this.aabb = new a, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = r.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
            }
            var u = t("../math/vec2"),
                l = t("poly-decomp"),
                c = t("../shapes/Convex"),
                s = t("../collision/RaycastResult"),
                n = t("../collision/Ray"),
                a = t("../collision/AABB"),
                o = t("../events/EventEmitter");
            (e.exports = r).prototype = new o, (r.prototype.constructor = r)._idCounter = 0, r.prototype.updateSolveMassProperties = function() {
                this.sleepState === r.SLEEPING || this.type === r.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            }, r.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, r.prototype.getArea = function() {
                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            }, r.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
            };
            var h = new a,
                d = u.create();
            r.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = d, s = this.angle, n = 0; n !== e; n++) {
                    var a = t[n],
                        o = a.angle + s;
                    u.rotate(i, a.position, s), u.add(i, i, this.position), a.computeAABB(h, i, o), 0 === n ? this.aabb.copy(h) : this.aabb.extend(h)
                }
                this.aabbNeedsUpdate = !1
            }, r.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                    var n = t[s],
                        a = u.length(n.position),
                        n = n.boundingRadius;
                    i < a + n && (i = a + n)
                }
                this.boundingRadius = i
            }, r.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? u.copy(t.position, e) : u.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, r.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, !(t.body = null))
            }, r.prototype.updateMassProperties = function() {
                if (this.type === r.STATIC || this.type === r.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        s = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var n = 0; n < e; n++) {
                            var a = t[n],
                                o = u.squaredLength(a.position);
                            s += a.computeMomentOfInertia(i) + i * o
                        }
                        this.inertia = s, this.invInertia = 0 < s ? 1 / s : 0
                    }
                    this.invMass = 1 / this.mass, u.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            };
            u.create();
            r.prototype.applyForce = function(t, e) {
                u.add(this.force, this.force, t), e && (t = u.crossLength(e, t), this.angularForce += t)
            };
            var p = u.create(),
                f = u.create(),
                g = u.create();
            r.prototype.applyForceLocal = function(t, e) {
                e = e || g;
                var i = p,
                    s = f;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyForce(i, s)
            };
            var m = u.create();
            r.prototype.applyImpulse = function(t, e) {
                var i;
                this.type === r.DYNAMIC && (i = m, u.scale(i, t, this.invMass), u.multiply(i, this.massMultiplier, i), u.add(this.velocity, i, this.velocity), e && (t = u.crossLength(e, t), t *= this.invInertia, this.angularVelocity += t))
            };
            var y = u.create(),
                b = u.create(),
                v = u.create();
            r.prototype.applyImpulseLocal = function(t, e) {
                e = e || v;
                var i = y,
                    s = b;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyImpulse(i, s)
            }, r.prototype.toLocalFrame = function(t, e) {
                u.toLocalFrame(t, e, this.position, this.angle)
            }, r.prototype.toWorldFrame = function(t, e) {
                u.toGlobalFrame(t, e, this.position, this.angle)
            }, r.prototype.vectorToLocalFrame = function(t, e) {
                u.vectorToLocalFrame(t, e, this.angle)
            }, r.prototype.vectorToWorldFrame = function(t, e) {
                u.vectorToGlobalFrame(t, e, this.angle)
            }, r.prototype.fromPolygon = function(t, e) {
                e = e || {};
                for (var i = this.shapes.length; 0 <= i; --i) this.removeShape(this.shapes[i]);
                var s = new l.Polygon;
                if (s.vertices = t, s.makeCCW(), "number" == typeof e.removeCollinearPoints && s.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !s.isSimple()) return !1;
                this.concavePath = s.vertices.slice(0);
                for (var n, i = 0; i < this.concavePath.length; i++) {
                    var a = [0, 0];
                    u.copy(a, this.concavePath[i]), this.concavePath[i] = a
                }
                n = e.optimalDecomp ? s.decomp() : s.quickDecomp();
                for (var o = u.create(), i = 0; i !== n.length; i++) {
                    for (var r = new c({
                            vertices: n[i].vertices
                        }), h = 0; h !== r.vertices.length; h++) {
                        a = r.vertices[h];
                        u.sub(a, a, r.centerOfMass)
                    }
                    u.scale(o, r.centerOfMass, 1), r.updateTriangles(), r.updateCenterOfMass(), r.updateBoundingRadius(), this.addShape(r, o)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0
            };
            u.fromValues(0, 0);
            var _ = u.fromValues(0, 0),
                x = u.fromValues(0, 0),
                w = u.fromValues(0, 0);
            r.prototype.adjustCenterOfMass = function() {
                var t = _,
                    e = x,
                    i = w,
                    s = 0;
                u.set(e, 0, 0);
                for (var n = 0; n !== this.shapes.length; n++) {
                    var a = this.shapes[n];
                    u.scale(t, a.position, a.area), u.add(e, e, t), s += a.area
                }
                u.scale(i, e, 1 / s);
                for (n = 0; n !== this.shapes.length; n++) {
                    a = this.shapes[n];
                    u.sub(a.position, a.position, i)
                }
                u.add(this.position, this.position, i);
                for (n = 0; this.concavePath && n < this.concavePath.length; n++) u.sub(this.concavePath[n], this.concavePath[n], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, r.prototype.setZeroForce = function() {
                u.set(this.force, 0, 0), this.angularForce = 0
            }, r.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                u.set(t, 0, 0), this.wlambda = 0
            }, r.prototype.addConstraintVelocity = function() {
                var t = this.velocity;
                u.add(t, t, this.vlambda), this.angularVelocity += this.wlambda
            }, r.prototype.applyDamping = function(t) {
                var e;
                this.type === r.DYNAMIC && (e = this.velocity, u.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t))
            }, r.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = r.AWAKE, this.idleTime = 0, t !== r.AWAKE && this.emit(r.wakeUpEvent)
            }, r.prototype.sleep = function() {
                this.sleepState = r.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, u.set(this.velocity, 0, 0), u.set(this.force, 0, 0), this.emit(r.sleepEvent)
            }, r.prototype.sleepTick = function(t, e, i) {
                this.allowSleep && this.type !== r.SLEEPING && (this.wantsToSleep = !1, this.sleepState, u.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = r.AWAKE) : (this.idleTime += i, this.sleepState = r.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep()))
            }, r.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var P = u.create(),
                T = u.create();
            r.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    s = this.position,
                    n = this.velocity;
                u.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), u.scale(P, i, t * e), u.multiply(P, this.massMultiplier, P), u.add(n, P, n), this.integrateToTimeOfImpact(t) || (u.scale(T, n, t), u.add(s, s, T), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var S = new s,
                C = new n({
                    mode: n.ALL
                }),
                A = u.create(),
                E = u.create(),
                I = u.create(),
                B = u.create();
            r.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || u.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                u.normalize(A, this.velocity), u.scale(E, this.velocity, t), u.add(E, E, this.position), u.sub(I, E, this.position);
                var e, i = this.angularVelocity * t,
                    s = u.length(I),
                    n = 1,
                    a = this;
                if (S.reset(), C.callback = function(t) {
                        t.body !== a && (e = t.body, t.getHitPoint(E, C), u.sub(I, E, a.position), n = u.length(I) / s, t.stop())
                    }, u.copy(C.from, this.position), u.copy(C.to, E), C.update(), this.world.raycast(S, C), !e) return !1;
                var o = this.angle;
                u.copy(B, this.position);
                for (var r = 0, h = 0, l = 0, c = n; h <= c && r < this.ccdIterations;) r++, l = (c - h) / 2, u.scale(T, I, n), u.add(this.position, B, T), this.angle = o + i * n, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? h = l : c = l;
                return n = l, u.copy(this.position, B), this.angle = o, u.scale(T, I, n), u.add(this.position, this.position, T), this.fixedRotation || (this.angle += i * n), !0
            }, r.prototype.getVelocityAtPoint = function(t, e) {
                return u.crossVZ(t, e, this.angularVelocity), u.subtract(t, this.velocity, t), t
            }, r.sleepyEvent = {
                type: "sleepy"
            }, r.sleepEvent = {
                type: "sleep"
            }, r.wakeUpEvent = {
                type: "wakeup"
            }, r.DYNAMIC = 1, r.STATIC = 2, r.KINEMATIC = 4, r.AWAKE = 0, r.SLEEPY = 1, r.SLEEPING = 2
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, i), this.localAnchorA = f.fromValues(0, 0), this.localAnchorB = f.fromValues(0, 0), i.localAnchorA && f.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && f.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                t = f.create(), e = f.create();
                this.getWorldAnchorA(t), this.getWorldAnchorB(e);
                e = f.distance(t, e);
                this.restLength = "number" == typeof i.restLength ? i.restLength : e
            }
            var f = t("../math/vec2"),
                n = t("./Spring");
            t("../utils/Utils");
            (((e.exports = s).prototype = new n).constructor = s).prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            }, s.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            }, s.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            }, s.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var g = f.create(),
                m = f.create(),
                y = f.create(),
                b = f.create(),
                v = f.create(),
                _ = f.create(),
                x = f.create(),
                w = f.create(),
                P = f.create();
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    s = this.bodyA,
                    n = this.bodyB,
                    a = g,
                    o = m,
                    r = y,
                    h = b,
                    l = P,
                    c = v,
                    u = _,
                    d = x,
                    p = w;
                this.getWorldAnchorA(c), this.getWorldAnchorB(u), f.sub(d, c, s.position), f.sub(p, u, n.position), f.sub(a, u, c);
                c = f.len(a);
                f.normalize(o, a), f.sub(r, n.velocity, s.velocity), f.crossZV(l, n.angularVelocity, p), f.add(r, r, l), f.crossZV(l, s.angularVelocity, d), f.sub(r, r, l), f.scale(h, o, -t * (c - i) - e * f.dot(r, o)), f.sub(s.force, s.force, h), f.add(n.force, n.force, h);
                d = f.crossLength(d, h), h = f.crossLength(p, h);
                s.angularForce -= d, n.angularForce += h
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
            }
            t("../math/vec2");
            var n = t("./Spring");
            (((e.exports = s).prototype = new n).constructor = s).prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    s = this.bodyA,
                    n = this.bodyB,
                    e = -t * (n.angle - s.angle - i) - e * (n.angularVelocity - s.angularVelocity) * 0;
                s.angularForce -= e, n.angularForce += e
            }
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(t, e, i) {
            function s(t, e, i) {
                i = n.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
            }
            t("../math/vec2");
            var n = t("../utils/Utils");
            (e.exports = s).prototype.applyForce = function() {}
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(t, e, i) {
            function s(t, e) {
                this.chassisBody = t, this.wheels = [], this.groundBody = new h({
                    mass: 0
                }), this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }

            function n(t, e) {
                e = e || {}, this.vehicle = t, this.forwardEquation = new r(t.chassisBody, t.groundBody), this.sideEquation = new r(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = a.fromValues(0, 1), e.localForwardVector && a.copy(this.localForwardVector, e.localForwardVector), this.localPosition = a.fromValues(0, 0), e.localPosition && a.copy(this.localPosition, e.localPosition), o.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
            }
            var a = t("../math/vec2"),
                o = (t("../utils/Utils"), t("../constraints/Constraint")),
                r = t("../equations/FrictionEquation"),
                h = t("../objects/Body");
            (e.exports = s).prototype.addToWorld = function(t) {
                (this.world = t).addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, s.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, s.prototype.addWheel = function(t) {
                t = new n(this, t);
                return this.wheels.push(t), t
            }, s.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            }, (n.prototype = new o).setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            }, n.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = a.create(),
                c = a.create();
            n.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), a.dot(l, c)
            };
            var u = a.create();
            n.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), a.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), a.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), a.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), a.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), a.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), a.normalize(u, this.forwardEquation.t), a.scale(u, u, this.engineForce), this.vehicle.chassisBody.applyForce(u, this.forwardEquation.contactPointA)
            }
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(t, e, i) {
            t = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(t, "Rectangle", {
                get: function() {
                    return this.Box
                }
            })
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    width: arguments[0],
                    height: arguments[1]
                }), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    e = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    i = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = e, t.axes = i, t.type = a.BOX, o.call(this, t)
            }
            var n = t("../math/vec2"),
                a = t("./Shape"),
                o = t("./Convex");
            (((e.exports = s).prototype = new o).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, s.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            };
            n.create(), n.create(), n.create(), n.create();
            s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            }, s.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    length: arguments[0],
                    radius: arguments[1]
                }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = n.CAPSULE, n.call(this, t)
            }
            var n = t("./Shape"),
                v = t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    e = 2 * e;
                return t * (e * e + i * i) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var a = v.create();
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                v.set(a, this.length / 2, 0), 0 !== i && v.rotate(a, a, i), v.set(t.upperBound, Math.max(a[0] + s, -a[0] + s), Math.max(a[1] + s, -a[1] + s)), v.set(t.lowerBound, Math.min(a[0] - s, -a[0] - s), Math.min(a[1] - s, -a[1] - s)), v.add(t.lowerBound, t.lowerBound, e), v.add(t.upperBound, t.upperBound, e)
            };
            var _ = v.create(),
                x = v.create(),
                w = v.create(),
                P = v.create(),
                T = v.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                for (var n = e.from, a = e.to, o = (e.direction, _), r = x, h = w, l = P, c = this.length / 2, u = 0; u < 2; u++) {
                    var d = this.radius * (2 * u - 1);
                    if (v.set(h, -c, d), v.set(l, c, d), v.toGlobalFrame(h, h, i, s), v.toGlobalFrame(l, l, i, s), 0 <= (f = v.getLineSegmentsIntersectionFraction(n, a, h, l)) && (v.rotate(r, T, s), v.scale(r, r, 2 * u - 1), e.reportIntersection(t, f, r, -1), t.shouldStop(e))) return
                }
                for (var p = Math.pow(this.radius, 2) + Math.pow(c, 2), u = 0; u < 2; u++) {
                    v.set(h, c * (2 * u - 1), 0), v.toGlobalFrame(h, h, i, s);
                    var f, g = Math.pow(a[0] - n[0], 2) + Math.pow(a[1] - n[1], 2),
                        m = 2 * ((a[0] - n[0]) * (n[0] - h[0]) + (a[1] - n[1]) * (n[1] - h[1])),
                        y = Math.pow(n[0] - h[0], 2) + Math.pow(n[1] - h[1], 2) - Math.pow(this.radius, 2);
                    if (!((f = Math.pow(m, 2) - 4 * g * y) < 0))
                        if (0 === f) {
                            if (v.lerp(o, n, a, f), v.squaredDistance(o, i) > p && (v.sub(r, o, h), v.normalize(r, r), e.reportIntersection(t, f, r, -1), t.shouldStop(e))) return
                        } else {
                            var b = Math.sqrt(f),
                                y = 1 / (2 * g),
                                g = (-m - b) * y,
                                y = (-m + b) * y;
                            if (0 <= g && g <= 1 && (v.lerp(o, n, a, g), v.squaredDistance(o, i) > p && (v.sub(r, o, h), v.normalize(r, r), e.reportIntersection(t, g, r, -1), t.shouldStop(e)))) return;
                            if (0 <= y && y <= 1 && (v.lerp(o, n, a, y), v.squaredDistance(o, i) > p && (v.sub(r, o, h), v.normalize(r, r), e.reportIntersection(t, y, r, -1), t.shouldStop(e)))) return
                        }
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    radius: arguments[0]
                }), t = t || {}, this.radius = t.radius || 1, t.type = n.CIRCLE, n.call(this, t)
            }
            var n = t("./Shape"),
                d = t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                d.set(t.upperBound, s, s), d.set(t.lowerBound, -s, -s), e && (d.add(t.lowerBound, t.lowerBound, e), d.add(t.upperBound, t.upperBound, e))
            };
            var p = d.create(),
                f = d.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    a = e.to,
                    o = this.radius,
                    r = Math.pow(a[0] - n[0], 2) + Math.pow(a[1] - n[1], 2),
                    h = 2 * ((a[0] - n[0]) * (n[0] - i[0]) + (a[1] - n[1]) * (n[1] - i[1])),
                    l = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(o, 2),
                    c = Math.pow(h, 2) - 4 * r * l,
                    u = p,
                    o = f;
                c < 0 || (0 == c ? (d.lerp(u, n, a, c), d.sub(o, u, i), d.normalize(o, o), e.reportIntersection(t, c, o, -1)) : (r = (-h + (l = Math.sqrt(c))) * (c = 1 / (2 * r)), 0 <= (c = (-h - l) * c) && c <= 1 && (d.lerp(u, n, a, c), d.sub(o, u, i), d.normalize(o, o), e.reportIntersection(t, c, o, -1), t.shouldStop(e)) || 0 <= r && r <= 1 && (d.lerp(u, n, a, r), d.sub(o, u, i), d.normalize(o, o), e.reportIntersection(t, r, o, -1))))
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(t, e, i) {
            function u(t) {
                Array.isArray(arguments[0]) && (t = {
                    vertices: arguments[0],
                    axes: arguments[1]
                }), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var s = p.create();
                    p.copy(s, e[i]), this.vertices.push(s)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var n = p.create();
                        p.copy(n, t.axes[i]), this.axes.push(n)
                    } else
                        for (i = 0; i < this.vertices.length; i++) {
                            var a = this.vertices[i],
                                o = this.vertices[(i + 1) % this.vertices.length],
                                r = p.create();
                            p.sub(r, o, a), p.rotate90cw(r, r), p.normalize(r, r), this.axes.push(r)
                        }
                if (this.centerOfMass = p.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = h.CONVEX, h.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var h = t("./Shape"),
                p = t("../math/vec2"),
                r = t("../math/polyk");
            t("poly-decomp");
            ((e.exports = u).prototype = new h).constructor = u;
            var l = p.create(),
                a = p.create();
            u.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, s, n = null, a = null, t = l, o = 0; o < this.vertices.length; o++) i = this.vertices[o], i = p.dot(i, t), (null === n || n < i) && (n = i), (null === a || i < a) && (a = i);
                n < a && (s = a, a = n, n = s), p.set(e, a, n)
            }, u.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                var n = a;
                this.projectOntoLocalAxis(t, s), 0 !== i ? p.rotate(n, t, i) : n = t;
                n = p.dot(e, n);
                p.set(s, s[0] + n, s[1] + n)
            }, u.prototype.updateTriangles = function() {
                for (var t = [], e = this.triangles.length = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                for (var s = r.Triangulate(t), e = 0; e < s.length; e += 3) {
                    var n = s[e],
                        a = s[e + 1],
                        o = s[e + 2];
                    this.triangles.push([n, a, o])
                }
            };
            var d = p.create(),
                f = p.create();
            p.create(), p.create(), p.create(), p.create(), p.create(), p.create(), p.create();
            u.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    s = d,
                    n = f;
                p.set(i, 0, 0);
                for (var a = 0, o = 0; o !== t.length; o++) {
                    var r = t[o],
                        h = e[r[0]],
                        l = e[r[1]],
                        c = e[r[2]];
                    p.centroid(s, h, l, c);
                    r = u.triangleArea(h, l, c);
                    a += r, p.scale(n, s, r), p.add(i, i, n)
                }
                p.scale(i, i, 1 / a)
            }, u.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, s = this.vertices.length, n = s - 1, a = 0; a < s; n = a, a++) {
                    var o = this.vertices[n],
                        r = this.vertices[a],
                        h = Math.abs(p.crossLength(o, r));
                    e += h * (p.dot(r, r) + p.dot(r, o) + p.dot(o, o)), i += h
                }
                return t / 6 * (e / i)
            }, u.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var s = p.squaredLength(t[i]);
                    e < s && (e = s)
                }
                this.boundingRadius = Math.sqrt(e)
            }, u.triangleArea = function(t, e, i) {
                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            }, u.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var s = t[i],
                        n = e[s[0]],
                        a = e[s[1]],
                        s = e[s[2]],
                        s = u.triangleArea(n, a, s);
                    this.area += s
                }
            }, u.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var g = p.create(),
                m = p.create(),
                y = p.create();
            u.prototype.raycast = function(t, e, i, s) {
                var n = g,
                    a = m,
                    o = y,
                    r = this.vertices;
                p.toLocalFrame(n, e.from, i, s), p.toLocalFrame(a, e.to, i, s);
                for (var h = r.length, l = 0; l < h && !t.shouldStop(e); l++) {
                    var c = r[l],
                        u = r[(l + 1) % h],
                        d = p.getLineSegmentsIntersectionFraction(n, a, c, u);
                    0 <= d && (p.sub(o, u, c), p.rotate(o, o, -Math.PI / 2 + s), p.normalize(o, o), e.reportIntersection(t, d, o, l))
                }
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(t, e, i) {
            function s(t) {
                if (Array.isArray(arguments[0]) && (t = {
                        heights: arguments[0]
                    }, "object" == typeof arguments[1]))
                    for (var e in arguments[1]) t[e] = arguments[1][e];
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = n.HEIGHTFIELD, n.call(this, t)
            }
            var n = t("./Shape"),
                p = t("../math/vec2");
            t("../utils/Utils");
            (((e.exports = s).prototype = new n).constructor = s).prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                    var n = t[s];
                    e < n && (e = n), n < i && (i = n)
                }
                this.maxValue = e, this.minValue = i
            }, s.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var a = [p.create(), p.create(), p.create(), p.create()];
            s.prototype.computeAABB = function(t, e, i) {
                p.set(a[0], 0, this.maxValue), p.set(a[1], this.elementWidth * this.heights.length, this.maxValue), p.set(a[2], this.elementWidth * this.heights.length, this.minValue), p.set(a[3], 0, this.minValue), t.setFromPoints(a, e, i)
            }, s.prototype.getLineSegment = function(t, e, i) {
                var s = this.heights,
                    n = this.elementWidth;
                p.set(t, i * n, s[i]), p.set(e, (i + 1) * n, s[i + 1])
            }, s.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            }, s.prototype.getClampedSegmentIndex = function(t) {
                t = this.getSegmentIndex(t);
                return Math.min(this.heights.length, Math.max(t, 0))
            };
            p.create();
            var f = p.create(),
                g = p.create(),
                m = p.create(),
                y = p.create(),
                b = p.create();
            p.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    a = e.to,
                    o = (e.direction, f),
                    r = g,
                    h = m,
                    l = y,
                    c = b;
                p.toLocalFrame(l, n, i, s), p.toLocalFrame(c, a, i, s);
                n = this.getClampedSegmentIndex(l), a = this.getClampedSegmentIndex(c);
                a < n && (i = n, n = a, a = i);
                for (var u = 0; u < this.heights.length - 1; u++) {
                    this.getLineSegment(r, h, u);
                    var d = p.getLineSegmentsIntersectionFraction(l, c, r, h);
                    if (0 <= d && (p.sub(o, h, r), p.rotate(o, o, s + Math.PI / 2), p.normalize(o, o), e.reportIntersection(t, d, o, -1), t.shouldStop(e))) return
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    length: arguments[0]
                }), t = t || {}, this.length = t.length || 1, t.type = n.LINE, n.call(this, t)
            }
            var n = t("./Shape"),
                l = t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var a = [l.create(), l.create()];
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.length / 2;
                l.set(a[0], -s, 0), l.set(a[1], s, 0), t.setFromPoints(a, e, i, 0)
            };
            l.create();
            var c = l.create(),
                u = l.create(),
                d = l.create(),
                p = l.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    a = e.to,
                    o = u,
                    r = d,
                    h = this.length / 2;
                l.set(o, -h, 0), l.set(r, h, 0), l.toGlobalFrame(o, o, i, s), l.toGlobalFrame(r, r, i, s);
                n = l.getLineSegmentsIntersectionFraction(o, r, n, a);
                0 <= n && (a = c, l.rotate(a, p, s), e.reportIntersection(t, n, a, -1))
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = n.PARTICLE, n.call(this, t)
            }
            var n = t("./Shape"),
                a = t("../math/vec2");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }, s.prototype.computeAABB = function(t, e, i) {
                a.copy(t.lowerBound, e), a.copy(t.upperBound, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = n.PLANE, n.call(this, t)
            }
            var n = t("./Shape"),
                c = t("../math/vec2");
            t("../utils/Utils");
            (((e.exports = s).prototype = new n).constructor = s).prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = i % (2 * Math.PI),
                    n = c.set,
                    a = Number.MAX_VALUE,
                    i = t.lowerBound,
                    t = t.upperBound;
                0 == s ? (n(i, -a, -a), n(t, a, 0)) : s == Math.PI / 2 ? (n(i, 0, -a), n(t, a, a)) : s === Math.PI ? (n(i, -a, 0), n(t, a, a)) : s == 3 * Math.PI / 2 ? (n(i, -a, -a), n(t, 0, a)) : (n(i, -a, -a), n(t, a, a)), c.add(i, i, e), c.add(t, t, e)
            }, s.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var u = c.create(),
                d = (c.create(), c.create(), c.create()),
                p = c.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    a = e.to,
                    o = e.direction,
                    r = u,
                    h = d,
                    l = p;
                c.set(h, 0, 1), c.rotate(h, h, s), c.sub(l, n, i);
                s = c.dot(l, h);
                c.sub(l, a, i), 0 < s * c.dot(l, h) || c.squaredDistance(n, a) < s * s || (o = c.dot(h, o), c.sub(r, n, i), o = -c.dot(h, r) / o / e.length, e.reportIntersection(t, o, h, -1))
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.body = null, this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
            }
            e.exports = s;
            var n = t("../math/vec2");
            s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, Object.defineProperty(s, "RECTANGLE", {
                get: function() {
                    return s.BOX
                }
            }), s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, s) {}
        }, {
            "../math/vec2": 30
        }],
        46: [function(t, e, i) {
            function w(t) {
                s.call(this, t, s.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new T.ARRAY_TYPE(this.arrayStep), this.Bs = new T.ARRAY_TYPE(this.arrayStep), this.invCs = new T.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
            }
            var P = t("../math/vec2"),
                s = t("./Solver"),
                T = t("../utils/Utils"),
                S = t("../equations/FrictionEquation");
            (((e.exports = w).prototype = new s).constructor = w).prototype.solve = function(t, e) {
                this.sortEquations();
                var i = 0,
                    s = this.iterations,
                    n = this.frictionIterations,
                    a = this.equations,
                    o = a.length,
                    r = Math.pow(this.tolerance * o, 2),
                    h = e.bodies,
                    l = e.bodies.length,
                    c = (P.add, P.set, this.useZeroRHS),
                    u = this.lambda;
                if (this.usedIterations = 0, o)
                    for (var d = 0; d !== l; d++) h[d].updateSolveMassProperties();
                u.length < o && (u = this.lambda = new T.ARRAY_TYPE(o + this.arrayStep), this.Bs = new T.ARRAY_TYPE(o + this.arrayStep), this.invCs = new T.ARRAY_TYPE(o + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--;) t[e] = 0
                    }(u);
                for (var p, f, g, m = this.invCs, y = this.Bs, u = this.lambda, d = 0; d !== a.length; d++)(p = a[d]).timeStep === t && !p.needsUpdate || (p.timeStep = t, p.update()), y[d] = p.computeB(p.a, p.b, t), m[d] = p.computeInvC(p.epsilon);
                if (0 !== o) {
                    for (d = 0; d !== l; d++) h[d].resetConstraintVelocity();
                    if (n) {
                        for (i = 0; i !== n; i++) {
                            for (g = f = 0; g !== o; g++) {
                                p = a[g];
                                var b = w.iterateEquation(g, p, p.epsilon, y, m, u, c, t, i);
                                f += Math.abs(b)
                            }
                            if (this.usedIterations++, f * f <= r) break
                        }
                        for (w.updateMultipliers(a, u, 1 / t), g = 0; g !== o; g++) {
                            var v = a[g];
                            if (v instanceof S) {
                                for (var _ = 0, x = 0; x !== v.contactEquations.length; x++) _ += v.contactEquations[x].multiplier;
                                _ *= v.frictionCoefficient / v.contactEquations.length, v.maxForce = _, v.minForce = -_
                            }
                        }
                    }
                    for (i = 0; i !== s; i++) {
                        for (g = f = 0; g !== o; g++) {
                            p = a[g];
                            b = w.iterateEquation(g, p, p.epsilon, y, m, u, c, t, i);
                            f += Math.abs(b)
                        }
                        if (this.usedIterations++, f * f <= r) break
                    }
                    for (d = 0; d !== l; d++) h[d].addConstraintVelocity();
                    w.updateMultipliers(a, u, 1 / t)
                }
            }, w.updateMultipliers = function(t, e, i) {
                for (var s = t.length; s--;) t[s].multiplier = e[s] * i
            }, w.iterateEquation = function(t, e, i, s, n, a, o, r, h) {
                var l = s[t],
                    c = n[t],
                    u = a[t],
                    d = e.computeGWlambda(),
                    s = e.maxForce,
                    n = e.minForce;
                o && (l = 0);
                d = c * (l - d - i * u), i = u + d;
                return i < n * r ? d = n * r - u : s * r < i && (d = s * r - u), a[t] += d, e.addToWlambda(d), d
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(t, e, i) {
            function s(t, e) {
                t = t || {}, n.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
            }
            t("../utils/Utils");
            var n = t("../events/EventEmitter");
            (((e.exports = s).prototype = new n).constructor = s).prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var a = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), a.bodies.length = 0, e.getBodies(a.bodies), a.bodies.length && this.solve(t, a))
            }, s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }, s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            }, s.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var s = t[e];
                    s.enabled && this.equations.push(s)
                }
            }, s.prototype.removeEquation = function(t) {
                t = this.equations.indexOf(t); - 1 !== t && this.equations.splice(t, 1)
            }, s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }, s.GS = 1, s.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(t, e, i) {
            function s() {
                a.apply(this, arguments)
            }
            var n = t("../equations/ContactEquation"),
                a = t("./Pool");
            (((e.exports = s).prototype = new a).constructor = s).prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(t, e, i) {
            function s() {
                a.apply(this, arguments)
            }
            var n = t("../equations/FrictionEquation"),
                a = t("./Pool");
            (((e.exports = s).prototype = new a).constructor = s).prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(t, e, i) {
            function s() {
                a.apply(this, arguments)
            }
            var n = t("../world/IslandNode"),
                a = t("./Pool");
            (((e.exports = s).prototype = new a).constructor = s).prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(t, e, i) {
            function s() {
                a.apply(this, arguments)
            }
            var n = t("../world/Island"),
                a = t("./Pool");
            (((e.exports = s).prototype = new a).constructor = s).prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(t, e, i) {
            function s() {
                this.overlappingShapesLastState = new n, this.overlappingShapesCurrentState = new n, this.recordPool = new a({
                    size: 16
                }), this.tmpDict = new n, this.tmpArray1 = []
            }
            var n = t("./TupleDictionary"),
                a = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils");
            (e.exports = s).prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var s = t.keys[i],
                        n = t.getByKey(s);
                    e.getByKey(s);
                    n && this.recordPool.release(n)
                }
                t.reset(), t.copy(e), e.reset()
            }, s.prototype.setOverlapping = function(t, e, i, s) {
                this.overlappingShapesLastState;
                var n, a = this.overlappingShapesCurrentState;
                a.get(e.id, s.id) || ((n = this.recordPool.get()).set(t, e, i, s), a.set(e.id, s.id, n))
            }, s.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            }, s.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            }, s.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--;) {
                    var n = i.keys[s],
                        n = i.data[n];
                    if (n.bodyA === t && n.bodyB === e || n.bodyA === e && n.bodyB === t) return !0
                }
                return !1
            }, s.prototype.getDiff = function(t, e, i) {
                var s = t,
                    n = e;
                (i = i || []).length = 0;
                for (var a = n.keys.length; a--;) {
                    var o = n.keys[a],
                        r = n.data[o];
                    if (!r) throw new Error("Key " + o + " had no data!");
                    s.data[o] || i.push(r)
                }
                return i
            }, s.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id,
                    t = this.overlappingShapesLastState,
                    e = this.overlappingShapesCurrentState;
                return !t.get(i, s) && !!e.get(i, s)
            }, s.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, s = t.length; s--;) {
                    var n = t[s];
                    i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                }
                for (s = i.keys.length; s--;)(n = i.getByKey(i.keys[s])) && e.push(n.bodyA, n.bodyB);
                return i.reset(), e
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(t, e, i) {
            function n(t, e, i, s) {
                this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i
            }(e.exports = n).prototype.set = function(t, e, i, s) {
                n.call(this, t, e, i, s)
            }
        }, {}],
        54: [function(t, e, i) {
            function s() {
                a.apply(this, arguments)
            }
            var n = t("./OverlapKeeperRecord"),
                a = t("./Pool");
            (((e.exports = s).prototype = new a).constructor = s).prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
            }(e.exports = s).prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            }, s.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            }, s.prototype.release = function(t) {
                return this.destroy(t), this.objects.push(t), this
            }
        }, {}],
        56: [function(t, e, i) {
            function s() {
                this.data = {}, this.keys = []
            }
            var n = t("./Utils");
            (e.exports = s).prototype.getKey = function(t, e) {
                return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | e) < (0 | t) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
            }, s.prototype.getByKey = function(t) {
                return t |= 0, this.data[t]
            }, s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            }, s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                e = this.getKey(t, e);
                return this.data[e] || this.keys.push(e), this.data[e] = i, e
            }, s.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, s.prototype.copy = function(t) {
                this.reset(), n.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, {
            "./Utils": 57
        }],
        57: [function(t, e, i) {
            function s() {}(e.exports = s).appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
            }, s.splice = function(t, e, i) {
                i = i || 1;
                for (var s = e, n = t.length - i; s < n; s++) t[s] = t[s + i];
                t.length = n
            }, "undefined" != typeof P2_ARRAY_TYPE ? s.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? s.ARRAY_TYPE = Float32Array : s.ARRAY_TYPE = Array, s.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            }, s.defaults = function(t, e) {
                for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                return t
            }
        }, {}],
        58: [function(t, e, i) {
            function s() {
                this.equations = [], this.bodies = []
            }
            var n = t("../objects/Body");
            (e.exports = s).prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var a = [];
            s.prototype.getBodies = function(t) {
                for (var e = t || [], i = this.equations, s = a.length = 0; s !== i.length; s++) {
                    var n = i[s]; - 1 === a.indexOf(n.bodyA.id) && (e.push(n.bodyA), a.push(n.bodyA.id)), -1 === a.indexOf(n.bodyB.id) && (e.push(n.bodyB), a.push(n.bodyB.id))
                }
                return e
            }, s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === n.DYNAMIC && !e.wantsToSleep) return !1
                }
                return !0
            }, s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) this.bodies[t].sleep();
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        59: [function(t, e, i) {
            function p(t) {
                this.nodePool = new s({
                    size: 16
                }), this.islandPool = new n({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
            }
            t("../math/vec2"), t("./Island"), t("./IslandNode");
            var s = t("./../utils/IslandNodePool"),
                n = t("./../utils/IslandPool"),
                o = t("../objects/Body");
            (e.exports = p).getUnvisitedNode = function(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var s = t[i];
                    if (!s.visited && s.body.type === o.DYNAMIC) return s
                }
                return !1
            }, p.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var s = t.equations.length, n = 0; n !== s; n++) {
                    var a = t.equations[n]; - 1 === i.indexOf(a) && i.push(a)
                }
            }, p.prototype.bfs = function(t, e, i) {
                var s = this.queue;
                for (s.length = 0, s.push(t), t.visited = !0, this.visit(t, e, i); s.length;)
                    for (var n, a = s.pop(); n = p.getUnvisitedNode(a.neighbors);) n.visited = !0, this.visit(n, e, i), n.body.type === o.DYNAMIC && s.push(n)
            }, p.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, s = this.equations; i.length;) this.nodePool.release(i.pop());
                for (var n = 0; n !== e.length; n++) {
                    var a = this.nodePool.get();
                    a.body = e[n], i.push(a)
                }
                for (var o = 0; o !== s.length; o++) {
                    var r = s[o],
                        n = e.indexOf(r.bodyA),
                        h = e.indexOf(r.bodyB),
                        l = i[n],
                        h = i[h];
                    l.neighbors.push(h), h.neighbors.push(l), l.equations.push(r), h.equations.push(r)
                }
                for (var c, u = this.islands, n = 0; n < u.length; n++) this.islandPool.release(u[n]);
                for (u.length = 0; c = p.getUnvisitedNode(i);) {
                    var d = this.islandPool.get();
                    this.bfs(c, d.bodies, d.equations), u.push(d)
                }
                return u
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(t, e, i) {
            function s(t) {
                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
            }(e.exports = s).prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
            }
        }, {}],
        61: [function(t, e, i) {
            function H(t) {
                n.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new s, this.narrowphase = new l(this), this.islandManager = new u, this.gravity = V.fromValues(0, -9.78), t.gravity && V.copy(this.gravity, t.gravity), this.frictionGravity = V.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new h, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new a, this.defaultContactMaterial = new o(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = H.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new c
            }
            var s = t("../solver/GSSolver"),
                V = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                y = t("../shapes/Circle"),
                b = t("../shapes/Convex"),
                v = (t("../shapes/Line"), t("../shapes/Plane")),
                _ = t("../shapes/Capsule"),
                x = t("../shapes/Particle"),
                n = t("../events/EventEmitter"),
                Y = t("../objects/Body"),
                a = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                o = t("../material/ContactMaterial"),
                r = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                h = t("../collision/SAPBroadphase"),
                l = t("../collision/Narrowphase"),
                q = t("../utils/Utils"),
                c = t("../utils/OverlapKeeper"),
                u = t("./IslandManager");
            t("../objects/RotationalSpring");
            (((e.exports = H).prototype = new Object(n.prototype)).constructor = H).NO_SLEEPING = 1, H.BODY_SLEEPING = 2, H.ISLAND_SLEEPING = 4, H.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            }, H.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            }, H.prototype.removeContactMaterial = function(t) {
                t = this.contactMaterials.indexOf(t); - 1 !== t && q.splice(this.contactMaterials, t, 1)
            }, H.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials, s = 0, n = i.length; s !== n; s++) {
                    var a = i[s];
                    if (a.materialA.id === t.id && a.materialB.id === e.id || a.materialA.id === e.id && a.materialB.id === t.id) return a
                }
                return !1
            }, H.prototype.removeConstraint = function(t) {
                t = this.constraints.indexOf(t); - 1 !== t && q.splice(this.constraints, t, 1)
            };
            V.create(), V.create(), V.create(), V.create(), V.create(), V.create();
            var z = V.create(),
                g = V.fromValues(0, 0),
                m = V.fromValues(0, 0);
            V.fromValues(0, 0), V.fromValues(0, 0);
            H.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t), this.time += t, this.accumulator -= t, s++;
                    for (var n = this.accumulator % t / t, a = 0; a !== this.bodies.length; a++) {
                        var o = this.bodies[a];
                        V.lerp(o.interpolatedPosition, o.previousPosition, o.position, n), o.interpolatedAngle = o.previousAngle + n * (o.angle - o.previousAngle)
                    }
                }
            };
            var K = [];
            H.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e, i = this.springs.length,
                    s = this.springs,
                    n = this.bodies,
                    a = this.gravity,
                    o = this.solver,
                    r = this.bodies.length,
                    h = this.broadphase,
                    l = this.narrowphase,
                    c = this.constraints,
                    u = z,
                    d = (V.scale, V.add),
                    p = (V.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity && (0 === (e = V.length(this.gravity)) && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = e)), this.applyGravity)
                    for (var f = 0; f !== r; f++) {
                        var g, m = (g = n[f]).force;
                        g.type === Y.DYNAMIC && g.sleepState !== Y.SLEEPING && (V.scale(u, a, g.mass * g.gravityScale), d(m, m, u))
                    }
                if (this.applySpringForces)
                    for (f = 0; f !== i; f++) s[f].applyForce();
                if (this.applyDamping)
                    for (f = 0; f !== r; f++)(g = n[f]).type === Y.DYNAMIC && g.applyDamping(t);
                for (var y = h.getCollisionPairs(this), b = this.disabledBodyCollisionPairs, f = b.length - 2; 0 <= f; f -= 2)
                    for (var v = y.length - 2; 0 <= v; v -= 2)(b[f] === y[v] && b[f + 1] === y[v + 1] || b[f + 1] === y[v] && b[f] === y[v + 1]) && y.splice(v, 2);
                var _ = c.length;
                for (f = 0; f !== _; f++) {
                    var x = c[f];
                    if (!x.collideConnected)
                        for (v = y.length - 2; 0 <= v; v -= 2)(x.bodyA === y[v] && x.bodyB === y[v + 1] || x.bodyB === y[v] && x.bodyA === y[v + 1]) && y.splice(v, 2)
                }
                this.postBroadphaseEvent.pairs = y, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, l.reset(this);
                for (var f = 0, w = y.length; f !== w; f += 2)
                    for (var P = y[f], T = y[f + 1], S = 0, C = P.shapes.length; S !== C; S++)
                        for (var A = P.shapes[S], E = A.position, I = A.angle, B = 0, M = T.shapes.length; B !== M; B++) {
                            var k, O = T.shapes[B],
                                D = O.position,
                                L = O.angle,
                                R = this.defaultContactMaterial;
                            A.material && O.material && ((k = this.getContactMaterial(A.material, O.material)) && (R = k)), this.runNarrowphase(l, P, A, E, I, T, O, D, L, R, this.frictionGravity)
                        }
                for (f = 0; f !== r; f++)(N = n[f])._wakeUpAfterNarrowphase && (N.wakeUp(), N._wakeUpAfterNarrowphase = !1);
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(K);
                    for (var F = this.endContactEvent, B = K.length; B--;) {
                        var G = K[B];
                        F.shapeA = G.shapeA, F.shapeB = G.shapeB, F.bodyA = G.bodyA, F.bodyB = G.bodyB, this.emit(F)
                    }
                    K.length = 0
                }
                h = this.preSolveEvent;
                h.contactEquations = l.contactEquations, h.frictionEquations = l.frictionEquations, this.emit(h), h.contactEquations = h.frictionEquations = null;
                _ = c.length;
                for (f = 0; f !== _; f++) c[f].update();
                if (l.contactEquations.length || l.frictionEquations.length || _)
                    if (this.islandSplit) {
                        for (p.equations.length = 0, q.appendArray(p.equations, l.contactEquations), q.appendArray(p.equations, l.frictionEquations), f = 0; f !== _; f++) q.appendArray(p.equations, c[f].equations);
                        p.split(this);
                        for (f = 0; f !== p.islands.length; f++)(X = p.islands[f]).equations.length && o.solveIsland(t, X)
                    } else {
                        for (o.addEquations(l.contactEquations), o.addEquations(l.frictionEquations), f = 0; f !== _; f++) o.addEquations(c[f].equations);
                        this.solveConstraints && o.solve(t, this), o.removeAllEquations()
                    }
                for (var N, f = 0; f !== r; f++)(N = n[f]).integrate(t);
                for (f = 0; f !== r; f++) n[f].setZeroForce();
                if (this.emitImpactEvent && this.has("impact"))
                    for (var U = this.impactEvent, f = 0; f !== l.contactEquations.length; f++) {
                        var j = l.contactEquations[f];
                        j.firstImpact && (U.bodyA = j.bodyA, U.bodyB = j.bodyB, U.shapeA = j.shapeA, U.shapeB = j.shapeB, U.contactEquation = j, this.emit(U))
                    }
                if (this.sleepMode === H.BODY_SLEEPING)
                    for (f = 0; f !== r; f++) n[f].sleepTick(this.time, !1, t);
                else if (this.sleepMode === H.ISLAND_SLEEPING && this.islandSplit) {
                    for (f = 0; f !== r; f++) n[f].sleepTick(this.time, !0, t);
                    for (var X, f = 0; f < this.islandManager.islands.length; f++)(X = this.islandManager.islands[f]).wantsToSleep() && X.sleep()
                }
                this.stepping = !1;
                for (var W = this.bodiesToBeRemoved, f = 0; f !== W.length; f++) this.removeBody(W[f]);
                W.length = 0, this.emit(this.postStepEvent)
            }, H.prototype.runNarrowphase = function(t, e, i, s, n, a, o, r, h, l, c) {
                if (0 != (i.collisionGroup & o.collisionMask) && 0 != (o.collisionGroup & i.collisionMask)) {
                    V.rotate(g, s, e.angle), V.rotate(m, r, a.angle), V.add(g, g, e.position), V.add(m, m, a.position);
                    s = n + e.angle, r = h + a.angle;
                    t.enableFriction = 0 < l.friction, t.frictionCoefficient = l.friction, n = e.type === Y.STATIC || e.type === Y.KINEMATIC ? a.mass : a.type === Y.STATIC || a.type === Y.KINEMATIC ? e.mass : e.mass * a.mass / (e.mass + a.mass), t.slipForce = l.friction * c * n, t.restitution = l.restitution, t.surfaceVelocity = l.surfaceVelocity, t.frictionStiffness = l.frictionStiffness, t.frictionRelaxation = l.frictionRelaxation, t.stiffness = l.stiffness, t.relaxation = l.relaxation, t.contactSkinSize = l.contactSkinSize, t.enabledEquations = e.collisionResponse && a.collisionResponse && i.collisionResponse && o.collisionResponse;
                    h = t[i.type | o.type], c = 0;
                    if (h) {
                        var n = i.sensor || o.sensor,
                            l = t.frictionEquations.length,
                            c = i.type < o.type ? h.call(t, e, i, g, s, a, o, m, r, n) : h.call(t, a, o, m, r, e, i, g, s, n),
                            u = t.frictionEquations.length - l;
                        if (c) {
                            if (e.allowSleep && e.type === Y.DYNAMIC && e.sleepState === Y.SLEEPING && a.sleepState === Y.AWAKE && a.type !== Y.STATIC && V.squaredLength(a.velocity) + Math.pow(a.angularVelocity, 2) >= 2 * Math.pow(a.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0), a.allowSleep && a.type === Y.DYNAMIC && a.sleepState === Y.SLEEPING && e.sleepState === Y.AWAKE && e.type !== Y.STATIC && V.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (a._wakeUpAfterNarrowphase = !0), this.overlapKeeper.setOverlapping(e, i, a, o), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, o)) {
                                var d = this.beginContactEvent;
                                if (d.shapeA = i, d.shapeB = o, d.bodyA = e, d.bodyB = a, d.contactEquations.length = 0, "number" == typeof c)
                                    for (var p = t.contactEquations.length - c; p < t.contactEquations.length; p++) d.contactEquations.push(t.contactEquations[p]);
                                this.emit(d)
                            }
                            if ("number" == typeof c && 1 < u)
                                for (p = t.frictionEquations.length - u; p < t.frictionEquations.length; p++) {
                                    var f = t.frictionEquations[p];
                                    f.setSlipForce(f.getSlipForce() / u)
                                }
                        }
                    }
                }
            }, H.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, H.prototype.removeSpring = function(t) {
                t = this.springs.indexOf(t); - 1 !== t && q.splice(this.springs, t, 1)
            }, H.prototype.addBody = function(t) {
                var e; - 1 === this.bodies.indexOf(t) && (this.bodies.push(t), (e = (t.world = this).addBodyEvent).body = t, this.emit(e), e.body = null)
            }, H.prototype.removeBody = function(t) {
                var e;
                this.stepping ? this.bodiesToBeRemoved.push(t) : (t.world = null, -1 !== (e = this.bodies.indexOf(t)) && (q.splice(this.bodies, e, 1), (this.removeBodyEvent.body = t).resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null))
            }, H.prototype.getBodyById = function(t) {
                for (var e = this.bodies, i = 0; i < e.length; i++) {
                    var s = e[i];
                    if (s.id === t) return s
                }
                return !1
            }, H.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            }, H.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                    if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
            }, H.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; 0 <= e; e--) this.removeConstraint(t[e]);
                for (var i = this.bodies, e = i.length - 1; 0 <= e; e--) this.removeBody(i[e]);
                for (var s = this.springs, e = s.length - 1; 0 <= e; e--) this.removeSpring(s[e]);
                for (var n = this.contactMaterials, e = n.length - 1; 0 <= e; e--) this.removeContactMaterial(n[e]);
                H.apply(this)
            };
            var w = V.create(),
                P = (V.fromValues(0, 0), V.fromValues(0, 0));
            H.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var s = new Y({
                        position: t
                    }),
                    n = new x,
                    a = t,
                    o = w,
                    r = P;
                s.addShape(n);
                for (var h = this.narrowphase, l = [], c = 0, u = e.length; c !== u; c++)
                    for (var d = e[c], p = 0, f = d.shapes.length; p !== f; p++) {
                        var g = d.shapes[p];
                        V.rotate(o, g.position, d.angle), V.add(o, o, d.position);
                        var m = g.angle + d.angle;
                        (g instanceof y && h.circleParticle(d, g, o, m, s, n, a, 0, !0) || g instanceof b && h.particleConvex(s, n, a, 0, d, g, o, m, !0) || g instanceof v && h.particlePlane(s, n, a, 0, d, g, o, m, !0) || g instanceof _ && h.particleCapsule(s, n, a, 0, d, g, o, m, !0) || g instanceof x && V.squaredLength(V.sub(r, o, t)) < i * i) && l.push(d)
                    }
                return l
            }, H.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var s = e[i], n = 0; n !== s.equations.length; n++) {
                        var a = s.equations[n];
                        a.stiffness = t, a.needsUpdate = !0
                    }
                for (var o = this.contactMaterials, i = 0; i !== o.length; i++)(s = o[i]).stiffness = s.frictionStiffness = t;
                (s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
            }, H.prototype.setGlobalRelaxation = function(t) {
                for (var e = 0; e !== this.constraints.length; e++)
                    for (var i = this.constraints[e], s = 0; s !== i.equations.length; s++) {
                        var n = i.equations[s];
                        n.relaxation = t, n.needsUpdate = !0
                    }
                for (e = 0; e !== this.contactMaterials.length; e++)(i = this.contactMaterials[e]).relaxation = i.frictionRelaxation = t;
                (i = this.defaultContactMaterial).relaxation = i.frictionRelaxation = t
            };
            var d = new r,
                p = [];
            H.prototype.raycast = function(t, e) {
                return e.getAABB(d), this.broadphase.aabbQuery(this, d, p), e.intersectBodies(t, p), p.length = 0, t.hasHit()
            }
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}, function(t, e, i) {
    (function() {
        var C = C || {};
        return C.game = null, C.WEBGL_RENDERER = 0, C.CANVAS_RENDERER = 1, C.VERSION = "v2.2.9", C._UID = 0, "undefined" != typeof Float32Array ? (C.Float32Array = Float32Array, C.Uint16Array = Uint16Array, C.Uint32Array = Uint32Array, C.ArrayBuffer = ArrayBuffer) : (C.Float32Array = Array, C.Uint16Array = Array), C.PI_2 = 2 * Math.PI, C.RAD_TO_DEG = 180 / Math.PI, C.DEG_TO_RAD = Math.PI / 180, C.RETINA_PREFIX = "@2x", C.DisplayObject = function() {
            this.position = new C.Point(0, 0), this.scale = new C.Point(1, 1), this.pivot = new C.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new C.Matrix, this.worldPosition = new C.Point(0, 0), this.worldScale = new C.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new C.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, C.DisplayObject.prototype.constructor = C.DisplayObject, C.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--;) this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game) return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i, s, n, a, o, r = e.worldTransform,
                    h = this.worldTransform;
                return this.rotation % C.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, t = -this._sr * this.scale.y, n = this._cr * this.scale.y, a = this.position.x, o = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * i + this.pivot.y * t, o -= this.pivot.x * s + this.pivot.y * n), h.a = i * r.a + s * r.c, h.b = i * r.b + s * r.d, h.c = t * r.a + n * r.c, h.d = t * r.b + n * r.d) : (i = this.scale.x, n = this.scale.y, a = this.position.x - this.pivot.x * i, o = this.position.y - this.pivot.y * n, h.a = i * r.a, h.b = i * r.b, h.c = n * r.c, h.d = n * r.d), h.tx = a * r.a + o * r.c + r.tx, h.ty = a * r.b + o * r.d + r.ty, this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.set(h.tx, h.ty), this.worldScale.set(this.scale.x * Math.sqrt(h.a * h.a + h.c * h.c), this.scale.y * Math.sqrt(h.b * h.b + h.d * h.d)), this.worldRotation = Math.atan2(-h.c, h.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, h, r), this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, i) {
                var s = this.getLocalBounds(),
                    t = new C.RenderTexture(0 | s.width, 0 | s.height, i, e, t);
                return C.DisplayObject._tempMatrix.tx = -s.x, C.DisplayObject._tempMatrix.ty = -s.y, t.render(this, C.DisplayObject._tempMatrix), t
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, (t.gl ? C.Sprite.prototype._renderWebGL : C.Sprite.prototype._renderCanvas).call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite ? this._cachedSprite.texture.resize(t.width, t.height) : (e = new C.RenderTexture(t.width, t.height), this._cachedSprite = new C.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform);
                var e = this._filters;
                this._filters = null, this._cachedSprite.filters = e, C.DisplayObject._tempMatrix.tx = -t.x, C.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, C.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = e, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            }
        }, C.DisplayObject.prototype.displayObjectUpdateTransform = C.DisplayObject.prototype.updateTransform, Object.defineProperties(C.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t) return this.visible;
                        do {
                            if (!t.visible) return !1
                        } while (t = t.parent);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1), (this._mask = t) && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)
                            for (var s = t[i].passes, n = 0; n < s.length; n++) e.push(s[n]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t, this.blendMode && this.blendMode === C.blendModes.MULTIPLY && (this.blendMode = C.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), C.DisplayObjectContainer = function() {
            C.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, C.DisplayObjectContainer.prototype = Object.create(C.DisplayObject.prototype), C.DisplayObjectContainer.prototype.constructor = C.DisplayObjectContainer, C.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, C.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (0 <= e && e <= this.children.length) return t.parent && t.parent.removeChild(t), (t.parent = this).children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, C.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t),
                    s = this.getChildIndex(e);
                if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[s] = t
            }
        }, C.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            t = this.children.indexOf(t);
            if (-1 === t) throw new Error("The supplied DisplayObject must be a child of the caller");
            return t
        }, C.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, C.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, C.DisplayObjectContainer.prototype.removeChild = function(t) {
            t = this.children.indexOf(t);
            if (-1 !== t) return this.removeChildAt(t)
        }, C.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, C.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            t = e - t;
            if (0 < t && t <= e) {
                for (var i = this.children.splice(begin, t), s = 0; s < i.length; s++) i[s].parent = void 0;
                return i
            }
            if (0 == t && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, C.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, C.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = C.DisplayObjectContainer.prototype.updateTransform, C.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e = t && t instanceof C.DisplayObject,
                i = !0;
            if (e ? i = t instanceof C.DisplayObjectContainer && t.contains(this) : t = this, e) {
                var s = t.worldTransform;
                for (t.worldTransform = C.identityMatrix, u = 0; u < t.children.length; u++) t.children[u].updateTransform()
            }
            for (var n, a, o = 1 / 0, r = 1 / 0, h = -1 / 0, l = -1 / 0, c = !1, u = 0; u < this.children.length; u++) this.children[u].visible && (c = !0, o = o < (a = this.children[u].getBounds()).x ? o : a.x, r = r < a.y ? r : a.y, h = (n = a.width + a.x) < h ? h : n, l = (a = a.height + a.y) < l ? l : a);
            var d, p, f, g, m, y, b, v, _, x, w, P, T, S = this._bounds;
            if (c || (_ = (S = new C.Rectangle).x, d = S.width + S.x, w = S.y, p = S.height + S.y, f = (T = this.worldTransform).a, g = T.b, y = T.c, m = T.d, o = (P = f * d + y * w + (b = T.tx)) < (o = (x = f * _ + y * w + b) < (o = (v = f * _ + y * p + b) < (o = y = f * d + y * p + b) ? v : o) ? x : o) ? P : o, r = (T = m * w + g * d + (b = T.ty)) < (r = (w = m * w + g * _ + b) < (r = (_ = m * p + g * _ + b) < (r = b = m * p + g * d + b) ? _ : r) ? w : r) ? T : r, h = (h = (h = (h = y) < v ? v : h) < x ? x : h) < P ? P : h, l = (l = (l = (l = b) < _ ? _ : l) < w ? w : l) < T ? T : l), S.x = o, S.y = r, S.width = h - o, S.height = l - r, e)
                for (t.worldTransform = s, u = 0; u < t.children.length; u++) t.children[u].updateTransform();
            return i || (i = t.getBounds(), S.x -= i.x, S.y -= i.y), S
        }, C.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, C.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, C.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            var e;
            if (this.visible && !(this.alpha <= 0))
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else if (this._mask || this._filters) {
                for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
            } else
                for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
        }, C.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha)
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else {
                    this._mask && t.maskManager.pushMask(this._mask, t);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
        }, Object.defineProperty(C.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1, this._width = t
            }
        }), Object.defineProperty(C.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1, this._height = t
            }
        }), C.Sprite = function(t) {
            C.DisplayObjectContainer.call(this), this.anchor = new C.Point, this.texture = t || C.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = C.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, C.Sprite.prototype = Object.create(C.DisplayObjectContainer.prototype), C.Sprite.prototype.constructor = C.Sprite, Object.defineProperty(C.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(C.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), C.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, C.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, C.Sprite.prototype.getBounds = function(t) {
            var e, i = this.texture.frame.width,
                s = this.texture.frame.height,
                n = i * (1 - this.anchor.x),
                a = i * -this.anchor.x,
                o = s * (1 - this.anchor.y),
                r = s * -this.anchor.y,
                h = t || this.worldTransform,
                l = h.a,
                c = h.b,
                u = h.c,
                d = h.d,
                p = h.tx,
                f = h.ty,
                g = -1 / 0,
                m = -1 / 0,
                i = 1 / 0,
                s = 1 / 0,
                m = 0 === c && 0 === u ? (l < 0 && (l *= -1, e = n, n = -a, a = -e), d < 0 && (d *= -1, e = o, o = -r, r = -e), i = l * a + p, g = l * n + p, s = d * r + f, d * o + f) : (i = (t = l * a + u * o + p) < (i = (h = l * n + u * o + p) < (i = (e = l * n + u * r + p) < (i = (p = l * a + u * r + p) < i ? p : i) ? e : i) ? h : i) ? t : i, s = (y = d * o + c * a + f) < (s = (o = d * o + c * n + f) < (s = (n = d * r + c * n + f) < (s = (f = d * r + c * a + f) < s ? f : s) ? n : s) ? o : s) ? y : s, g = (g = (g = (g = g < p ? p : g) < e ? e : g) < h ? h : g) < t ? t : g, (m = (m = (m = m < f ? f : m) < n ? n : m) < o ? o : m) < y ? y : m),
                y = this._bounds;
            return y.x = i, y.width = g - i, y.y = s, y.height = m - s, this._currentBounds = y
        }, C.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = C.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, C.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e), this._mask || this._filters) {
                    e = t.spriteBatch;
                    this._filters && (e.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (e.stop(), t.maskManager.pushMask(this.mask, t), e.start()), e.render(this);
                    for (var s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t);
                    e.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), e.start()
                } else {
                    t.spriteBatch.render(this);
                    for (s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t, i)
                }
            }
        }, C.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var i, s, n, a, o, r = this.worldTransform;
                e && (r = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = C.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid && (i = this.texture.baseTexture.resolution / t.resolution, t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === C.scaleModes.LINEAR), s = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width, n = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height, a = r.tx * t.resolution + t.shakeX, o = r.ty * t.resolution + t.shakeY, t.roundPixels ? (t.context.setTransform(r.a, r.b, r.c, r.d, 0 | a, 0 | o), s |= 0, n |= 0) : t.context.setTransform(r.a, r.b, r.c, r.d, a, o), e = this.texture.crop.width, r = this.texture.crop.height, s /= i, n /= i, 16777215 !== this.tint ? (!this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = C.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, e, r, s, n, e / i, r / i)) : (a = this.texture.crop.x, o = this.texture.crop.y, t.context.drawImage(this.texture.baseTexture.source, a, o, e, r, s, n, e / i, r / i)));
                for (var h = 0; h < this.children.length; h++) this.children[h]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, C.SpriteBatch = function(t) {
            C.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
        }, C.SpriteBatch.prototype = Object.create(C.DisplayObjectContainer.prototype), C.SpriteBatch.prototype.constructor = C.SpriteBatch, C.SpriteBatch.prototype.initWebGL = function(t) {
            this.fastSpriteBatch = new C.WebGLFastSpriteBatch(t), this.ready = !0
        }, C.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }, C.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
        }, C.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                    var a, o, r, h, l, c = this.children[n];
                    c.visible && (o = (a = c.texture).frame, e.globalAlpha = this.worldAlpha * c.alpha, c.rotation % (2 * Math.PI) == 0 ? (s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, c.anchor.x * (-o.width * c.scale.x) + c.position.x + .5 + t.shakeX | 0, c.anchor.y * (-o.height * c.scale.y) + c.position.y + .5 + t.shakeY | 0, o.width * c.scale.x, o.height * c.scale.y)) : (s = s || !0, c.displayObjectUpdateTransform(), h = (r = c.worldTransform).tx * t.resolution + t.shakeX, l = r.ty * t.resolution + t.shakeY, t.roundPixels ? e.setTransform(r.a, r.b, r.c, r.d, 0 | h, 0 | l) : e.setTransform(r.a, r.b, r.c, r.d, h, l), e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, c.anchor.x * -o.width + .5 | 0, c.anchor.y * -o.height + .5 | 0, o.width, o.height)))
                }
            }
        }, C.hex2rgb = function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        }, C.rgb2hex = function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        }, C.canUseNewCanvasBlendModes = function() {
            if (void 0 === document) return !1;
            var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                i = new Image;
            i.src = t + "AP804Oa6" + e;
            var s = new Image;
            s.crossOrigin = "Anonymous", s.src = t + "/wCKxvRF" + e;
            e = C.CanvasPool.create(this, 6, 1).getContext("2d");
            if (e.globalCompositeOperation = "multiply", e.drawImage(i, 0, 0), e.drawImage(s, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1;
            e = e.getImageData(2, 0, 1, 1).data;
            return C.CanvasPool.remove(this), 255 === e[0] && 0 === e[1] && 0 === e[2]
        }, C.getNextPowerOfTwo = function(t) {
            if (0 < t && 0 == (t & t - 1)) return t;
            for (var e = 1; e < t;) e <<= 1;
            return e
        }, C.isPowerOfTwo = function(t, e) {
            return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
        }, C.CanvasPool = {
            create: function(t, e, i) {
                var s, n = C.CanvasPool.getFirst(),
                    n = -1 === n ? (s = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    }, C.CanvasPool.pool.push(s), s.canvas) : (C.CanvasPool.pool[n].parent = t, C.CanvasPool.pool[n].canvas);
                return void 0 !== e && (n.width = e, n.height = i), n
            },
            getFirst: function() {
                for (var t = C.CanvasPool.pool, e = 0; e < t.length; e++)
                    if (!t[e].parent) return e;
                return -1
            },
            remove: function(t) {
                for (var e = C.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var e = C.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = C.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++;
                return e
            },
            getFree: function() {
                for (var t = C.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++;
                return e
            }
        }, C.CanvasPool.pool = [], C.initDefaultShaders = function() {}, C.CompileVertexShader = function(t, e) {
            return C._CompileShader(t, e, t.VERTEX_SHADER)
        }, C.CompileFragmentShader = function(t, e) {
            return C._CompileShader(t, e, t.FRAGMENT_SHADER)
        }, C._CompileShader = function(t, e, i) {
            var s = e;
            Array.isArray(e) && (s = e.join("\n"));
            i = t.createShader(i);
            return t.shaderSource(i, s), t.compileShader(i), t.getShaderParameter(i, t.COMPILE_STATUS) ? i : (window.console.log(t.getShaderInfoLog(i)), null)
        }, C.compileProgram = function(t, e, i) {
            var s = C.CompileFragmentShader(t, i),
                i = C.CompileVertexShader(t, e),
                e = t.createProgram();
            return t.attachShader(e, i), t.attachShader(e, s), t.linkProgram(e), t.getProgramParameter(e, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(e)), window.console.log("Could not initialise shaders")), e
        }, C.PixiShader = function(t) {
            this._UID = C._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, C.PixiShader.prototype.constructor = C.PixiShader, C.PixiShader.prototype.init = function() {
            var t, e = this.gl,
                i = C.compileProgram(e, this.vertexSrc || C.PixiShader.defaultVertexSrc, this.fragmentSrc);
            for (t in e.useProgram(i), this.uSampler = e.getUniformLocation(i, "uSampler"), this.projectionVector = e.getUniformLocation(i, "projectionVector"), this.offsetVector = e.getUniformLocation(i, "offsetVector"), this.dimensions = e.getUniformLocation(i, "dimensions"), this.aVertexPosition = e.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = e.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = e.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.uniforms) this.uniforms[t].uniformLocation = e.getUniformLocation(i, t);
            this.initUniforms(), this.program = i
        }, C.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e, i = this.gl;
            for (e in this.uniforms) {
                var s = (t = this.uniforms[e]).type;
                "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = i.uniformMatrix2fv : "mat3" === s ? t.glFunc = i.uniformMatrix3fv : "mat4" === s && (t.glFunc = i.uniformMatrix4fv)) : (t.glFunc = i["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
            }
        }, C.PixiShader.prototype.initSampler2D = function(t) {
            var e, i, s, n, a, o, r, h, l;
            t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded && ((e = this.gl).activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData && (i = (l = t.textureData).magFilter || e.LINEAR, s = l.minFilter || e.LINEAR, n = l.wrapS || e.CLAMP_TO_EDGE, a = l.wrapT || e.CLAMP_TO_EDGE, o = l.luminance ? e.LUMINANCE : e.RGBA, l.repeat && (n = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!l.flipY), l.width ? (r = l.width || 512, h = l.height || 2, l = l.border || 0, e.texImage2D(e.TEXTURE_2D, 0, o, r, h, l, o, e.UNSIGNED_BYTE, null)) : e.texImage2D(e.TEXTURE_2D, 0, o, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)), e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++)
        }, C.PixiShader.prototype.syncUniforms = function() {
            this.textureCount = 1;
            var t, e, i = this.gl;
            for (e in this.uniforms) t = this.uniforms[e], 1 === t.glValueLength ? !0 === t.glMatrix ? t.glFunc.call(i, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(i, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (i.activeTexture(i["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[i.id] ? C.instances[i.id].updateTexture(t.value.baseTexture) : i.bindTexture(i.TEXTURE_2D, t.value.baseTexture._glTextures[i.id]), i.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
        }, C.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, C.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], C.PixiFastShader = function(t) {
            this._UID = C._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, C.PixiFastShader.prototype.constructor = C.PixiFastShader, C.PixiFastShader.prototype.init = function() {
            var t = this.gl,
                e = C.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
        }, C.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, C.StripShader = function(t) {
            this._UID = C._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
        }, C.StripShader.prototype.constructor = C.StripShader, C.StripShader.prototype.init = function() {
            var t = this.gl,
                e = C.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, C.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, C.PrimitiveShader = function(t) {
            this._UID = C._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, C.PrimitiveShader.prototype.constructor = C.PrimitiveShader, C.PrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = C.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, C.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, C.ComplexPrimitiveShader = function(t) {
            this._UID = C._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, C.ComplexPrimitiveShader.prototype.constructor = C.ComplexPrimitiveShader, C.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = C.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, C.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, C.glContexts = [], C.instances = [], C.WebGLRenderer = function(t) {
            this.game = t, C.defaultRenderer || (C.defaultRenderer = this), this.type = C.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            }, this.projection = new C.Point, this.offset = new C.Point, this.shaderManager = new C.WebGLShaderManager, this.spriteBatch = new C.WebGLSpriteBatch, this.maskManager = new C.WebGLMaskManager, this.filterManager = new C.WebGLFilterManager, this.stencilManager = new C.WebGLStencilManager, this.blendModeManager = new C.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, (this.renderSession.renderer = this).renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
        }, C.WebGLRenderer.prototype.constructor = C.WebGLRenderer, C.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (!(this.gl = t)) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = t.id = C.WebGLRenderer.glContextId++, C.glContexts[this.glContextId] = t, C.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
        }, C.WebGLRenderer.prototype.render = function(t) {
            var e;
            this.contextLost || ((e = this.gl).viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection))
        }, C.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, s) {
            this.renderSession.blendModeManager.setBlendMode(C.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, s), this.spriteBatch.end()
        }, C.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, C.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded) return !1;
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === C.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && C.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === C.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === C.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), !(t._dirty[e.id] = !1)
        }, C.WebGLRenderer.prototype.destroy = function() {
            C.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, C.CanvasPool.remove(this), C.instances[this.glContextId] = null, C.WebGLRenderer.glContextId--
        }, C.WebGLRenderer.prototype.mapBlendModes = function() {
            var t, e, i = this.gl;
            C.blendModesWebGL || ((t = [])[(e = C.blendModes).NORMAL] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.ADD] = [i.SRC_ALPHA, i.DST_ALPHA], t[e.MULTIPLY] = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA], t[e.SCREEN] = [i.SRC_ALPHA, i.ONE], t[e.OVERLAY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.DARKEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.LIGHTEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.COLOR_DODGE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.COLOR_BURN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.HARD_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.SOFT_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.DIFFERENCE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.EXCLUSION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.HUE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.SATURATION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.COLOR] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[e.LUMINOSITY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], C.blendModesWebGL = t)
        }, C.WebGLRenderer.glContextId = 0, C.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, C.WebGLBlendModeManager.prototype.constructor = C.WebGLBlendModeManager, C.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }, C.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t) return !1;
            this.currentBlendMode = t;
            t = C.blendModesWebGL[this.currentBlendMode];
            return t && this.gl.blendFunc(t[0], t[1]), !0
        }, C.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, C.WebGLMaskManager = function() {}, C.WebGLMaskManager.prototype.constructor = C.WebGLMaskManager, C.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }, C.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var i = e.gl;
            t.dirty && C.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
        }, C.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }, C.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, C.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, C.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }, C.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var s = this.gl;
            this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
            i = this.count;
            s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - i, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, i, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (i + 1), 255) : s.stencilFunc(s.EQUAL, i + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, i, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - i, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, i + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (i + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
        }, C.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var s, n = this.gl,
                a = i.projection,
                o = i.offset;
            1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, a.x, -a.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, C.hex2rgb(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, a.x, -a.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, C.hex2rgb(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8)), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
        }, C.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var s, n = this.gl;
            this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length ? n.disable(n.STENCIL_TEST) : (s = this.count, this.bindGraphics(t, e, i), n.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (n.stencilFunc(n.EQUAL, 255 - (s + 1), 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, s + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), n.stencilFunc(n.ALWAYS, 0, 255), n.stencilOp(n.KEEP, n.KEEP, n.INVERT), n.drawElements(n.TRIANGLE_FAN, e.indices.length - 4, n.UNSIGNED_SHORT, 0)) : (this.reverse ? (n.stencilFunc(n.EQUAL, s + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)) : (n.stencilFunc(n.EQUAL, 255 - (s + 1), 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)), n.drawElements(n.TRIANGLE_STRIP, e.indices.length, n.UNSIGNED_SHORT, 0)), this.reverse ? n.stencilFunc(n.EQUAL, s, 255) : n.stencilFunc(n.EQUAL, 255 - s, 255), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP))
        }, C.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, C.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
            this.stack = []
        }, C.WebGLShaderManager.prototype.constructor = C.WebGLShaderManager, C.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t, this.primitiveShader = new C.PrimitiveShader(t), this.complexPrimitiveShader = new C.ComplexPrimitiveShader(t), this.defaultShader = new C.PixiShader(t), this.fastShader = new C.PixiFastShader(t), this.stripShader = new C.StripShader(t), this.setShader(this.defaultShader)
        }, C.WebGLShaderManager.prototype.setAttribs = function(t) {
            for (var e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var s = this.gl;
            for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
        }, C.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
        }, C.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
        }, C.WebGLSpriteBatch = function() {
            this.vertSize = 5, this.size = 2e3;
            var t = 4 * this.size * 4 * this.vertSize,
                e = 6 * this.size;
            this.vertices = new C.ArrayBuffer(t), this.positions = new C.Float32Array(this.vertices), this.colors = new C.Uint32Array(this.vertices), this.indices = new C.Uint16Array(e);
            for (var i = this.lastIndexCount = 0, s = 0; i < e; i += 6, s += 4) this.indices[i + 0] = s + 0, this.indices[i + 1] = s + 1, this.indices[i + 2] = s + 2, this.indices[i + 3] = s + 0, this.indices[i + 4] = s + 2, this.indices[i + 5] = s + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new C.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }, C.WebGLSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var e = new C.PixiShader(t);
            e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[t.id] = e
        }, C.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, C.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, C.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture,
                s = t.worldTransform;
            e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
            var n, a, o, r, h, l, c, u, d, p, f = i._uvs;
            f && (u = t.anchor.x, d = t.anchor.y, i.trim ? (a = (n = (c = i.trim).x - u * c.width) + i.crop.width, r = (o = c.y - d * c.height) + i.crop.height) : (a = i.frame.width * (1 - u), n = i.frame.width * -u, r = i.frame.height * (1 - d), o = i.frame.height * -d), h = 4 * this.currentBatchSize * this.vertSize, p = i.baseTexture.resolution, l = s.a / p, e = s.b / p, c = s.c / p, u = s.d / p, d = s.tx, i = s.ty, p = this.colors, s = this.positions, this.renderSession.roundPixels ? (s[h] = l * n + c * o + d | 0, s[1 + h] = u * o + e * n + i | 0, s[5 + h] = l * a + c * o + d | 0, s[6 + h] = u * o + e * a + i | 0, s[10 + h] = l * a + c * r + d | 0, s[11 + h] = u * r + e * a + i | 0, s[15 + h] = l * n + c * r + d | 0, s[16 + h] = u * r + e * n + i | 0) : (s[h] = l * n + c * o + d, s[1 + h] = u * o + e * n + i, s[5 + h] = l * a + c * o + d, s[6 + h] = u * o + e * a + i, s[10 + h] = l * a + c * r + d, s[11 + h] = u * r + e * a + i, s[15 + h] = l * n + c * r + d, s[16 + h] = u * r + e * n + i), s[2 + h] = f.x0, s[3 + h] = f.y0, s[7 + h] = f.x1, s[8 + h] = f.y1, s[12 + h] = f.x2, s[13 + h] = f.y2, s[17 + h] = f.x3, s[18 + h] = f.y3, f = t.tint, p[4 + h] = p[9 + h] = p[14 + h] = p[19 + h] = (f >> 16) + (65280 & f) + ((255 & f) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t)
        }, C.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new C.TextureUvs);
            var i = t._uvs,
                s = e.baseTexture.width,
                n = e.baseTexture.height;
            t.tilePosition.x %= s * t.tileScaleOffset.x, t.tilePosition.y %= n * t.tileScaleOffset.y;
            var a = t.tilePosition.x / (s * t.tileScaleOffset.x),
                o = t.tilePosition.y / (n * t.tileScaleOffset.y),
                r = t.width / s / (t.tileScale.x * t.tileScaleOffset.x),
                h = t.height / n / (t.tileScale.y * t.tileScaleOffset.y);
            i.x0 = 0 - a, i.y0 = 0 - o, i.x1 = r - a, i.y1 = 0 - o, i.x2 = r - a, i.y2 = h - o, i.x3 = 0 - a, i.y3 = h - o;
            var l = t.tint,
                c = (l >> 16) + (65280 & l) + ((255 & l) << 16) + (255 * t.worldAlpha << 24),
                u = this.positions,
                d = this.colors,
                p = t.width,
                f = t.height,
                g = t.anchor.x,
                s = t.anchor.y,
                n = p * (1 - g),
                r = p * -g,
                a = f * (1 - s),
                h = f * -s,
                o = 4 * this.currentBatchSize * this.vertSize,
                l = e.baseTexture.resolution,
                p = t.worldTransform,
                g = p.a / l,
                f = p.b / l,
                s = p.c / l,
                e = p.d / l,
                l = p.tx,
                p = p.ty;
            u[o++] = g * r + s * h + l, u[o++] = e * h + f * r + p, u[o++] = i.x0, u[o++] = i.y0, d[o++] = c, u[o++] = g * n + s * h + l, u[o++] = e * h + f * n + p, u[o++] = i.x1, u[o++] = i.y1, d[o++] = c, u[o++] = g * n + s * a + l, u[o++] = e * a + f * n + p, u[o++] = i.x2, u[o++] = i.y2, d[o++] = c, u[o++] = g * r + s * a + l, u[o++] = e * a + f * r + p, u[o++] = i.x3, u[o++] = i.y3, d[+o] = c, this.sprites[this.currentBatchSize++] = t
        }, C.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, e, i = this.gl;
                this.dirty && (this.dirty = !1, i.activeTexture(i.TEXTURE0), i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[i.id], e = 4 * this.vertSize, i.vertexAttribPointer(t.aVertexPosition, 2, i.FLOAT, !1, e, 0), i.vertexAttribPointer(t.aTextureCoord, 2, i.FLOAT, !1, e, 8), i.vertexAttribPointer(t.colorAttribute, 4, i.UNSIGNED_BYTE, !0, e, 16)), this.currentBatchSize > .5 * this.size ? i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices) : (e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize), i.bufferSubData(i.ARRAY_BUFFER, 0, e));
                for (var s, n, a, o, r, h = 0, l = 0, c = null, u = this.renderSession.blendModeManager.currentBlendMode, d = null, p = 0, f = this.currentBatchSize; p < f; p++) {
                    s = ((r = this.sprites[p]).tilingTexture || r.texture).baseTexture, a = u !== (n = r.blendMode), o = d !== (g = r.shader || this.defaultShader);
                    var g, m = s.skipRender;
                    m && 0 < r.children.length && (m = !1), (c !== s && !m || a || o) && (this.renderBatch(c, h, l), l = p, h = 0, c = s, a && (u = n, this.renderSession.blendModeManager.setBlendMode(u)), o) && ((t = (d = g).shaders[i.id]) || ((t = new C.PixiShader(i)).fragmentSrc = d.fragmentSrc, t.uniforms = d.uniforms, t.init(), d.shaders[i.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms(), g = this.renderSession.projection, i.uniform2f(t.projectionVector, g.x, g.y), g = this.renderSession.offset, i.uniform2f(t.offsetVector, g.x, g.y)), h++
                }
                this.renderBatch(c, h, l), this.currentBatchSize = 0
            }
        }, C.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var s = this.gl;
                if (t._dirty[s.id]) {
                    if (!this.renderSession.renderer.updateTexture(t)) return
                } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
            }
        }, C.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, C.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, C.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, C.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize,
                i = 6 * this.maxSize;
            this.vertices = new C.Float32Array(e), this.indices = new C.Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null;
            for (var s = this.lastIndexCount = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
        }, C.WebGLFastSpriteBatch.prototype.constructor = C.WebGLFastSpriteBatch, C.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }, C.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
        }, C.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, C.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children,
                t = e[0];
            if (t.texture._uvs) {
                this.currentBaseTexture = t.texture.baseTexture, t.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(t.blendMode));
                for (var i = 0, s = e.length; i < s; i++) this.renderSprite(e[i]);
                this.flush()
            }
        }, C.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            var e, i, s, n, a, o, r;
            t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs)) && (e = this.vertices, r = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim ? (n = (s = (i = t.texture.trim).x - t.anchor.x * i.width) + t.texture.crop.width, o = (a = i.y - t.anchor.y * i.height) + t.texture.crop.height) : (n = t.texture.frame.width * (1 - t.anchor.x), s = t.texture.frame.width * -t.anchor.x, o = t.texture.frame.height * (1 - t.anchor.y), a = t.texture.frame.height * -t.anchor.y), i = 4 * this.currentBatchSize * this.vertSize, e[i++] = s, e[i++] = a, e[i++] = t.position.x, e[i++] = t.position.y, e[i++] = t.scale.x, e[i++] = t.scale.y, e[i++] = t.rotation, e[i++] = r.x0, e[i++] = r.y1, e[i++] = t.alpha, e[i++] = n, e[i++] = a, e[i++] = t.position.x, e[i++] = t.position.y, e[i++] = t.scale.x, e[i++] = t.scale.y, e[i++] = t.rotation, e[i++] = r.x1, e[i++] = r.y1, e[i++] = t.alpha, e[i++] = n, e[i++] = o, e[i++] = t.position.x, e[i++] = t.position.y, e[i++] = t.scale.x, e[i++] = t.scale.y, e[i++] = t.rotation, e[i++] = r.x2, e[i++] = r.y2, e[i++] = t.alpha, e[i++] = s, e[i++] = o, e[i++] = t.position.x, e[i++] = t.position.y, e[i++] = t.scale.x, e[i++] = t.scale.y, e[i++] = t.rotation, e[i++] = r.x3, e[i++] = r.y3, e[i++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush())
        }, C.WebGLFastSpriteBatch.prototype.flush = function() {
            var t, e;
            0 !== this.currentBatchSize && (t = this.gl, this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size ? t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices) : (e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize), t.bufferSubData(t.ARRAY_BUFFER, 0, e)), t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++)
        }, C.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, C.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            e = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, e, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, e, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, e, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, e, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, e, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, e, 36)
        }, C.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, C.WebGLFilterManager.prototype.constructor = C.WebGLFilterManager, C.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t, this.texturePool = [], this.initShaderBuffers()
        }, C.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
            t = this.renderSession.projection;
            this.width = 2 * t.x, this.height = 2 * -t.y, this.buffer = e
        }, C.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl,
                i = this.renderSession.projection,
                s = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new C.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
            var n = t.filterPasses[0];
            this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
            var a = this.texturePool.pop();
            a ? a.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : a = new C.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, a.texture);
            var o = t._filterArea,
                n = n.padding;
            o.x -= n, o.y -= n, o.width += 2 * n, o.height += 2 * n, o.x < 0 && (o.x = 0), o.width > this.width && (o.width = this.width), o.y < 0 && (o.y = 0), o.height > this.height && (o.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, a.frameBuffer), e.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution), i.x = o.width / 2, i.y = -o.height / 2, s.x = -o.x, s.y = -o.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = a
        }, C.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl,
                e = this.filterStack.pop(),
                i = e._filterArea,
                s = e._glFilterTexture,
                n = this.renderSession.projection,
                a = this.renderSession.offset;
            if (1 < e.filterPasses.length) {
                t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var o = s;
                (l = (l = this.texturePool.pop()) || new C.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)).resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, l.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                for (var r = 0; r < e.filterPasses.length - 1; r++) {
                    var h = e.filterPasses[r];
                    t.bindFramebuffer(t.FRAMEBUFFER, l.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o.texture), this.applyFilterPass(h, i, i.width, i.height);
                    var h = o,
                        o = l,
                        l = h
                }
                t.enable(t.BLEND), s = o, this.texturePool.push(l)
            }
            var c = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= i.x, this.offsetY -= i.y;
            var u, d = this.width,
                p = this.height,
                f = 0,
                g = 0,
                m = this.buffer;
            0 === this.filterStack.length ? t.colorMask(!0, !0, !0, !0) : (d = (i = (u = this.filterStack[this.filterStack.length - 1])._filterArea).width, p = i.height, f = i.x, g = i.y, m = u._glFilterTexture.frameBuffer), n.x = d / 2, n.y = -p / 2, a.x = f, a.y = g;
            f = (i = e._filterArea).x - f, g = i.y - g;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = f, this.vertexArray[1] = g + i.height, this.vertexArray[2] = f + i.width, this.vertexArray[3] = g + i.height, this.vertexArray[4] = f, this.vertexArray[5] = g, this.vertexArray[6] = f + i.width, this.vertexArray[7] = g, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, d * this.renderSession.resolution, p * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, m), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, 0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(c, i, d, p), this.texturePool.push(s), e._glFilterTexture = null
        }, C.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, s) {
            var n = this.gl,
                a = t.shaders[n.id];
            a || ((a = new C.PixiShader(n)).fragmentSrc = t.fragmentSrc, a.uniforms = t.uniforms, a.init(), t.shaders[n.id] = a), this.renderSession.shaderManager.setShader(a), n.uniform2f(a.projectionVector, i / 2, -s / 2), n.uniform2f(a.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), a.syncUniforms(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.vertexAttribPointer(a.aVertexPosition, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.uvBuffer), n.vertexAttribPointer(a.aTextureCoord, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.colorBuffer), n.vertexAttribPointer(a.colorAttribute, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, C.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new C.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new C.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new C.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }, C.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null, this.offsetX = 0;
            for (var e = this.offsetY = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
            this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
        }, C.FilterTexture = function(t, e, i, s) {
            this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || C.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === C.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === C.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i)
        }, C.FilterTexture.prototype.constructor = C.FilterTexture, C.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
        }, C.FilterTexture.prototype.resize = function(t, e) {
            var i;
            this.width === t && this.height === e || (this.width = t, this.height = e, (i = this.gl).bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e))
        }, C.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, C.CanvasBuffer = function(t, e) {
            this.width = t, this.height = e, this.canvas = C.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
        }, C.CanvasBuffer.prototype.constructor = C.CanvasBuffer, C.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, C.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, C.CanvasBuffer.prototype.destroy = function() {
            C.CanvasPool.remove(this)
        }, C.CanvasMaskManager = function() {}, C.CanvasMaskManager.prototype.constructor = C.CanvasMaskManager, C.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var i = e.context;
            i.save();
            var s = t.alpha,
                n = t.worldTransform,
                e = e.resolution;
            i.setTransform(n.a * e, n.b * e, n.c * e, n.d * e, n.tx * e, n.ty * e), C.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = s
        }, C.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, C.CanvasTinter = function() {}, C.CanvasTinter.getTintedTexture = function(t, e) {
            var i = t.tintedTexture || C.CanvasPool.create(this);
            return C.CanvasTinter.tintMethod(t.texture, e, i), i
        }, C.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var s = i.getContext("2d"),
                n = t.crop;
            i.width === n.width && i.height === n.height || (i.width = n.width, i.height = n.height), s.clearRect(0, 0, n.width, n.height), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
        }, C.CanvasTinter.tintWithPerPixel = function(t, e, i) {
            var s = i.getContext("2d"),
                n = t.crop;
            i.width = n.width, i.height = n.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height);
            for (var a, e = C.hex2rgb(e), o = e[0], r = e[1], h = e[2], n = s.getImageData(0, 0, n.width, n.height), l = n.data, c = 0; c < l.length; c += 4) l[c + 0] *= o, l[c + 1] *= r, l[c + 2] *= h, C.CanvasTinter.canHandleAlpha || (a = l[c + 3], l[c + 0] /= 255 / a, l[c + 1] /= 255 / a, l[c + 2] /= 255 / a);
            s.putImageData(n, 0, 0)
        }, C.CanvasTinter.checkInverseAlpha = function() {
            var t = new C.CanvasBuffer(2, 1);
            t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
            var e = t.context.getImageData(0, 0, 1, 1);
            if (null === e) return !1;
            t.context.putImageData(e, 1, 0);
            t = t.context.getImageData(1, 0, 1, 1);
            return t.data[0] === e.data[0] && t.data[1] === e.data[1] && t.data[2] === e.data[2] && t.data[3] === e.data[3]
        }, C.CanvasTinter.canHandleAlpha = C.CanvasTinter.checkInverseAlpha(), C.CanvasTinter.canUseMultiply = C.canUseNewCanvasBlendModes(), C.CanvasTinter.tintMethod = C.CanvasTinter.canUseMultiply ? C.CanvasTinter.tintWithMultiply : C.CanvasTinter.tintWithPerPixel, C.CanvasRenderer = function(t) {
            this.game = t, C.defaultRenderer || (C.defaultRenderer = this), this.type = C.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }), this.refresh = !0, this.count = 0, this.maskManager = new C.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, C.CanvasRenderer.prototype.constructor = C.CanvasRenderer, C.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, C.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, C.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === C.scaleModes.LINEAR)
        }, C.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, C.CanvasRenderer.prototype.mapBlendModes = function() {
            var t, e, i;
            C.blendModesCanvas || (t = [], e = C.blendModes, i = C.canUseNewCanvasBlendModes(), t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", C.blendModesCanvas = t)
        }, C.BaseTexture = function(t, e) {
            this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = e || C.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, C.BaseTexture.prototype.constructor = C.BaseTexture, C.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, C.BaseTexture.prototype.destroy = function() {
            this.source && C.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, C.BaseTexture.prototype.updateSourceImage = function(t) {}, C.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
        }, C.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; 0 <= t; t--) {
                var e = this._glTextures[t],
                    i = C.glContexts[t];
                i && e && i.deleteTexture(e)
            }
            this._glTextures.length = 0, this.dirty()
        }, C.BaseTexture.fromCanvas = function(t, e) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new C.BaseTexture(t, e)
        }, C.TextureSilentFail = !1, C.Texture = function(t, e, i, s) {
            this.noFrame = !1, e || (this.noFrame = !0, e = new C.Rectangle(0, 0, 1, 1)), t instanceof C.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new C.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (e = new C.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
        }, C.Texture.prototype.constructor = C.Texture, C.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new C.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, C.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, C.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
            else {
                if (!C.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                this.valid = !1
            }
        }, C.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new C.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                i = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
        }, C.Texture.fromCanvas = function(t, e) {
            e = C.BaseTexture.fromCanvas(t, e);
            return new C.Texture(e)
        }, C.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, C.RenderTexture = function(t, e, i, s, n) {
            this.width = t || 100, this.height = e || 100, this.resolution = n || 1, this.frame = new C.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new C.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new C.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || C.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, C.Texture.call(this, this.baseTexture, new C.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = i || C.defaultRenderer, this.renderer.type === C.WEBGL_RENDERER ? (i = this.renderer.gl, this.baseTexture._dirty[i.id] = !1, this.textureBuffer = new C.FilterTexture(i, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[i.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new C.Point(.5 * this.width, .5 * -this.height)) : (this.render = this.renderCanvas, this.textureBuffer = new C.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas), this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, C.RenderTexture.prototype = Object.create(C.Texture.prototype), C.RenderTexture.prototype.constructor = C.RenderTexture, C.RenderTexture.prototype.resize = function(t, e, i) {
            t === this.width && e === this.height || (this.valid = 0 < t && 0 < e, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === C.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, C.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === C.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, C.RenderTexture.prototype.renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                s = this.renderer.gl;
                s.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), s.bindFramebuffer(s.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
            }
        }, C.RenderTexture.prototype.renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), e && s.append(e);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                i && this.textureBuffer.clear();
                i = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = i
            }
        }, C.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.crossOrigin = "Anonymous", t.src = this.getBase64(), t
        }, C.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }, C.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type !== C.WEBGL_RENDERER) return this.textureBuffer.canvas;
            var t = this.renderer.gl,
                e = this.textureBuffer.width,
                i = this.textureBuffer.height,
                s = new Uint8Array(4 * e * i);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
            t = new C.CanvasBuffer(e, i), i = t.context.getImageData(0, 0, e, i);
            return i.data.set(s), t.context.putImageData(i, 0, 0), t.canvas
        }, C.AbstractFilter = function(t, e) {
            this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
        }, C.AbstractFilter.prototype.constructor = C.AbstractFilter, C.AbstractFilter.prototype.syncUniforms = function() {
            for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
        }, C.Strip = function(t) {
            C.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new C.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new C.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new C.Float32Array([1, 1, 1, 1]), this.indices = new C.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = C.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = C.Strip.DrawModes.TRIANGLE_STRIP
        }, C.Strip.prototype = Object.create(C.DisplayObjectContainer.prototype), C.Strip.prototype.constructor = C.Strip, C.Strip.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
        }, C.Strip.prototype._initWebGL = function(t) {
            t = t.gl;
            this._vertexBuffer = t.createBuffer(), this._indexBuffer = t.createBuffer(), this._uvBuffer = t.createBuffer(), this._colorBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this._uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvs, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this._colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colors, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW)
        }, C.Strip.prototype._renderStrip = function(t) {
            var e = t.gl,
                i = t.projection,
                s = t.offset,
                n = t.shaderManager.stripShader,
                a = this.drawMode === C.Strip.DrawModes.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode), e.uniformMatrix3fv(n.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(n.projectionVector, i.x, -i.y), e.uniform2f(n.offsetVector, -s.x, -s.y), e.uniform1f(n.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW), e.vertexAttribPointer(n.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(n.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices), e.vertexAttribPointer(n.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(n.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(a, this.indices.length, e.UNSIGNED_SHORT, 0)
        }, C.Strip.prototype._renderCanvas = function(t) {
            var e = t.context,
                i = this.worldTransform,
                s = i.tx * t.resolution + t.shakeX,
                n = i.ty * t.resolution + t.shakeY;
            t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | s, 0 | n) : e.setTransform(i.a, i.b, i.c, i.d, s, n), this.drawMode === C.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
        }, C.Strip.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = e.length / 2;
            this.count++;
            for (var n = 0; n < s - 2; n++) {
                var a = 2 * n;
                this._renderCanvasDrawTriangle(t, e, i, a, 2 + a, 4 + a)
            }
        }, C.Strip.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = this.indices,
                n = s.length;
            this.count++;
            for (var a = 0; a < n; a += 3) {
                var o = 2 * s[a],
                    r = 2 * s[a + 1],
                    h = 2 * s[a + 2];
                this._renderCanvasDrawTriangle(t, e, i, o, r, h)
            }
        }, C.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, a) {
            var o = this.texture.baseTexture.source,
                r = this.texture.width,
                h = this.texture.height,
                l = e[s],
                c = e[n],
                u = e[a],
                d = e[s + 1],
                p = e[n + 1],
                f = e[a + 1],
                g = i[s] * r,
                m = i[n] * r,
                y = i[a] * r,
                e = i[s + 1] * h,
                r = i[n + 1] * h,
                s = i[a + 1] * h;
            0 < this.canvasPadding && (n = this.canvasPadding / this.worldTransform.a, _ = this.canvasPadding / this.worldTransform.d, b = d - (i = (d + p + f) / 3), l = (a = (l + c + u) / 3) + (h = l - a) / (v = Math.sqrt(h * h + b * b)) * (v + n), d = i + b / v * (v + _), b = p - i, c = a + (h = c - a) / (v = Math.sqrt(h * h + b * b)) * (v + n), p = i + b / v * (v + _), b = f - i, u = a + (h = u - a) / (v = Math.sqrt(h * h + b * b)) * (v + n), f = i + b / v * (v + _)), t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
            var b = g * r + e * y + m * s - r * y - e * m - g * s,
                v = l * r + e * u + c * s - r * u - e * c - l * s,
                _ = g * c + l * y + m * u - c * y - l * m - g * u,
                l = g * r * u + e * c * y + l * m * s - l * r * y - e * m * u - g * c * s,
                u = d * r + e * f + p * s - r * f - e * p - d * s,
                c = g * p + d * y + m * f - p * y - d * m - g * f,
                s = g * r * f + e * p * y + d * m * s - d * r * y - e * m * f - g * p * s;
            t.transform(v / b, u / b, _ / b, c / b, l / b, s / b), t.drawImage(o, 0, 0), t.restore()
        }, C.Strip.prototype.renderStripFlat = function(t) {
            var e = this.context,
                i = t.vertices,
                s = i.length / 2;
            this.count++, e.beginPath();
            for (var n = 1; n < s - 2; n++) {
                var a = 2 * n,
                    o = i[a],
                    r = i[2 + a],
                    h = i[4 + a],
                    l = i[1 + a],
                    c = i[3 + a],
                    a = i[5 + a];
                e.moveTo(o, l), e.lineTo(r, c), e.lineTo(h, a)
            }
            e.fillStyle = "#FF0000", e.fill(), e.closePath()
        }, C.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        }, C.Strip.prototype.getBounds = function(t) {
            for (var t = t || this.worldTransform, e = t.a, i = t.b, s = t.c, n = t.d, a = t.tx, o = t.ty, r = -1 / 0, h = -1 / 0, l = 1 / 0, c = 1 / 0, u = this.vertices, d = 0, p = u.length; d < p; d += 2) var f = u[d],
                g = u[d + 1],
                m = e * f + s * g + a,
                f = n * g + i * f + o,
                l = m < l ? m : l,
                c = f < c ? f : c,
                r = r < m ? m : r,
                h = h < f ? f : h;
            if (l === -1 / 0 || h === 1 / 0) return C.EmptyRectangle;
            t = this._bounds;
            return t.x = l, t.width = r - l, t.y = c, t.height = h - c, this._currentBounds = t
        }, C.Strip.DrawModes = {
            TRIANGLE_STRIP: 0,
            TRIANGLES: 1
        }, C.Rope = function(t, e) {
            C.Strip.call(this, t), this.points = e, this.vertices = new C.Float32Array(4 * e.length), this.uvs = new C.Float32Array(4 * e.length), this.colors = new C.Float32Array(2 * e.length), this.indices = new C.Uint16Array(2 * e.length), this.refresh()
        }, C.Rope.prototype = Object.create(C.Strip.prototype), C.Rope.prototype.constructor = C.Rope, C.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs,
                    i = (t[0], this.indices),
                    s = this.colors;
                this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, s[0] = 1, s[1] = 1, i[0] = 0, i[1] = 1;
                for (var n, a, o = t.length, r = 1; r < o; r++) t[r], a = r / (o - 1), e[n = 4 * r] = a, e[1 + n] = 0, e[2 + n] = a, e[3 + n] = 1, s[n = 2 * r] = 1, s[1 + n] = 1, i[n = 2 * r] = n, i[1 + n] = 1 + n, 0
            }
        }, C.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = t[0],
                    i = {
                        x: 0,
                        y: 0
                    };
                this.count -= .2;
                for (var s, n, a, o, r = this.vertices, h = t.length, l = 0; l < h; l++) s = t[l], n = 4 * l, o = l < t.length - 1 ? t[l + 1] : s, i.y = -(o.x - e.x), i.x = o.y - e.y, a = Math.sqrt(i.x * i.x + i.y * i.y), o = this.texture.height / 2, i.x /= a, i.y /= a, i.x *= o, i.y *= o, r[n] = s.x + i.x, r[1 + n] = s.y + i.y, r[2 + n] = s.x - i.x, r[3 + n] = s.y - i.y, e = s;
                C.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, C.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }, C.TilingSprite = function(t, e, i) {
            C.Sprite.call(this, t), this._width = e || 128, this._height = i || 128, this.tileScale = new C.Point(1, 1), this.tileScaleOffset = new C.Point(1, 1), this.tilePosition = new C.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = C.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
        }, C.TilingSprite.prototype = Object.create(C.Sprite.prototype), C.TilingSprite.prototype.constructor = C.TilingSprite, C.TilingSprite.prototype.setTexture = function(t) {
            this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
        }, C.TilingSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
            }
        }, C.TilingSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform,
                    s = t.resolution,
                    n = i.tx * s + t.shakeX,
                    a = i.ty * s + t.shakeY;
                if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, a), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var o = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = C.blendModesCanvas[t.currentBlendMode]);
                var r = this.tilePosition,
                    h = this.tileScale;
                r.x %= this.tilingTexture.baseTexture.width, r.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(r.x + this.anchor.x * -this._width, r.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern;
                n = -r.x, a = -r.y, i = this._width / h.x, s = this._height / h.y;
                t.roundPixels && (n |= 0, a |= 0, i |= 0, s |= 0), e.fillRect(n, a, i, s), e.scale(1 / h.x, 1 / h.y), e.translate(-r.x + this.anchor.x * this._width, -r.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for (var l = 0; l < this.children.length; l++) this.children[l]._renderCanvas(t);
                o !== this.blendMode && (t.currentBlendMode = o, e.globalCompositeOperation = C.blendModesCanvas[o])
            }
        }, C.TilingSprite.prototype.onTextureUpdate = function() {}, C.TilingSprite.prototype.generateTilingTexture = function(t, e) {
            var i, s, n, a, o, r, h;
            this.texture.baseTexture.hasLoaded && (s = (i = this.texture).frame, n = this._frame.sourceSizeW || this._frame.width, a = this._frame.sourceSizeH || this._frame.height, r = o = 0, this._frame.trimmed && (o = this._frame.spriteSourceSizeX, r = this._frame.spriteSourceSizeY), t && (n = C.getNextPowerOfTwo(n), a = C.getNextPowerOfTwo(a)), this.canvasBuffer ? (this.canvasBuffer.resize(n, a), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = a) : (this.canvasBuffer = new C.CanvasBuffer(n, a), this.tilingTexture = C.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0), this.tilingTexture.needsUpdate = !0, this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, a)), h = i.crop.width, t = i.crop.height, h === n && t === a || (h = n, t = a), this.canvasBuffer.context.drawImage(i.baseTexture.source, i.crop.x, i.crop.y, i.crop.width, i.crop.height, o, r, h, t), this.tileScaleOffset.x = s.width / n, this.tileScaleOffset.y = s.height / a, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0)
        }, C.TilingSprite.prototype.getBounds = function() {
            var t = this._width,
                e = this._height,
                i = t * (1 - this.anchor.x),
                s = t * -this.anchor.x,
                n = e * (1 - this.anchor.y),
                a = e * -this.anchor.y,
                o = this.worldTransform,
                r = o.a,
                h = o.b,
                l = o.c,
                c = o.d,
                u = o.tx,
                d = o.ty,
                p = r * s + l * a + u,
                t = c * a + h * s + d,
                e = r * i + l * a + u,
                o = c * a + h * i + d,
                a = r * i + l * n + u,
                i = c * n + h * i + d,
                u = r * s + l * n + u,
                c = c * n + h * s + d,
                n = -1 / 0,
                h = -1 / 0,
                s = 1 / 0,
                d = 1 / 0;
            s = u < (s = a < (s = e < (s = p < s ? p : s) ? e : s) ? a : s) ? u : s, d = c < (d = i < (d = o < (d = t < d ? t : d) ? o : d) ? i : d) ? c : d, n = (n = (n = (n = n < p ? p : n) < e ? e : n) < a ? a : n) < u ? u : n, h = (h = (h = (h = h < t ? t : h) < o ? o : h) < i ? i : h) < c ? c : h;
            c = this._bounds;
            return c.x = s, c.width = n - s, c.y = d, c.height = h - d, this._currentBounds = c
        }, C.TilingSprite.prototype.destroy = function() {
            C.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, Object.defineProperty(C.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }), Object.defineProperty(C.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }), void 0 !== t && t.exports && (e = t.exports = C), e.PIXI = C
    }).call(this)
}, function(h, l, t) {
    (function(r) {
        (function() {
            function s(t, e) {
                this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
            }
            var t, a, e, i, X = X || {
                VERSION: "2.6.4",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {}
            };
            for (e in Math.trunc || (Math.trunc = function(t) {
                    return t < 0 ? Math.ceil(t) : Math.floor(t)
                }), Function.prototype.bind || (Function.prototype.bind = (a = Array.prototype.slice, function(e) {
                    function i() {
                        var t = n.concat(a.call(arguments));
                        s.apply(this instanceof i ? this : e, t)
                    }
                    var s = this,
                        n = a.call(arguments, 1);
                    if ("function" != typeof s) throw new TypeError;
                    return i.prototype = function t(e) {
                        if (e && (t.prototype = e), !(this instanceof t)) return new t
                    }(s.prototype), i
                })), Array.isArray || (Array.isArray = function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                    "use strict";
                    if (null == this) throw new TypeError;
                    var e = Object(this),
                        i = e.length >>> 0;
                    if ("function" != typeof t) throw new TypeError;
                    for (var s = 2 <= arguments.length ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
                }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array && ((t = function(t) {
                    var e = new Array;
                    window[t] = function(t) {
                        if ("number" == typeof t) {
                            Array.call(this, t), this.length = t;
                            for (var e = 0; e < this.length; e++) this[e] = 0
                        } else {
                            Array.call(this, t.length), this.length = t.length;
                            for (e = 0; e < this.length; e++) this[e] = t[e]
                        }
                    }, window[t].prototype = e, window[t].constructor = window[t]
                })("Uint32Array"), t("Int16Array")), window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), /firefox/i.test(navigator.userAgent) && (window.oldGetComputedStyle = window.getComputedStyle, window.getComputedStyle = function(t, e) {
                    e = window.oldGetComputedStyle(t, e);
                    return null === e ? {
                        getPropertyValue: function() {}
                    } : e
                }), X.Utils = {
                    reverseString: function(t) {
                        return t.split("").reverse().join("")
                    },
                    getProperty: function(t, e) {
                        for (var i = e.split("."), e = i.pop(), s = i.length, n = 1, a = i[0]; n < s && (t = t[a]);) a = i[n], n++;
                        return t ? t[e] : null
                    },
                    setProperty: function(t, e, i) {
                        for (var s = e.split("."), e = s.pop(), n = s.length, a = 1, o = s[0]; a < n && (t = t[o]);) o = s[a], a++;
                        return t && (t[e] = i), t
                    },
                    chanceRoll: function(t) {
                        return void 0 === t && (t = 50), 0 < t && 100 * Math.random() <= t
                    },
                    randomChoice: function(t, e) {
                        return Math.random() < .5 ? t : e
                    },
                    parseDimension: function(t, e) {
                        var i;
                        return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, 0 === e ? window.innerWidth * i : window.innerHeight * i) : parseInt(t, 10) : t
                    },
                    pad: function(t, e, i, s) {
                        void 0 === e && (e = 0), void 0 === i && (i = " "), void 0 === s && (s = 3);
                        var n;
                        if (e + 1 >= (t = t.toString()).length) switch (s) {
                            case 1:
                                t = new Array(e + 1 - t.length).join(i) + t;
                                break;
                            case 3:
                                var a = Math.ceil((n = e - t.length) / 2);
                                t = new Array(1 + (n - a)).join(i) + t + new Array(a + 1).join(i);
                                break;
                            default:
                                t += new Array(e + 1 - t.length).join(i)
                        }
                        return t
                    },
                    isPlainObject: function(t) {
                        if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                        try {
                            if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                        } catch (t) {
                            return !1
                        }
                        return !0
                    },
                    extend: function() {
                        var t, e, i, s, n, a = arguments[0] || {},
                            o = 1,
                            r = arguments.length,
                            h = !1;
                        for ("boolean" == typeof a && (h = a, a = arguments[1] || {}, o = 2), r === o && (a = this, --o); o < r; o++)
                            if (null != (t = arguments[o]))
                                for (e in t) n = a[e], i = t[e], a !== i && (h && i && (X.Utils.isPlainObject(i) || (s = Array.isArray(i))) ? (n = s ? (s = !1, n && Array.isArray(n) ? n : []) : n && X.Utils.isPlainObject(n) ? n : {}, a[e] = X.Utils.extend(h, n, i)) : void 0 !== i && (a[e] = i));
                        return a
                    },
                    mixinPrototype: function(t, e, i) {
                        void 0 === i && (i = !1);
                        for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                            var a = s[n],
                                o = e[a];
                            !i && a in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[a] = o : "function" == typeof o.clone ? t[a] = o.clone() : Object.defineProperty(t, a, o))
                        }
                    },
                    mixin: function(t, e) {
                        if (!t || "object" != typeof t) return e;
                        for (var i in t) {
                            var s, n = t[i];
                            n.childNodes || n.cloneNode || (s = typeof t[i], t[i] && "object" == s ? typeof e[i] == s ? e[i] = X.Utils.mixin(t[i], e[i]) : e[i] = X.Utils.mixin(t[i], new n.constructor) : e[i] = t[i])
                        }
                        return e
                    }
                }, X.Circle = function(t, e, i) {
                    t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, (this._radius = 0) < i && (this._radius = .5 * i), this.type = X.CIRCLE
                }, X.Circle.prototype = {
                    circumference: function() {
                        return Math.PI * this._radius * 2
                    },
                    random: function(t) {
                        void 0 === t && (t = new X.Point);
                        var e = 2 * Math.PI * Math.random(),
                            i = Math.random() + Math.random(),
                            s = 1 < i ? 2 - i : i,
                            i = s * Math.cos(e),
                            e = s * Math.sin(e);
                        return t.x = this.x + i * this.radius, t.y = this.y + e * this.radius, t
                    },
                    getBounds: function() {
                        return new X.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                    },
                    setTo: function(t, e, i) {
                        return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.diameter)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                    },
                    distance: function(t, e) {
                        t = X.Math.distance(this.x, this.y, t.x, t.y);
                        return e ? Math.round(t) : t
                    },
                    clone: function(t) {
                        return null == t ? t = new X.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                    },
                    contains: function(t, e) {
                        return X.Circle.contains(this, t, e)
                    },
                    circumferencePoint: function(t, e, i) {
                        return X.Circle.circumferencePoint(this, t, e, i)
                    },
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    toString: function() {
                        return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                    }
                }, X.Circle.prototype.constructor = X.Circle, Object.defineProperty(X.Circle.prototype, "diameter", {
                    get: function() {
                        return this._diameter
                    },
                    set: function(t) {
                        0 < t && (this._diameter = t, this._radius = .5 * t)
                    }
                }), Object.defineProperty(X.Circle.prototype, "radius", {
                    get: function() {
                        return this._radius
                    },
                    set: function(t) {
                        0 < t && (this._radius = t, this._diameter = 2 * t)
                    }
                }), Object.defineProperty(X.Circle.prototype, "left", {
                    get: function() {
                        return this.x - this._radius
                    },
                    set: function(t) {
                        t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                    }
                }), Object.defineProperty(X.Circle.prototype, "right", {
                    get: function() {
                        return this.x + this._radius
                    },
                    set: function(t) {
                        t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                    }
                }), Object.defineProperty(X.Circle.prototype, "top", {
                    get: function() {
                        return this.y - this._radius
                    },
                    set: function(t) {
                        t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                    }
                }), Object.defineProperty(X.Circle.prototype, "bottom", {
                    get: function() {
                        return this.y + this._radius
                    },
                    set: function(t) {
                        t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                    }
                }), Object.defineProperty(X.Circle.prototype, "area", {
                    get: function() {
                        return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
                    }
                }), Object.defineProperty(X.Circle.prototype, "empty", {
                    get: function() {
                        return 0 === this._diameter
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0)
                    }
                }), X.Circle.contains = function(t, e, i) {
                    return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
                }, X.Circle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.diameter === e.diameter
                }, X.Circle.intersects = function(t, e) {
                    return X.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
                }, X.Circle.circumferencePoint = function(t, e, i, s) {
                    return void 0 === i && (i = !1), void 0 === s && (s = new X.Point), !0 === i && (e = X.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
                }, X.Circle.intersectsRectangle = function(t, e) {
                    var i = Math.abs(t.x - e.x - e.halfWidth);
                    if (i > e.halfWidth + t.radius) return !1;
                    var s = Math.abs(t.y - e.y - e.halfHeight);
                    if (s > e.halfHeight + t.radius) return !1;
                    if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                    i -= e.halfWidth, e = s - e.halfHeight;
                    return i * i + e * e <= t.radius * t.radius
                }, PIXI.Circle = X.Circle, X.Ellipse = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = X.ELLIPSE
                }, X.Ellipse.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    getBounds: function() {
                        return new X.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    clone: function(t) {
                        return null == t ? t = new X.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    },
                    contains: function(t, e) {
                        return X.Ellipse.contains(this, t, e)
                    },
                    random: function(t) {
                        void 0 === t && (t = new X.Point);
                        var e = Math.random() * Math.PI * 2,
                            i = Math.random();
                        return t.x = Math.sqrt(i) * Math.cos(e), t.y = Math.sqrt(i) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                    },
                    toString: function() {
                        return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                    }
                }, X.Ellipse.prototype.constructor = X.Ellipse, Object.defineProperty(X.Ellipse.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                }), Object.defineProperty(X.Ellipse.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t < this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(X.Ellipse.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }), Object.defineProperty(X.Ellipse.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t < this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(X.Ellipse.prototype, "empty", {
                    get: function() {
                        return 0 === this.width || 0 === this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), X.Ellipse.contains = function(t, e, i) {
                    if (t.width <= 0 || t.height <= 0) return !1;
                    e = (e - t.x) / t.width - .5, t = (i - t.y) / t.height - .5;
                    return (e *= e) + (t *= t) < .25
                }, PIXI.Ellipse = X.Ellipse, X.Line = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new X.Point(t, e), this.end = new X.Point(i, s), this.type = X.LINE
                }, X.Line.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(i, s), this
                    },
                    fromSprite: function(t, e, i) {
                        return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
                    },
                    fromAngle: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
                    },
                    rotate: function(t, e) {
                        var i = (this.start.x + this.end.x) / 2,
                            s = (this.start.y + this.end.y) / 2;
                        return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                    },
                    rotateAround: function(t, e, i, s) {
                        return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
                    },
                    intersects: function(t, e, i) {
                        return X.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
                    },
                    reflect: function(t) {
                        return X.Line.reflect(this, t)
                    },
                    midPoint: function(t) {
                        return void 0 === t && (t = new X.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                    },
                    centerOn: function(t, e) {
                        t -= (this.start.x + this.end.x) / 2, e -= (this.start.y + this.end.y) / 2;
                        this.start.add(t, e), this.end.add(t, e)
                    },
                    pointOnLine: function(t, e) {
                        return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
                    },
                    pointOnSegment: function(t, e) {
                        var i = Math.min(this.start.x, this.end.x),
                            s = Math.max(this.start.x, this.end.x),
                            n = Math.min(this.start.y, this.end.y),
                            a = Math.max(this.start.y, this.end.y);
                        return this.pointOnLine(t, e) && i <= t && t <= s && n <= e && e <= a
                    },
                    random: function(t) {
                        void 0 === t && (t = new X.Point);
                        var e = Math.random();
                        return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                    },
                    coordinatesOnLine: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = []);
                        var i = Math.round(this.start.x),
                            s = Math.round(this.start.y),
                            n = Math.round(this.end.x),
                            a = Math.round(this.end.y),
                            o = Math.abs(n - i),
                            r = Math.abs(a - s),
                            h = i < n ? 1 : -1,
                            l = s < a ? 1 : -1,
                            c = o - r;
                        e.push([i, s]);
                        for (var u = 1; i !== n || s !== a;) {
                            var d = c << 1; - r < d && (c -= r, i += h), d < o && (c += o, s += l), u % t == 0 && e.push([i, s]), u++
                        }
                        return e
                    },
                    clone: function(t) {
                        return null == t ? t = new X.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                    }
                }, Object.defineProperty(X.Line.prototype, "length", {
                    get: function() {
                        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                    }
                }), Object.defineProperty(X.Line.prototype, "angle", {
                    get: function() {
                        return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "slope", {
                    get: function() {
                        return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "perpSlope", {
                    get: function() {
                        return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                    }
                }), Object.defineProperty(X.Line.prototype, "x", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "y", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(X.Line.prototype, "left", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "right", {
                    get: function() {
                        return Math.max(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "top", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(X.Line.prototype, "bottom", {
                    get: function() {
                        return Math.max(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(X.Line.prototype, "width", {
                    get: function() {
                        return Math.abs(this.start.x - this.end.x)
                    }
                }), Object.defineProperty(X.Line.prototype, "height", {
                    get: function() {
                        return Math.abs(this.start.y - this.end.y)
                    }
                }), Object.defineProperty(X.Line.prototype, "normalX", {
                    get: function() {
                        return Math.cos(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(X.Line.prototype, "normalY", {
                    get: function() {
                        return Math.sin(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(X.Line.prototype, "normalAngle", {
                    get: function() {
                        return X.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                    }
                }), X.Line.intersectsPoints = function(t, e, i, s, n, a) {
                    void 0 === n && (n = !0), void 0 === a && (a = new X.Point);
                    var o = e.y - t.y,
                        r = s.y - i.y,
                        h = t.x - e.x,
                        l = i.x - s.x,
                        c = e.x * t.y - t.x * e.y,
                        u = s.x * i.y - i.x * s.y,
                        d = o * l - r * h;
                    if (0 == d) return null;
                    if (a.x = (h * u - l * c) / d, a.y = (r * c - o * u) / d, n) {
                        n = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y), s = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / n, n = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / n;
                        return 0 <= s && s <= 1 && 0 <= n && n <= 1 ? a : null
                    }
                    return a
                }, X.Line.intersects = function(t, e, i, s) {
                    return X.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
                }, X.Line.intersectsRectangle = function(t, e) {
                    if (!X.Rectangle.intersects(t, e)) return !1;
                    var i = t.start.x,
                        s = t.start.y,
                        n = t.end.x,
                        a = t.end.y,
                        o = e.x,
                        r = e.y,
                        h = e.right,
                        t = e.bottom,
                        e = 0;
                    if (o <= i && i <= h && r <= s && s <= t || o <= n && n <= h && r <= a && a <= t) return !0;
                    if (i < o && o <= n) {
                        if ((e = s + (a - s) * (o - i) / (n - i)) > r && e <= t) return !0
                    } else if (h < i && n <= h && (e = s + (a - s) * (h - i) / (n - i)) >= r && e <= t) return !0;
                    if (s < r && r <= a) {
                        if ((e = i + (n - i) * (r - s) / (a - s)) >= o && e <= h) return !0
                    } else if (t < s && a <= t && (e = i + (n - i) * (t - s) / (a - s)) >= o && e <= h) return !0;
                    return !1
                }, X.Line.reflect = function(t, e) {
                    return 2 * e.normalAngle - 3.141592653589793 - t.angle
                }, X.Matrix = function(t, e, i, s, n, a) {
                    null != t || (t = 1), null != e || (e = 0), null != i || (i = 0), null != s || (s = 1), null != n || (n = 0), null != a || (a = 0), this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = a, this.type = X.MATRIX
                }, X.Matrix.prototype = {
                    fromArray: function(t) {
                        return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                    },
                    setTo: function(t, e, i, s, n, a) {
                        return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = a, this
                    },
                    clone: function(t) {
                        return null == t ? t = new X.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                    },
                    copyTo: function(t) {
                        return t.copyFrom(this), t
                    },
                    copyFrom: function(t) {
                        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                    },
                    toArray: function(t, e) {
                        return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0), e[8] = 1, e
                    },
                    apply: function(t, e) {
                        return void 0 === e && (e = new X.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                    },
                    applyInverse: function(t, e) {
                        void 0 === e && (e = new X.Point);
                        var i = 1 / (this.a * this.d + this.c * -this.b),
                            s = t.x,
                            t = t.y;
                        return e.x = this.d * i * s + -this.c * i * t + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * t + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, e
                    },
                    translate: function(t, e) {
                        return this.tx += t, this.ty += e, this
                    },
                    scale: function(t, e) {
                        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                    },
                    rotate: function(t) {
                        var e = Math.cos(t),
                            i = Math.sin(t),
                            s = this.a,
                            n = this.c,
                            t = this.tx;
                        return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = t * e - this.ty * i, this.ty = t * i + this.ty * e, this
                    },
                    append: function(t) {
                        var e = this.a,
                            i = this.b,
                            s = this.c,
                            n = this.d;
                        return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
                    },
                    identity: function() {
                        return this.setTo(1, 0, 0, 1, 0, 0)
                    }
                }, X.identityMatrix = new X.Matrix, PIXI.Matrix = X.Matrix, PIXI.identityMatrix = X.identityMatrix, X.Point = function(t, e) {
                    t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = X.POINT
                }, X.Point.prototype = {
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y)
                    },
                    invert: function() {
                        return this.setTo(this.y, this.x)
                    },
                    setTo: function(t, e) {
                        return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                    },
                    set: function(t, e) {
                        return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                    },
                    add: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    subtract: function(t, e) {
                        return this.x -= t, this.y -= e, this
                    },
                    multiply: function(t, e) {
                        return this.x *= t, this.y *= e, this
                    },
                    divide: function(t, e) {
                        return this.x /= t, this.y /= e, this
                    },
                    clampX: function(t, e) {
                        return this.x = X.Math.clamp(this.x, t, e), this
                    },
                    clampY: function(t, e) {
                        return this.y = X.Math.clamp(this.y, t, e), this
                    },
                    clamp: function(t, e) {
                        return this.x = X.Math.clamp(this.x, t, e), this.y = X.Math.clamp(this.y, t, e), this
                    },
                    clone: function(t) {
                        return null == t ? t = new X.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t
                    },
                    distance: function(t, e) {
                        return X.Point.distance(this, t, e)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y
                    },
                    angle: function(t, e) {
                        return void 0 === e && (e = !1), e ? X.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
                    },
                    rotate: function(t, e, i, s, n) {
                        return X.Point.rotate(this, t, e, i, s, n)
                    },
                    getMagnitude: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    getMagnitudeSq: function() {
                        return this.x * this.x + this.y * this.y
                    },
                    setMagnitude: function(t) {
                        return this.normalize().multiply(t, t)
                    },
                    normalize: function() {
                        var t;
                        return this.isZero() || (t = this.getMagnitude(), this.x /= t, this.y /= t), this
                    },
                    isZero: function() {
                        return 0 === this.x && 0 === this.y
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y
                    },
                    cross: function(t) {
                        return this.x * t.y - this.y * t.x
                    },
                    perp: function() {
                        return this.setTo(-this.y, this.x)
                    },
                    rperp: function() {
                        return this.setTo(this.y, -this.x)
                    },
                    normalRightHand: function() {
                        return this.setTo(-1 * this.y, this.x)
                    },
                    floor: function() {
                        return this.setTo(Math.floor(this.x), Math.floor(this.y))
                    },
                    ceil: function() {
                        return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                    },
                    toString: function() {
                        return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                    }
                }, X.Point.prototype.constructor = X.Point, X.Point.add = function(t, e, i) {
                    return void 0 === i && (i = new X.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
                }, X.Point.subtract = function(t, e, i) {
                    return void 0 === i && (i = new X.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
                }, X.Point.multiply = function(t, e, i) {
                    return void 0 === i && (i = new X.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
                }, X.Point.divide = function(t, e, i) {
                    return void 0 === i && (i = new X.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
                }, X.Point.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, X.Point.angle = function(t, e) {
                    return Math.atan2(t.y - e.y, t.x - e.x)
                }, X.Point.negative = function(t, e) {
                    return void 0 === e && (e = new X.Point), e.setTo(-t.x, -t.y)
                }, X.Point.multiplyAdd = function(t, e, i, s) {
                    return void 0 === s && (s = new X.Point), s.setTo(t.x + e.x * i, t.y + e.y * i)
                }, X.Point.interpolate = function(t, e, i, s) {
                    return void 0 === s && (s = new X.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
                }, X.Point.perp = function(t, e) {
                    return void 0 === e && (e = new X.Point), e.setTo(-t.y, t.x)
                }, X.Point.rperp = function(t, e) {
                    return void 0 === e && (e = new X.Point), e.setTo(t.y, -t.x)
                }, X.Point.distance = function(t, e, i) {
                    e = X.Math.distance(t.x, t.y, e.x, e.y);
                    return i ? Math.round(e) : e
                }, X.Point.project = function(t, e, i) {
                    void 0 === i && (i = new X.Point);
                    t = t.dot(e) / e.getMagnitudeSq();
                    return 0 != t && i.setTo(t * e.x, t * e.y), i
                }, X.Point.projectUnit = function(t, e, i) {
                    void 0 === i && (i = new X.Point);
                    t = t.dot(e);
                    return 0 !== t && i.setTo(t * e.x, t * e.y), i
                }, X.Point.normalRightHand = function(t, e) {
                    return void 0 === e && (e = new X.Point), e.setTo(-1 * t.y, t.x)
                }, X.Point.normalize = function(t, e) {
                    void 0 === e && (e = new X.Point);
                    var i = t.getMagnitude();
                    return 0 !== i && e.setTo(t.x / i, t.y / i), e
                }, X.Point.rotate = function(t, e, i, s, n, a) {
                    var o, r;
                    return n && (s = X.Math.degToRad(s)), void 0 === a ? (t.subtract(e, i), o = Math.sin(s), n = (r = Math.cos(s)) * t.x - o * t.y, r = o * t.x + r * t.y, t.x = n + e, t.y = r + i) : (s = s + Math.atan2(t.y - i, t.x - e), t.x = e + a * Math.cos(s), t.y = i + a * Math.sin(s)), t
                }, X.Point.centroid = function(t, e) {
                    if (void 0 === e && (e = new X.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                    var i = t.length;
                    if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                    if (1 === i) return e.copyFrom(t[0]), e;
                    for (var s = 0; s < i; s++) X.Point.add(e, t[s], e);
                    return e.divide(i, i), e
                }, X.Point.parse = function(t, e, i) {
                    e = e || "x", i = i || "y";
                    var s = new X.Point;
                    return t[e] && (s.x = parseInt(t[e], 10)), t[i] && (s.y = parseInt(t[i], 10)), s
                }, PIXI.Point = X.Point, X.Polygon = function() {
                    this.area = 0, this._points = [], 0 < arguments.length && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = X.POLYGON
                }, X.Polygon.prototype = {
                    toNumberArray: function(t) {
                        void 0 === t && (t = []);
                        for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                        return t
                    },
                    flatten: function() {
                        return this._points = this.toNumberArray(), this.flattened = !0, this
                    },
                    clone: function(t) {
                        var e = this._points.slice();
                        return null == t ? t = new X.Polygon(e) : t.setTo(e), t
                    },
                    contains: function(t, e) {
                        var i = !1;
                        if (this.flattened)
                            for (var s = -2, n = this._points.length - 2;
                                (s += 2) < this._points.length; n = s) {
                                var a = this._points[s],
                                    o = this._points[s + 1],
                                    r = this._points[n],
                                    h = this._points[n + 1];
                                (o <= e && e < h || h <= e && e < o) && t < (r - a) * (e - o) / (h - o) + a && (i = !i)
                            } else
                                for (s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                                    a = this._points[s].x, o = this._points[s].y, r = this._points[n].x, h = this._points[n].y;
                                    (o <= e && e < h || h <= e && e < o) && t < (r - a) * (e - o) / (h - o) + a && (i = !i)
                                }
                        return i
                    },
                    setTo: function(t) {
                        if (this.area = 0, this._points = [], 0 < arguments.length) {
                            Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                            for (var e, i = Number.MAX_VALUE, s = 0, n = t.length; s < n; s++) "number" == typeof t[s] ? (e = new PIXI.Point(t[s], t[s + 1]), s++) : e = Array.isArray(t[s]) ? new PIXI.Point(t[s][0], t[s][1]) : new PIXI.Point(t[s].x, t[s].y), this._points.push(e), e.y < i && (i = e.y);
                            this.calculateArea(i)
                        }
                        return this
                    },
                    calculateArea: function(t) {
                        for (var e, i, s, n = 0, a = this._points.length; n < a; n++) e = this._points[n], s = n === a - 1 ? this._points[0] : this._points[n + 1], i = (e.y - t + (s.y - t)) / 2, s = e.x - s.x, this.area += i * s;
                        return this.area
                    }
                }, X.Polygon.prototype.constructor = X.Polygon, Object.defineProperty(X.Polygon.prototype, "points", {
                    get: function() {
                        return this._points
                    },
                    set: function(t) {
                        null != t ? this.setTo(t) : this.setTo()
                    }
                }), PIXI.Polygon = X.Polygon, X.Rectangle = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = X.RECTANGLE
                }, X.Rectangle.prototype = {
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    scale: function(t, e) {
                        return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                    },
                    centerOn: function(t, e) {
                        return this.centerX = t, this.centerY = e, this
                    },
                    floor: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                    },
                    floorAll: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                    },
                    ceil: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                    },
                    ceilAll: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    inflate: function(t, e) {
                        return X.Rectangle.inflate(this, t, e)
                    },
                    size: function(t) {
                        return X.Rectangle.size(this, t)
                    },
                    resize: function(t, e) {
                        return this.width = t, this.height = e, this
                    },
                    clone: function(t) {
                        return X.Rectangle.clone(this, t)
                    },
                    contains: function(t, e) {
                        return X.Rectangle.contains(this, t, e)
                    },
                    containsRect: function(t) {
                        return X.Rectangle.containsRect(t, this)
                    },
                    equals: function(t) {
                        return X.Rectangle.equals(this, t)
                    },
                    intersection: function(t, e) {
                        return X.Rectangle.intersection(this, t, e)
                    },
                    intersects: function(t) {
                        return X.Rectangle.intersects(this, t)
                    },
                    intersectsRaw: function(t, e, i, s, n) {
                        return X.Rectangle.intersectsRaw(this, t, e, i, s, n)
                    },
                    union: function(t, e) {
                        return X.Rectangle.union(this, t, e)
                    },
                    random: function(t) {
                        return void 0 === t && (t = new X.Point), t.x = this.randomX, t.y = this.randomY, t
                    },
                    getPoint: function(t, e) {
                        switch (void 0 === e && (e = new X.Point), t) {
                            default:
                                case X.TOP_LEFT:
                                return e.set(this.x, this.y);
                            case X.TOP_CENTER:
                                    return e.set(this.centerX, this.y);
                            case X.TOP_RIGHT:
                                    return e.set(this.right, this.y);
                            case X.LEFT_CENTER:
                                    return e.set(this.x, this.centerY);
                            case X.CENTER:
                                    return e.set(this.centerX, this.centerY);
                            case X.RIGHT_CENTER:
                                    return e.set(this.right, this.centerY);
                            case X.BOTTOM_LEFT:
                                    return e.set(this.x, this.bottom);
                            case X.BOTTOM_CENTER:
                                    return e.set(this.centerX, this.bottom);
                            case X.BOTTOM_RIGHT:
                                    return e.set(this.right, this.bottom)
                        }
                    },
                    toString: function() {
                        return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                    }
                }, Object.defineProperty(X.Rectangle.prototype, "halfWidth", {
                    get: function() {
                        return Math.round(this.width / 2)
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "halfHeight", {
                    get: function() {
                        return Math.round(this.height / 2)
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t <= this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "bottomLeft", {
                    get: function() {
                        return new X.Point(this.x, this.bottom)
                    },
                    set: function(t) {
                        this.x = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "bottomRight", {
                    get: function() {
                        return new X.Point(this.right, this.bottom)
                    },
                    set: function(t) {
                        this.right = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t <= this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "volume", {
                    get: function() {
                        return this.width * this.height
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "perimeter", {
                    get: function() {
                        return 2 * this.width + 2 * this.height
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "centerX", {
                    get: function() {
                        return this.x + this.halfWidth
                    },
                    set: function(t) {
                        this.x = t - this.halfWidth
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "centerY", {
                    get: function() {
                        return this.y + this.halfHeight
                    },
                    set: function(t) {
                        this.y = t - this.halfHeight
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "randomX", {
                    get: function() {
                        return this.x + Math.random() * this.width
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "randomY", {
                    get: function() {
                        return this.y + Math.random() * this.height
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "topLeft", {
                    get: function() {
                        return new X.Point(this.x, this.y)
                    },
                    set: function(t) {
                        this.x = t.x, this.y = t.y
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "topRight", {
                    get: function() {
                        return new X.Point(this.x + this.width, this.y)
                    },
                    set: function(t) {
                        this.right = t.x, this.y = t.y
                    }
                }), Object.defineProperty(X.Rectangle.prototype, "empty", {
                    get: function() {
                        return !this.width || !this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), X.Rectangle.prototype.constructor = X.Rectangle, X.Rectangle.inflate = function(t, e, i) {
                    return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
                }, X.Rectangle.inflatePoint = function(t, e) {
                    return X.Rectangle.inflate(t, e.x, e.y)
                }, X.Rectangle.size = function(t, e) {
                    return null == e ? e = new X.Point(t.width, t.height) : e.setTo(t.width, t.height), e
                }, X.Rectangle.clone = function(t, e) {
                    return null == e ? e = new X.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
                }, X.Rectangle.contains = function(t, e, i) {
                    return !(t.width <= 0 || t.height <= 0) && e >= t.x && e < t.right && i >= t.y && i < t.bottom
                }, X.Rectangle.containsRaw = function(t, e, i, s, n, a) {
                    return t <= n && n < t + i && e <= a && a < e + s
                }, X.Rectangle.containsPoint = function(t, e) {
                    return X.Rectangle.contains(t, e.x, e.y)
                }, X.Rectangle.containsRect = function(t, e) {
                    return !(t.volume > e.volume) && t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom
                }, X.Rectangle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
                }, X.Rectangle.sameDimensions = function(t, e) {
                    return t.width === e.width && t.height === e.height
                }, X.Rectangle.intersection = function(t, e, i) {
                    return void 0 === i && (i = new X.Rectangle), X.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
                }, X.Rectangle.intersects = function(t, e) {
                    return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
                }, X.Rectangle.intersectsRaw = function(t, e, i, s, n, a) {
                    return void 0 === a && (a = 0), !(e > t.right + a || i < t.left - a || s > t.bottom + a || n < t.top - a)
                }, X.Rectangle.union = function(t, e, i) {
                    return void 0 === i && (i = new X.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
                }, X.Rectangle.aabb = function(t, e) {
                    void 0 === e && (e = new X.Rectangle);
                    var i = Number.NEGATIVE_INFINITY,
                        s = Number.POSITIVE_INFINITY,
                        n = Number.NEGATIVE_INFINITY,
                        a = Number.POSITIVE_INFINITY;
                    return t.forEach(function(t) {
                        t.x > i && (i = t.x), t.x < s && (s = t.x), t.y > n && (n = t.y), t.y < a && (a = t.y)
                    }), e.setTo(s, a, i - s, n - a), e
                }, PIXI.Rectangle = X.Rectangle, PIXI.EmptyRectangle = new X.Rectangle(0, 0, 0, 0), X.RoundedRectangle = function(t, e, i, s, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 20), this.x = t, this.y = e, this.width = i, this.height = s, this.radius = n || 20, this.type = X.ROUNDEDRECTANGLE
                }, X.RoundedRectangle.prototype = {
                    clone: function() {
                        return new X.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                    },
                    contains: function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = this.x;
                        if (i <= t && t <= i + this.width) {
                            i = this.y;
                            if (i <= e && e <= i + this.height) return !0
                        }
                        return !1
                    }
                }, X.RoundedRectangle.prototype.constructor = X.RoundedRectangle, PIXI.RoundedRectangle = X.RoundedRectangle, X.Camera = function(t, e, i, s, n, a) {
                    this.game = t, this.world = t.world, this.id = 0, this.view = new X.Rectangle(i, s, n, a), this.bounds = new X.Rectangle(i, s, n, a), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                        x: !1,
                        y: !1
                    }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new X.Point(1, 1), this.onShakeComplete = new X.Signal, this.onFlashComplete = new X.Signal, this.onFadeComplete = new X.Signal, this.fx = null, this._targetPosition = new X.Point, this._edge = 0, this._position = new X.Point, this._shake = {
                        intensity: 0,
                        duration: 0,
                        horizontal: !1,
                        vertical: !1,
                        shakeBounds: !0,
                        x: 0,
                        y: 0
                    }, this._fxDuration = 0, this._fxType = 0
                }, X.Camera.FOLLOW_LOCKON = 0, X.Camera.FOLLOW_PLATFORMER = 1, X.Camera.FOLLOW_TOPDOWN = 2, X.Camera.FOLLOW_TOPDOWN_TIGHT = 3, X.Camera.SHAKE_BOTH = 4, X.Camera.SHAKE_HORIZONTAL = 5, X.Camera.SHAKE_VERTICAL = 6, X.Camera.ENABLE_FX = !0, X.Camera.prototype = {
                    boot: function() {
                        this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, X.Graphics && X.Camera.ENABLE_FX && (this.fx = new X.Graphics(this.game), this.game.stage.addChild(this.fx))
                    },
                    preUpdate: function() {
                        this.totalInView = 0
                    },
                    follow: function(t, e, i, s) {
                        var n;
                        switch (void 0 === e && (e = X.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(i, s), e) {
                            case X.Camera.FOLLOW_PLATFORMER:
                                var a = this.width / 8,
                                    o = this.height / 3;
                                this.deadzone = new X.Rectangle((this.width - a) / 2, (this.height - o) / 2 - .25 * o, a, o);
                                break;
                            case X.Camera.FOLLOW_TOPDOWN:
                                n = Math.max(this.width, this.height) / 4, this.deadzone = new X.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                                break;
                            case X.Camera.FOLLOW_TOPDOWN_TIGHT:
                                n = Math.max(this.width, this.height) / 8, this.deadzone = new X.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                                break;
                            case X.Camera.FOLLOW_LOCKON:
                            default:
                                this.deadzone = null
                        }
                    },
                    unfollow: function() {
                        this.target = null
                    },
                    focusOn: function(t) {
                        this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                    },
                    focusOnXY: function(t, e) {
                        this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                    },
                    shake: function(t, e, i, s, n) {
                        return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === s && (s = X.Camera.SHAKE_BOTH), void 0 === n && (n = !0), !(!i && 0 < this._shake.duration || (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = n, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === X.Camera.SHAKE_BOTH || s === X.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === X.Camera.SHAKE_BOTH || s === X.Camera.SHAKE_VERTICAL, 0))
                    },
                    flash: function(t, e, i) {
                        return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration || (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0))
                    },
                    fade: function(t, e, i) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration || (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, 0))
                    },
                    update: function() {
                        0 < this._fxDuration && this.updateFX(), 0 < this._shake.duration && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    updateFX: function() {
                        0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, 1 <= this.fx.alpha && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                    },
                    updateShake: function() {
                        this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                    },
                    updateTarget: function() {
                        this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    setBoundsToWorld: function() {
                        this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                    },
                    checkBounds: function() {
                        this.atLimit.x = !1, this.atLimit.y = !1;
                        var t = this.view.x + this._shake.x,
                            e = this.view.right + this._shake.x,
                            i = this.view.y + this._shake.y,
                            s = this.view.bottom + this._shake.y;
                        t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                    },
                    setPosition: function(t, e) {
                        this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                    },
                    setSize: function(t, e) {
                        this.view.width = t, this.view.height = e
                    },
                    reset: function() {
                        this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
                    },
                    resetFX: function() {
                        this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
                    }
                }, X.Camera.prototype.constructor = X.Camera, Object.defineProperty(X.Camera.prototype, "x", {
                    get: function() {
                        return this.view.x
                    },
                    set: function(t) {
                        this.view.x = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(X.Camera.prototype, "y", {
                    get: function() {
                        return this.view.y
                    },
                    set: function(t) {
                        this.view.y = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(X.Camera.prototype, "position", {
                    get: function() {
                        return this._position.set(this.view.x, this.view.y), this._position
                    },
                    set: function(t) {
                        void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(X.Camera.prototype, "width", {
                    get: function() {
                        return this.view.width
                    },
                    set: function(t) {
                        this.view.width = t
                    }
                }), Object.defineProperty(X.Camera.prototype, "height", {
                    get: function() {
                        return this.view.height
                    },
                    set: function(t) {
                        this.view.height = t
                    }
                }), Object.defineProperty(X.Camera.prototype, "shakeIntensity", {
                    get: function() {
                        return this._shake.intensity
                    },
                    set: function(t) {
                        this._shake.intensity = t
                    }
                }), X.State = function() {
                    this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
                }, X.State.prototype = {
                    init: function() {},
                    preload: function() {},
                    loadUpdate: function() {},
                    loadRender: function() {},
                    create: function() {},
                    update: function() {},
                    preRender: function() {},
                    render: function() {},
                    resize: function() {},
                    paused: function() {},
                    resumed: function() {},
                    pauseUpdate: function() {},
                    shutdown: function() {}
                }, X.State.prototype.constructor = X.State, X.StateManager = function(t, e) {
                    this.game = t, this.states = {}, (this._pendingState = null) != e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new X.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
                }, X.StateManager.prototype = {
                    boot: function() {
                        this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                    },
                    add: function(t, e, i) {
                        var s;
                        return void 0 === i && (i = !1), e instanceof X.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
                    },
                    remove: function(t) {
                        this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                    },
                    start: function(t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, 3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3)))
                    },
                    restart: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, 2 < arguments.length && (this._args = Array.prototype.slice.call(arguments, 2))
                    },
                    dummy: function() {},
                    preUpdate: function() {
                        var t;
                        this._pendingState && this.game.isBooted && (t = this.current, this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current === this._pendingState && (this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()))
                    },
                    clearCurrentState: function() {
                        this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                    },
                    checkState: function(t) {
                        return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render)
                    },
                    link: function(t) {
                        this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, (this.states[t].state = this).states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
                    },
                    unlink: function(t) {
                        this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
                    },
                    setCurrentState: function(t) {
                        this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                    },
                    getCurrentState: function() {
                        return this.states[this.current]
                    },
                    loadComplete: function() {
                        !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                    },
                    pause: function() {
                        this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                    },
                    resume: function() {
                        this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                    },
                    update: function() {
                        this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    pauseUpdate: function() {
                        this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    preRender: function(t) {
                        this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                    },
                    resize: function(t, e) {
                        this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                    },
                    render: function() {
                        this._created ? this.onRenderCallback && (this.game.renderType === X.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                    },
                    destroy: function() {
                        this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                    }
                }, X.StateManager.prototype.constructor = X.StateManager, Object.defineProperty(X.StateManager.prototype, "created", {
                    get: function() {
                        return this._created
                    }
                }), X.Signal = function() {}, X.Signal.prototype = {
                    _bindings: null,
                    _prevParams: null,
                    memorize: !1,
                    _shouldPropagate: !0,
                    active: !0,
                    _boundDispatch: !1,
                    validateListener: function(t, e) {
                        if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                    },
                    _registerListener: function(t, e, i, s, n) {
                        var a, o = this._indexOfListener(t, i);
                        if (-1 !== o) {
                            if ((a = this._bindings[o]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                        } else a = new X.SignalBinding(this, t, e, i, s, n), this._addBinding(a);
                        return this.memorize && this._prevParams && a.execute(this._prevParams), a
                    },
                    _addBinding: function(t) {
                        this._bindings || (this._bindings = []);
                        for (var e = this._bindings.length; e--, this._bindings[e] && t._priority <= this._bindings[e]._priority;);
                        this._bindings.splice(e + 1, 0, t)
                    },
                    _indexOfListener: function(t, e) {
                        if (!this._bindings) return -1;
                        void 0 === e && (e = null);
                        for (var i, s = this._bindings.length; s--;)
                            if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                        return -1
                    },
                    has: function(t, e) {
                        return -1 !== this._indexOfListener(t, e)
                    },
                    add: function(t, e, i) {
                        this.validateListener(t, "add");
                        var s = [];
                        if (3 < arguments.length)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !1, e, i, s)
                    },
                    addOnce: function(t, e, i) {
                        this.validateListener(t, "addOnce");
                        var s = [];
                        if (3 < arguments.length)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !0, e, i, s)
                    },
                    remove: function(t, e) {
                        this.validateListener(t, "remove");
                        e = this._indexOfListener(t, e);
                        return -1 !== e && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)), t
                    },
                    removeAll: function(t) {
                        if (void 0 === t && (t = null), this._bindings) {
                            for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                            t || (this._bindings.length = 0)
                        }
                    },
                    getNumListeners: function() {
                        return this._bindings ? this._bindings.length : 0
                    },
                    halt: function() {
                        this._shouldPropagate = !1
                    },
                    dispatch: function() {
                        if (this.active && this._bindings) {
                            var t, e = Array.prototype.slice.call(arguments),
                                i = this._bindings.length;
                            if (this.memorize && (this._prevParams = e), i)
                                for (t = this._bindings.slice(), this._shouldPropagate = !0; i--, t[i] && this._shouldPropagate && !1 !== t[i].execute(e););
                        }
                    },
                    forget: function() {
                        this._prevParams && (this._prevParams = null)
                    },
                    dispose: function() {
                        this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                    },
                    toString: function() {
                        return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                    }
                }, Object.defineProperty(X.Signal.prototype, "boundDispatch", {
                    get: function() {
                        var t = this;
                        return this._boundDispatch || (this._boundDispatch = function() {
                            return t.dispatch.apply(t, arguments)
                        })
                    }
                }), X.Signal.prototype.constructor = X.Signal, X.SignalBinding = function(t, e, i, s, n, a) {
                    this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), a && a.length && (this._args = a)
                }, X.SignalBinding.prototype = {
                    context: null,
                    _isOnce: !1,
                    _priority: 0,
                    _args: null,
                    callCount: 0,
                    active: !0,
                    params: null,
                    execute: function(t) {
                        var e;
                        return this.active && this._listener && (e = this.params ? this.params.concat(t) : t, this._args && (e = e.concat(this._args)), e = this._listener.apply(this.context, e), this.callCount++, this._isOnce && this.detach()), e
                    },
                    detach: function() {
                        return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                    },
                    isBound: function() {
                        return !!this._signal && !!this._listener
                    },
                    isOnce: function() {
                        return this._isOnce
                    },
                    getListener: function() {
                        return this._listener
                    },
                    getSignal: function() {
                        return this._signal
                    },
                    _destroy: function() {
                        delete this._signal, delete this._listener, delete this.context
                    },
                    toString: function() {
                        return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                    }
                }, X.SignalBinding.prototype.constructor = X.SignalBinding, X.Filter = function(t, e, i) {
                    this.game = t, this.type = X.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new X.Point;
                    t = new Date;
                    if (this.uniforms = {
                            resolution: {
                                type: "2f",
                                value: {
                                    x: 256,
                                    y: 256
                                }
                            },
                            time: {
                                type: "1f",
                                value: 0
                            },
                            mouse: {
                                type: "2f",
                                value: {
                                    x: 0,
                                    y: 0
                                }
                            },
                            date: {
                                type: "4fv",
                                value: [t.getFullYear(), t.getMonth(), t.getDate(), 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds()]
                            },
                            sampleRate: {
                                type: "1f",
                                value: 44100
                            },
                            iChannel0: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel1: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel2: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel3: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            }
                        }, e)
                        for (var s in e) this.uniforms[s] = e[s];
                    this.fragmentSrc = i || ""
                }, X.Filter.prototype = {
                    init: function() {},
                    setResolution: function(t, e) {
                        this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                    },
                    update: function(t) {
                        var e;
                        void 0 !== t && (e = t.x / this.game.width, t = 1 - t.y / this.game.height, e === this.prevPoint.x && t === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = t.toFixed(2), this.prevPoint.set(e, t))), this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                    },
                    addToWorld: function(t, e, i, s, n, a) {
                        void 0 === n && (n = 0), void 0 === a && (a = 0), null != i ? this.width = i : i = this.width, null != s ? this.height = s : s = this.height;
                        e = this.game.add.image(t, e, "__default");
                        return e.width = i, e.height = s, e.anchor.set(n, a), e.filters = [this], e
                    },
                    destroy: function() {
                        this.game = null
                    }
                }, X.Filter.prototype.constructor = X.Filter, Object.defineProperty(X.Filter.prototype, "width", {
                    get: function() {
                        return this.uniforms.resolution.value.x
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.x = t
                    }
                }), Object.defineProperty(X.Filter.prototype, "height", {
                    get: function() {
                        return this.uniforms.resolution.value.y
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.y = t
                    }
                }), X.Plugin = function(t, e) {
                    void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
                }, X.Plugin.prototype = {
                    preUpdate: function() {},
                    update: function() {},
                    render: function() {},
                    postRender: function() {},
                    destroy: function() {
                        this.game = null, this.parent = null, this.active = !1, this.visible = !1
                    }
                }, X.Plugin.prototype.constructor = X.Plugin, X.PluginManager = function(t) {
                    this.game = t, this.plugins = [], this._len = 0, this._i = 0
                }, X.PluginManager.prototype = {
                    add: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            i = !1;
                        return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (i = t.hasPreUpdate = !0), "function" == typeof t.update && (i = t.hasUpdate = !0), "function" == typeof t.postUpdate && (i = t.hasPostUpdate = !0), "function" == typeof t.render && (i = t.hasRender = !0), "function" == typeof t.postRender && (i = t.hasPostRender = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                    },
                    remove: function(t, e) {
                        for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                            if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                    },
                    removeAll: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                        this.plugins.length = 0, this._len = 0
                    },
                    preUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                    },
                    update: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                    },
                    postUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                    },
                    render: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                    },
                    postRender: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                    },
                    destroy: function() {
                        this.removeAll(), this.game = null
                    }
                }, X.PluginManager.prototype.constructor = X.PluginManager, X.Stage = function(t) {
                    this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, (this.stage = this).currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        color: 0,
                        rgba: "#000000"
                    }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
                }, X.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), X.Stage.prototype.constructor = X.Stage, X.Stage.prototype.parseConfig = function(t) {
                    t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
                }, X.Stage.prototype.boot = function() {
                    X.DOM.getOffset(this.game.canvas, this.offset), X.Canvas.setUserSelect(this.game.canvas, "none"), X.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
                }, X.Stage.prototype.preUpdate = function() {
                    for (var t = this.currentRenderOrderID = 0; t < this.children.length; t++) this.children[t].preUpdate()
                }, X.Stage.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, X.Stage.prototype.postUpdate = function() {
                    this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                    this.updateTransform()
                }, X.Stage.prototype.updateTransform = function() {
                    this.worldAlpha = 1;
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
                }, X.Stage.prototype.checkVisibility = function() {
                    void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                    var e = this;
                    this._onChange = function(t) {
                        return e.visibilityChange(t)
                    }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                        X.Stage.prototype.visibilityChange.call(e, {
                            type: "pause"
                        })
                    }), CocoonJS.App.onActivated.addEventListener(function() {
                        X.Stage.prototype.visibilityChange.call(e, {
                            type: "resume"
                        })
                    }))
                }, X.Stage.prototype.visibilityChange = function(t) {
                    "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)
                }, X.Stage.prototype.setBackgroundColor = function(t) {
                    this.game.transparent || (X.Color.valueToColor(t, this._bgColor), X.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
                }, X.Stage.prototype.destroy = function() {
                    this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
                }, Object.defineProperty(X.Stage.prototype, "backgroundColor", {
                    get: function() {
                        return this._bgColor.color
                    },
                    set: function(t) {
                        this.setBackgroundColor(t)
                    }
                }), Object.defineProperty(X.Stage.prototype, "smoothed", {
                    get: function() {
                        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                    },
                    set: function(t) {
                        PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                    }
                }), X.Group = function(t, e, i, s, n, a) {
                    void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === a && (a = X.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = X.GROUP, this.physicsType = X.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = X.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new X.Signal, this.onChildInputUp = new X.Signal, this.onChildInputOver = new X.Signal, this.onChildInputOut = new X.Signal, this.enableBody = n, this.enableBodyDebug = !1, this.physicsBodyType = a, this.physicsSortDirection = null, this.onDestroy = new X.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new X.Point, this.hash = [], this._sortProperty = "z"
                }, X.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), X.Group.prototype.constructor = X.Group, X.Group.RETURN_NONE = 0, X.Group.RETURN_TOTAL = 1, X.Group.RETURN_CHILD = 2, X.Group.RETURN_ALL = 3, X.Group.SORT_ASCENDING = -1, X.Group.SORT_DESCENDING = 1, X.Group.prototype.add = function(t, e, i) {
                    return void 0 === e && (e = !1), t.parent === this || (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t)), t
                }, X.Group.prototype.addAt = function(t, e, i) {
                    this.add(t, i, e)
                }, X.Group.prototype.addToHash = function(t) {
                    return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
                }, X.Group.prototype.removeFromHash = function(t) {
                    if (t) {
                        t = this.hash.indexOf(t);
                        if (-1 !== t) return this.hash.splice(t, 1), !0
                    }
                    return !1
                }, X.Group.prototype.addMultiple = function(t, e) {
                    if (t instanceof X.Group) t.moveAll(this, e);
                    else if (Array.isArray(t))
                        for (var i = 0; i < t.length; i++) this.add(t[i], e);
                    return t
                }, X.Group.prototype.getAt = function(t) {
                    return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
                }, X.Group.prototype.create = function(t, e, i, s, n, a) {
                    void 0 === n && (n = !0);
                    s = new this.classType(this.game, t, e, i, s);
                    return s.exists = n, s.visible = n, s.alive = n, this.add(s, !1, a)
                }, X.Group.prototype.createMultiple = function(s, t, e, n) {
                    void 0 === e && (e = 0), void 0 === n && (n = !1), Array.isArray(t) || (t = [t]), Array.isArray(e) || (e = [e]);
                    var a = this,
                        o = [];
                    return t.forEach(function(i) {
                        e.forEach(function(t) {
                            for (var e = 0; e < s; e++) o.push(a.create(0, 0, i, t, n))
                        })
                    }), o
                }, X.Group.prototype.updateZ = function() {
                    for (var t = this.children.length; t--;) this.children[t].z = t
                }, X.Group.prototype.align = function(t, e, i, s, n, a) {
                    if (void 0 === n && (n = X.TOP_LEFT), void 0 === a && (a = 0), 0 === this.children.length || a > this.children.length || -1 === t && -1 === e) return !1;
                    for (var o = new X.Rectangle(0, 0, i, s), r = t * i, h = e * s, l = a; l < this.children.length; l++) {
                        var c = this.children[l];
                        if (c.alignIn)
                            if (c.alignIn(o, n), -1 === t) o.y += s, o.y === h && (o.x += i, o.y = 0);
                            else if (-1 === e) o.x += i, o.x === r && (o.x = 0, o.y += s);
                        else if (o.x += i, o.x === r && (o.x = 0, o.y += s, o.y === h)) return !0
                    }
                    return !0
                }, X.Group.prototype.resetCursor = function(t) {
                    if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
                }, X.Group.prototype.next = function() {
                    if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
                }, X.Group.prototype.previous = function() {
                    if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
                }, X.Group.prototype.swap = function(t, e) {
                    this.swapChildren(t, e), this.updateZ()
                }, X.Group.prototype.bringToTop = function(t) {
                    return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
                }, X.Group.prototype.sendToBack = function(t) {
                    return t.parent === this && 0 < this.getIndex(t) && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
                }, X.Group.prototype.moveUp = function(t) {
                    var e;
                    return t.parent === this && this.getIndex(t) < this.children.length - 1 && (e = this.getIndex(t), (e = this.getAt(e + 1)) && this.swap(t, e)), t
                }, X.Group.prototype.moveDown = function(t) {
                    var e;
                    return t.parent === this && 0 < this.getIndex(t) && (e = this.getIndex(t), (e = this.getAt(e - 1)) && this.swap(t, e)), t
                }, X.Group.prototype.xy = function(t, e, i) {
                    if (t < 0 || t > this.children.length) return -1;
                    this.getChildAt(t).x = e, this.getChildAt(t).y = i
                }, X.Group.prototype.reverse = function() {
                    this.children.reverse(), this.updateZ()
                }, X.Group.prototype.getIndex = function(t) {
                    return this.children.indexOf(t)
                }, X.Group.prototype.getByName = function(t) {
                    for (var e = 0; e < this.children.length; e++)
                        if (this.children[e].name === t) return this.children[e];
                    return null
                }, X.Group.prototype.replace = function(t, e) {
                    var i = this.getIndex(t);
                    if (-1 !== i) return e.parent && (e.parent instanceof X.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t
                }, X.Group.prototype.hasProperty = function(t, e) {
                    var i = e.length;
                    return 1 === i && e[0] in t || 2 === i && e[0] in t && e[1] in t[e[0]] || 3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]
                }, X.Group.prototype.setProperty = function(t, e, i, s, n) {
                    if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || 0 < s)) return !1;
                    n = e.length;
                    return 1 === n ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === n ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === n ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === n && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
                }, X.Group.prototype.checkProperty = function(t, e, i, s) {
                    return void 0 === s && (s = !1), !(!X.Utils.getProperty(t, e) && s) && X.Utils.getProperty(t, e) === i
                }, X.Group.prototype.set = function(t, e, i, s, n, a, o) {
                    if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, a, o)
                }, X.Group.prototype.setAll = function(t, e, i, s, n, a) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), t = t.split("."), n = n || 0;
                    for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, a)
                }, X.Group.prototype.setAllChildren = function(t, e, i, s, n, a) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), n = n || 0;
                    for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && (this.children[o] instanceof X.Group ? this.children[o].setAllChildren(t, e, i, s, n, a) : this.setProperty(this.children[o], t.split("."), e, n, a))
                }, X.Group.prototype.checkAll = function(t, e, i, s, n) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
                    for (var a = 0; a < this.children.length; a++)
                        if ((!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && !this.checkProperty(this.children[a], t, e, n)) return !1;
                    return !0
                }, X.Group.prototype.addAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 1)
                }, X.Group.prototype.subAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 2)
                }, X.Group.prototype.multiplyAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 3)
                }, X.Group.prototype.divideAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 4)
                }, X.Group.prototype.callAllExists = function(t, e) {
                    var i;
                    if (2 < arguments.length) {
                        i = [];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    for (s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
                }, X.Group.prototype.callbackFromArray = function(t, e, i) {
                    if (1 === i) {
                        if (t[e[0]]) return t[e[0]]
                    } else if (2 === i) {
                        if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                    } else if (3 === i) {
                        if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                    } else if (4 === i) {
                        if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                    } else if (t[e]) return t[e];
                    return !1
                }, X.Group.prototype.callAll = function(t, e) {
                    if (void 0 !== t) {
                        var i, s, n = (t = t.split(".")).length;
                        if (null == e || "" === e ? e = null : "string" == typeof e && (i = (e = e.split(".")).length), 2 < arguments.length) {
                            s = [];
                            for (var a = 2; a < arguments.length; a++) s.push(arguments[a])
                        }
                        for (var o, r = null, a = 0; a < this.children.length; a++) r = this.callbackFromArray(this.children[a], t, n), e && r ? (o = this.callbackFromArray(this.children[a], e, i), r && r.apply(o, s)) : r && r.apply(this.children[a], s)
                    }
                }, X.Group.prototype.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (!this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }, X.Group.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, X.Group.prototype.postUpdate = function() {
                    this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, X.Group.prototype.filter = function(t, e) {
                    for (var i = -1, s = this.children.length, n = []; ++i < s;) {
                        var a = this.children[i];
                        (!e || e && a.exists) && t(a, i, this.children) && n.push(a)
                    }
                    return new X.ArraySet(n)
                }, X.Group.prototype.forEach = function(t, e, i) {
                    if (void 0 === i && (i = !1), arguments.length <= 3)
                        for (var s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && t.call(e, this.children[s]);
                    else {
                        for (var n = [null], s = 3; s < arguments.length; s++) n.push(arguments[s]);
                        for (s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && (n[0] = this.children[s], t.apply(e, n))
                    }
                }, X.Group.prototype.forEachExists = function(t, e) {
                    var i;
                    if (2 < arguments.length) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("exists", !0, X.Group.RETURN_TOTAL, t, e, i)
                }, X.Group.prototype.forEachAlive = function(t, e) {
                    var i;
                    if (2 < arguments.length) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !0, X.Group.RETURN_TOTAL, t, e, i)
                }, X.Group.prototype.forEachDead = function(t, e) {
                    var i;
                    if (2 < arguments.length) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !1, X.Group.RETURN_TOTAL, t, e, i)
                }, X.Group.prototype.sort = function(t, e) {
                    this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = X.Group.SORT_ASCENDING), this._sortProperty = t, e === X.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
                }, X.Group.prototype.customSort = function(t, e) {
                    this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
                }, X.Group.prototype.ascendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] || !(t[this._sortProperty] > e[this._sortProperty]) && t.z < e.z ? -1 : 1
                }, X.Group.prototype.descendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
                }, X.Group.prototype.iterate = function(t, e, i, s, n, a) {
                    if (0 === this.children.length) {
                        if (i === X.Group.RETURN_TOTAL) return 0;
                        if (i === X.Group.RETURN_ALL) return []
                    }
                    var o, r = 0;
                    i === X.Group.RETURN_ALL && (o = []);
                    for (var h = 0; h < this.children.length; h++)
                        if (this.children[h][t] === e) {
                            if (r++, s && (a ? (a[0] = this.children[h], s.apply(n, a)) : s.call(n, this.children[h])), i === X.Group.RETURN_CHILD) return this.children[h];
                            i === X.Group.RETURN_ALL && o.push(this.children[h])
                        }
                    return i === X.Group.RETURN_TOTAL ? r : i === X.Group.RETURN_ALL ? o : null
                }, X.Group.prototype.getFirstExists = function(t, e, i, s, n, a) {
                    void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                    t = this.iterate("exists", t, X.Group.RETURN_CHILD);
                    return null === t && e ? this.create(i, s, n, a) : this.resetChild(t, i, s, n, a)
                }, X.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var a = this.iterate("alive", !0, X.Group.RETURN_CHILD);
                    return null === a && t ? this.create(e, i, s, n) : this.resetChild(a, e, i, s, n)
                }, X.Group.prototype.getFirstDead = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var a = this.iterate("alive", !1, X.Group.RETURN_CHILD);
                    return null === a && t ? this.create(e, i, s, n) : this.resetChild(a, e, i, s, n)
                }, X.Group.prototype.resetChild = function(t, e, i, s, n) {
                    return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
                }, X.Group.prototype.getTop = function() {
                    if (0 < this.children.length) return this.children[this.children.length - 1]
                }, X.Group.prototype.getBottom = function() {
                    if (0 < this.children.length) return this.children[0]
                }, X.Group.prototype.getClosestTo = function(t, e, i) {
                    for (var s = Number.MAX_VALUE, n = 0, a = null, o = 0; o < this.children.length; o++) {
                        var r = this.children[o];
                        r.exists && (n = Math.abs(X.Point.distance(t, r))) < s && (!e || e.call(i, r, n)) && (s = n, a = r)
                    }
                    return a
                }, X.Group.prototype.getFurthestFrom = function(t, e, i) {
                    for (var s = 0, n = 0, a = null, o = 0; o < this.children.length; o++) {
                        var r = this.children[o];
                        r.exists && (n = Math.abs(X.Point.distance(t, r))) > s && (!e || e.call(i, r, n)) && (s = n, a = r)
                    }
                    return a
                }, X.Group.prototype.countLiving = function() {
                    return this.iterate("alive", !0, X.Group.RETURN_TOTAL)
                }, X.Group.prototype.countDead = function() {
                    return this.iterate("alive", !1, X.Group.RETURN_TOTAL)
                }, X.Group.prototype.getRandom = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : X.ArrayUtils.getRandomItem(this.children, t, e)
                }, X.Group.prototype.getRandomExists = function(t, e) {
                    e = this.getAll("exists", !0, t, e);
                    return this.game.rnd.pick(e)
                }, X.Group.prototype.getAll = function(t, e, i, s) {
                    void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                    for (var n = [], a = i; a < s; a++) {
                        var o = this.children[a];
                        t && o[t] === e && n.push(o)
                    }
                    return n
                }, X.Group.prototype.remove = function(t, e, i) {
                    if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                    i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                    i = this.removeChild(t);
                    return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && i && i.destroy(!0), !0
                }, X.Group.prototype.moveAll = function(t, e) {
                    if (void 0 === e && (e = !1), 0 < this.children.length && t instanceof X.Group) {
                        for (; t.add(this.children[0], e), 0 < this.children.length;);
                        this.hash = [], this.cursor = null
                    }
                    return t
                }, X.Group.prototype.removeAll = function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                        do {
                            !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                            var s = this.removeChild(this.children[0])
                        } while (this.removeFromHash(s), t && s && s.destroy(!0, i), 0 < this.children.length);
                        this.hash = [], this.cursor = null
                    }
                }, X.Group.prototype.removeBetween = function(t, e, i, s) {
                    if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                        if (e < t || t < 0 || e > this.children.length) return !1;
                        for (var n = e; t <= n;) {
                            !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                            var a = this.removeChild(this.children[n]);
                            this.removeFromHash(a), i && a && a.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                        }
                        this.updateZ()
                    }
                }, X.Group.prototype.destroy = function(t, e) {
                    null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
                }, Object.defineProperty(X.Group.prototype, "total", {
                    get: function() {
                        return this.iterate("exists", !0, X.Group.RETURN_TOTAL)
                    }
                }), Object.defineProperty(X.Group.prototype, "length", {
                    get: function() {
                        return this.children.length
                    }
                }), Object.defineProperty(X.Group.prototype, "angle", {
                    get: function() {
                        return X.Math.radToDeg(this.rotation)
                    },
                    set: function(t) {
                        this.rotation = X.Math.degToRad(t)
                    }
                }), Object.defineProperty(X.Group.prototype, "centerX", {
                    get: function() {
                        return this.getBounds(this.parent).centerX
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.halfWidth
                    }
                }), Object.defineProperty(X.Group.prototype, "centerY", {
                    get: function() {
                        return this.getBounds(this.parent).centerY
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.halfHeight
                    }
                }), Object.defineProperty(X.Group.prototype, "left", {
                    get: function() {
                        return this.getBounds(this.parent).left
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            e = this.x - e.x;
                        this.x = t + e
                    }
                }), Object.defineProperty(X.Group.prototype, "right", {
                    get: function() {
                        return this.getBounds(this.parent).right
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.width
                    }
                }), Object.defineProperty(X.Group.prototype, "top", {
                    get: function() {
                        return this.getBounds(this.parent).top
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            e = this.y - e.y;
                        this.y = t + e
                    }
                }), Object.defineProperty(X.Group.prototype, "bottom", {
                    get: function() {
                        return this.getBounds(this.parent).bottom
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.height
                    }
                }), X.World = function(t) {
                    X.Group.call(this, t, null, "__world", !1), this.bounds = new X.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
                }, X.World.prototype = Object.create(X.Group.prototype), X.World.prototype.constructor = X.World, X.World.prototype.boot = function() {
                    this.camera = new X.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
                }, X.World.prototype.stateChange = function() {
                    this.x = 0, this.y = 0, this.camera.reset()
                }, X.World.prototype.setBounds = function(t, e, i, s) {
                    this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
                }, X.World.prototype.resize = function(t, e) {
                    this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
                }, X.World.prototype.shutdown = function() {
                    this.destroy(!0, !0)
                }, X.World.prototype.wrap = function(t, e, i, s, n) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
                }, Object.defineProperty(X.World.prototype, "width", {
                    get: function() {
                        return this.bounds.width
                    },
                    set: function(t) {
                        t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                    }
                }), Object.defineProperty(X.World.prototype, "height", {
                    get: function() {
                        return this.bounds.height
                    },
                    set: function(t) {
                        t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                    }
                }), Object.defineProperty(X.World.prototype, "centerX", {
                    get: function() {
                        return this.bounds.halfWidth + this.bounds.x
                    }
                }), Object.defineProperty(X.World.prototype, "centerY", {
                    get: function() {
                        return this.bounds.halfHeight + this.bounds.y
                    }
                }), Object.defineProperty(X.World.prototype, "randomX", {
                    get: function() {
                        return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                    }
                }), Object.defineProperty(X.World.prototype, "randomY", {
                    get: function() {
                        return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                    }
                }), X.Game = function(t, e, i, s, n, a, o, r) {
                    return this.id = X.GAMES.push(this) - 1, this.config = null, this.physicsConfig = r, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = X.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = X.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new X.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof t ? this.parseConfig(t) : (this.config = {
                        enableDebug: !0
                    }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== s && (this.parent = s), void 0 !== a && (this.transparent = a), void 0 !== o && (this.antialias = o), this.rnd = new X.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new X.StateManager(this, n)), this.device.whenReady(this.boot, this), this
                }, X.Game.prototype = {
                    parseConfig: function(t) {
                        void 0 === (this.config = t).enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                        var e = [(Date.now() * Math.random()).toString()];
                        t.seed && (e = t.seed), this.rnd = new X.RandomDataGenerator(e);
                        e = null;
                        t.state && (e = t.state), this.state = new X.StateManager(this, e)
                    },
                    boot: function() {
                        this.isBooted || (this.onPause = new X.Signal, this.onResume = new X.Signal, this.onBlur = new X.Signal, this.onFocus = new X.Signal, this.isBooted = !0, (PIXI.game = this).math = X.Math, this.scale = new X.ScaleManager(this, this._width, this._height), this.stage = new X.Stage(this), this.setUpRenderer(), this.world = new X.World(this), this.add = new X.GameObjectFactory(this), this.make = new X.GameObjectCreator(this), this.cache = new X.Cache(this), this.load = new X.Loader(this), this.time = new X.Time(this), this.tweens = new X.TweenManager(this), this.input = new X.Input(this), this.sound = new X.SoundManager(this), this.physics = new X.Physics(this, this.physicsConfig), this.particles = new X.Particles(this), this.create = new X.Create(this), this.plugins = new X.PluginManager(this), this.net = new X.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new X.Utils.Debug(this), this.debug.boot()) : this.debug = {
                            preUpdate: function() {},
                            update: function() {},
                            reset: function() {}
                        }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new X.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new X.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
                    },
                    showDebugHeader: function() {
                        if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                            var t = X.VERSION,
                                e = "Canvas",
                                i = "HTML Audio",
                                s = 1;
                            if (this.renderType === X.WEBGL ? (e = "WebGL", s++) : this.renderType === X.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.chrome)
                                for (var n = ["%c %c %c @orange-games/phaser v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c http://phaser.io %câ¥%câ¥%câ¥", "background: #F47820", "background: #ED873F", "color: #ffffff; background: #DD6612;", "background: #ED873F", "background: #F47820", "background: #ffffff"], a = 0; a < 3; a++) a < s ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                            else window.console
                        }
                    },
                    setUpRenderer: function() {
                        if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = X.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === X.HEADLESS || this.renderType === X.CANVAS || this.renderType === X.AUTO && !this.device.webGL) {
                            if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                            this.renderType = X.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                        } else this.renderType = X.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                        this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === X.CANVAS), this.renderType !== X.HEADLESS && (this.stage.smoothed = this.antialias, X.Canvas.addToDOM(this.canvas, this.parent, !1), X.Canvas.setTouchAction(this.canvas))
                    },
                    contextLost: function(t) {
                        t.preventDefault(), this.renderer.contextLost = !0
                    },
                    contextRestored: function() {
                        this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                    },
                    update: function(t) {
                        if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                        if (1 < this._spiraling && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                        else {
                            var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                            this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                            var i = 0;
                            for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                            i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                        }
                    },
                    updateLogic: function(t) {
                        this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                    },
                    updateRender: function(t) {
                        this.lockRender || (this.state.preRender(t), this.renderType !== X.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
                    },
                    enableStep: function() {
                        this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                    },
                    disableStep: function() {
                        this.stepping = !1, this.pendingStep = !1
                    },
                    step: function() {
                        this.pendingStep = !1, this.stepCount++
                    },
                    destroy: function() {
                        this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), X.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, X.GAMES[this.id] = null
                    },
                    gamePaused: function(t) {
                        this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                    },
                    gameResumed: function(t) {
                        this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                    },
                    focusLoss: function(t) {
                        this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                    },
                    focusGain: function(t) {
                        this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                    }
                }, X.Game.prototype.constructor = X.Game, Object.defineProperty(X.Game.prototype, "paused", {
                    get: function() {
                        return this._paused
                    },
                    set: function(t) {
                        !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                    }
                }), X.Input = function(t) {
                    this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = X.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new X.ArraySet, this._localPoint = new X.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
                }, X.Input.MOUSE_OVERRIDES_TOUCH = 0, X.Input.TOUCH_OVERRIDES_MOUSE = 1, X.Input.MOUSE_TOUCH_COMBINE = 2, X.Input.MAX_POINTERS = 10, X.Input.prototype = {
                    boot: function() {
                        this.mousePointer = new X.Pointer(this.game, 0, X.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new X.Mouse(this.game), this.touch = new X.Touch(this.game), this.mspointer = new X.MSPointer(this.game), X.Keyboard && (this.keyboard = new X.Keyboard(this.game)), X.Gamepad && (this.gamepad = new X.Gamepad(this.game)), this.onDown = new X.Signal, this.onUp = new X.Signal, this.onTap = new X.Signal, this.onHold = new X.Signal, this.scale = new X.Point(1, 1), this.speed = new X.Point, this.position = new X.Point, this._oldPosition = new X.Point, this.circle = new X.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                        var e = this;
                        this._onClickTrampoline = function(t) {
                            e.onClickTrampoline(t)
                        }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                    },
                    destroy: function() {
                        this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                    },
                    setInteractiveCandidateHandler: function(t, e) {
                        this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                    },
                    addMoveCallback: function(t, e) {
                        this.moveCallbacks.push({
                            callback: t,
                            context: e
                        })
                    },
                    deleteMoveCallback: function(t, e) {
                        for (var i = this.moveCallbacks.length; i--;)
                            if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                    },
                    addPointer: function() {
                        if (this.pointers.length >= X.Input.MAX_POINTERS) return null;
                        var t = this.pointers.length + 1,
                            e = new X.Pointer(this.game, t, X.PointerMode.TOUCH);
                        return this.pointers.push(e), this["pointer" + t] = e
                    },
                    update: function() {
                        if (this.keyboard && this.keyboard.update(), 0 < this.pollRate && this._pollCounter < this.pollRate) this._pollCounter++;
                        else {
                            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                            for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                            this._pollCounter = 0
                        }
                    },
                    reset: function(t) {
                        if (this.game.isBooted && !this.resetLocked) {
                            void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                            for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                            "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new X.Signal, this.onUp = new X.Signal, this.onTap = new X.Signal, this.onHold = new X.Signal, this.moveCallbacks = []), this._pollCounter = 0
                        }
                    },
                    resetSpeed: function(t, e) {
                        this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                    },
                    startPointer: function(t) {
                        if (0 <= this.maxPointers && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                        if (!this.pointer1.active) return this.pointer1.start(t);
                        if (!this.pointer2.active) return this.pointer2.start(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (!i.active) return i.start(t)
                        }
                        return null
                    },
                    updatePointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.move(t)
                        }
                        return null
                    },
                    stopPointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.stop(t)
                        }
                        return null
                    },
                    countActivePointers: function(t) {
                        void 0 === t && (t = this.pointers.length);
                        for (var e = t, i = 0; i < this.pointers.length && 0 < e; i++) this.pointers[i].active && e--;
                        return t - e
                    },
                    getPointer: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active === t) return i
                        }
                        return null
                    },
                    getPointerFromIdentifier: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.identifier === t) return i
                        }
                        return null
                    },
                    getPointerFromId: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.pointerId === t) return i
                        }
                        return null
                    },
                    getLocalPosition: function(t, e, i) {
                        void 0 === i && (i = new X.Point);
                        var s = t.worldTransform,
                            t = 1 / (s.a * s.d + s.c * -s.b);
                        return i.setTo(s.d * t * e.x + -s.c * t * e.y + (s.ty * s.c - s.tx * s.d) * t, s.a * t * e.y + -s.b * t * e.x + (-s.ty * s.a + s.tx * s.b) * t)
                    },
                    hitTest: function(t, e, i) {
                        if (!t.worldVisible) return !1;
                        if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                        if (t instanceof X.TileSprite) {
                            var s = t.width,
                                n = t.height,
                                a = -s * t.anchor.x;
                            if (this._localPoint.x >= a && this._localPoint.x < a + s) {
                                var o = -n * t.anchor.y;
                                if (this._localPoint.y >= o && this._localPoint.y < o + n) return !0
                            }
                        } else if (t instanceof PIXI.Sprite) {
                            s = t.texture.frame.width, n = t.texture.frame.height, a = -s * t.anchor.x;
                            if (this._localPoint.x >= a && this._localPoint.x < a + s) {
                                o = -n * t.anchor.y;
                                if (this._localPoint.y >= o && this._localPoint.y < o + n) return !0
                            }
                        } else if (t instanceof X.Graphics)
                            for (var r = 0; r < t.graphicsData.length; r++) {
                                var h = t.graphicsData[r];
                                if (h.fill && h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y)) return !0
                            }
                        for (r = 0; r < t.children.length; r++)
                            if (this.hitTest(t.children[r], e, i)) return !0;
                        return !1
                    },
                    onClickTrampoline: function() {
                        this.activePointer.processClickTrampolines()
                    }
                }, X.Input.prototype.constructor = X.Input, Object.defineProperty(X.Input.prototype, "x", {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = Math.floor(t)
                    }
                }), Object.defineProperty(X.Input.prototype, "y", {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = Math.floor(t)
                    }
                }), Object.defineProperty(X.Input.prototype, "pollLocked", {
                    get: function() {
                        return 0 < this.pollRate && this._pollCounter < this.pollRate
                    }
                }), Object.defineProperty(X.Input.prototype, "totalInactivePointers", {
                    get: function() {
                        return this.pointers.length - this.countActivePointers()
                    }
                }), Object.defineProperty(X.Input.prototype, "totalActivePointers", {
                    get: function() {
                        return this.countActivePointers()
                    }
                }), Object.defineProperty(X.Input.prototype, "worldX", {
                    get: function() {
                        return this.game.camera.view.x + this.x
                    }
                }), Object.defineProperty(X.Input.prototype, "worldY", {
                    get: function() {
                        return this.game.camera.view.y + this.y
                    }
                }), X.Mouse = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new X.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
                }, X.Mouse.NO_BUTTON = -1, X.Mouse.LEFT_BUTTON = 0, X.Mouse.MIDDLE_BUTTON = 1, X.Mouse.RIGHT_BUTTON = 2, X.Mouse.BACK_BUTTON = 3, X.Mouse.FORWARD_BUTTON = 4, X.Mouse.WHEEL_UP = 1, X.Mouse.WHEEL_DOWN = -1, X.Mouse.prototype = {
                    start: function() {
                        var e, t, i;
                        this.game.device.android && !1 === this.game.device.chrome || null !== this._onMouseDown || ((e = this)._onMouseDown = function(t) {
                            return e.onMouseDown(t)
                        }, this._onMouseMove = function(t) {
                            return e.onMouseMove(t)
                        }, this._onMouseUp = function(t) {
                            return e.onMouseUp(t)
                        }, this._onMouseUpGlobal = function(t) {
                            return e.onMouseUpGlobal(t)
                        }, this._onMouseOutGlobal = function(t) {
                            return e.onMouseOutGlobal(t)
                        }, this._onMouseOut = function(t) {
                            return e.onMouseOut(t)
                        }, this._onMouseOver = function(t) {
                            return e.onMouseOver(t)
                        }, this._onMouseWheel = function(t) {
                            return e.onMouseWheel(t)
                        }, (t = this.game.canvas).addEventListener("mousedown", this._onMouseDown, !0), t.addEventListener("mousemove", this._onMouseMove, !0), t.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), t.addEventListener("mouseover", this._onMouseOver, !0), t.addEventListener("mouseout", this._onMouseOut, !0)), (i = this.game.device.wheelEvent) && (t.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new s(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1, 1))))
                    },
                    onMouseDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                    },
                    onMouseMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                    },
                    onMouseUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseUpGlobal: function(t) {
                        this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOutGlobal: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
                    },
                    onMouseOut: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOver: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
                    },
                    onMouseWheel: function(t) {
                        this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = X.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                    },
                    requestPointerLock: function() {
                        var t, e;
                        this.game.device.pointerLock && ((t = this.game.canvas).requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock(), (e = this)._pointerLockChange = function(t) {
                            return e.pointerLockChange(t)
                        }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0))
                    },
                    pointerLockChange: function(t) {
                        var e = this.game.canvas;
                        document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                    },
                    releasePointerLock: function() {
                        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                        var e = this.game.device.wheelEvent;
                        e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                }, X.Mouse.prototype.constructor = X.Mouse, ((s.prototype = {}).constructor = s).prototype.bindEvent = function(t) {
                    if (!s._stubsGenerated && t) {
                        for (var e in t) e in s.prototype || Object.defineProperty(s.prototype, e, {
                            get: function(e) {
                                return function() {
                                    var t = this.originalEvent[e];
                                    return "function" != typeof t ? t : t.bind(this.originalEvent)
                                }
                            }(e)
                        });
                        s._stubsGenerated = !0
                    }
                    return this.originalEvent = t, this
                }, Object.defineProperties(s.prototype, {
                    type: {
                        value: "wheel"
                    },
                    deltaMode: {
                        get: function() {
                            return this._deltaMode
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                        }
                    },
                    deltaX: {
                        get: function() {
                            return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                        }
                    },
                    deltaZ: {
                        value: 0
                    }
                }), X.MSPointer = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
                }, X.MSPointer.prototype = {
                    start: function() {
                        var e, t;
                        null !== this._onMSPointerDown || (e = this).game.device.mspointer && (this._onMSPointerDown = function(t) {
                            return e.onPointerDown(t)
                        }, this._onMSPointerMove = function(t) {
                            return e.onPointerMove(t)
                        }, this._onMSPointerUp = function(t) {
                            return e.onPointerUp(t)
                        }, this._onMSPointerUpGlobal = function(t) {
                            return e.onPointerUpGlobal(t)
                        }, this._onMSPointerOut = function(t) {
                            return e.onPointerOut(t)
                        }, this._onMSPointerOver = function(t) {
                            return e.onPointerOver(t)
                        }, (t = this.game.canvas).addEventListener("MSPointerDown", this._onMSPointerDown, !1), t.addEventListener("MSPointerMove", this._onMSPointerMove, !1), t.addEventListener("MSPointerUp", this._onMSPointerUp, !1), t.addEventListener("pointerdown", this._onMSPointerDown, !1), t.addEventListener("pointermove", this._onMSPointerMove, !1), t.addEventListener("pointerup", this._onMSPointerUp, !1), t.style["-ms-content-zooming"] = "none", t.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.addEventListener("MSPointerOver", this._onMSPointerOver, !0), t.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.addEventListener("pointerover", this._onMSPointerOver, !0), t.addEventListener("pointerout", this._onMSPointerOut, !0)))
                    },
                    onPointerDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                    },
                    onPointerMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                    },
                    onPointerUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                    },
                    onPointerUpGlobal: function(t) {
                        var e;
                        (!("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) || (e = this.input.getPointerFromIdentifier(t.identifier)) && e.withinGame) && this.onPointerUp(t)
                    },
                    onPointerOut: function(t) {
                        var e;
                        this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.withinGame = !1 : (e = this.input.getPointerFromIdentifier(t.identifier)) && (e.withinGame = !1), this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, (e || this.input.mousePointer).stop(t))
                    },
                    onPointerOver: function(t) {
                        var e;
                        this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.withinGame = !0 : (e = this.input.getPointerFromIdentifier(t.identifier)) && (e.withinGame = !0), this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
                    }
                }, X.MSPointer.prototype.constructor = X.MSPointer, X.DeviceButton = function(t, e) {
                    this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new X.Signal, this.onUp = new X.Signal, this.onFloat = new X.Signal
                }, X.DeviceButton.prototype = {
                    start: function(t, e) {
                        this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                    },
                    stop: function(t, e) {
                        this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                    },
                    padFloat: function(t) {
                        this.value = t, this.onFloat.dispatch(this, t)
                    },
                    justPressed: function(t) {
                        return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    reset: function() {
                        this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                    },
                    destroy: function() {
                        this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                    }
                }, X.DeviceButton.prototype.constructor = X.DeviceButton, Object.defineProperty(X.DeviceButton.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), X.Pointer = function(t, e, i) {
                    this.game = t, this.id = e, this.type = X.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || X.PointerMode.CURSOR | X.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new X.DeviceButton(this, X.Pointer.LEFT_BUTTON), this.middleButton = new X.DeviceButton(this, X.Pointer.MIDDLE_BUTTON), this.rightButton = new X.DeviceButton(this, X.Pointer.RIGHT_BUTTON), this.backButton = new X.DeviceButton(this, X.Pointer.BACK_BUTTON), this.forwardButton = new X.DeviceButton(this, X.Pointer.FORWARD_BUTTON), this.eraserButton = new X.DeviceButton(this, X.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new X.Point, this.positionDown = new X.Point, this.positionUp = new X.Point, this.circle = new X.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
                }, X.Pointer.NO_BUTTON = 0, X.Pointer.LEFT_BUTTON = 1, X.Pointer.RIGHT_BUTTON = 2, X.Pointer.MIDDLE_BUTTON = 4, X.Pointer.BACK_BUTTON = 8, X.Pointer.FORWARD_BUTTON = 16, X.Pointer.ERASER_BUTTON = 32, X.Pointer.prototype = {
                    resetButtons: function() {
                        this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                    },
                    processButtonsDown: function(t, e) {
                        X.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), X.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), X.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), X.Pointer.BACK_BUTTON & t && this.backButton.start(e), X.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), X.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
                    },
                    processButtonsUp: function(t, e) {
                        t === X.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === X.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === X.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === X.Mouse.BACK_BUTTON && this.backButton.stop(e), t === X.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
                    },
                    updateButtons: function(t) {
                        this.button = t.button;
                        var e = "down" === t.type.toLowerCase().substr(-4);
                        void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                    },
                    start: function(t) {
                        var e = this.game.input;
                        return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === X.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === X.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === X.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                    },
                    update: function() {
                        var t = this.game.input;
                        this.active && (this.dirty && (0 < t.interactiveItems.total && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === X.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === X.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === X.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                            x: this.position.x,
                            y: this.position.y
                        }), this._history.length > t.recordLimit && this._history.shift()))
                    },
                    move: function(t, e) {
                        var i = this.game.input;
                        if (!i.pollLocked) {
                            if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === X.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === X.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === X.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                            for (var s = i.moveCallbacks.length; s--;) i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e);
                            return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : 0 < i.interactiveItems.total && this.processInteractiveObjects(e), this
                        }
                    },
                    processInteractiveObjects: function(t) {
                        var e = 0,
                            i = -1,
                            s = null,
                            n = this.game.input.interactiveItems.first;
                        for (this.interactiveCandidates = []; n;) n.checked = !1, n.validForInput(i, e, !1) && (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                        for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                        return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                    },
                    swapTarget: function(t, e) {
                        void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t)._pointerOverHandler(this, e) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                    },
                    leave: function(t) {
                        this.withinGame = !1, this.move(t, !1)
                    },
                    stop: function(t) {
                        var e = this.game.input;
                        return this._stateReset && this.withinGame ? void t.preventDefault() : (this.timeUp = this.game.time.time, (e.multiInputOverride === X.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === X.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === X.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), 0 <= this.duration && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), 0 < this.id && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
                    },
                    justPressed: function(t) {
                        return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    addClickTrampoline: function(t, e, i, s) {
                        if (this.isDown) {
                            for (var n = this._clickTrampolines = this._clickTrampolines || [], a = 0; a < n.length; a++)
                                if (n[a].name === t) {
                                    n.splice(a, 1);
                                    break
                                }
                            n.push({
                                name: t,
                                targetObject: this.targetObject,
                                callback: e,
                                callbackContext: i,
                                callbackArgs: s
                            })
                        }
                    },
                    processClickTrampolines: function() {
                        var t = this._clickTrampolines;
                        if (t) {
                            for (var e = 0; e < t.length; e++) {
                                var i = t[e];
                                i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                            }
                            this._clickTrampolines = null, this._trampolineTargetObject = null
                        }
                    },
                    reset: function() {
                        !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                    },
                    resetMovement: function() {
                        this.movementX = 0, this.movementY = 0
                    }
                }, X.Pointer.prototype.constructor = X.Pointer, Object.defineProperty(X.Pointer.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), Object.defineProperty(X.Pointer.prototype, "worldX", {
                    get: function() {
                        return this.game.world.camera.x + this.x
                    }
                }), Object.defineProperty(X.Pointer.prototype, "worldY", {
                    get: function() {
                        return this.game.world.camera.y + this.y
                    }
                }), X.PointerMode = {
                    CURSOR: 1,
                    CONTACT: 2
                }, X.Touch = function(t) {
                    this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
                }, X.Touch.prototype = {
                    start: function() {
                        var e;
                        null !== this._onTouchStart || (e = this).game.device.touch && (this._onTouchStart = function(t) {
                            return e.onTouchStart(t)
                        }, this._onTouchMove = function(t) {
                            return e.onTouchMove(t)
                        }, this._onTouchEnd = function(t) {
                            return e.onTouchEnd(t)
                        }, this._onTouchEnter = function(t) {
                            return e.onTouchEnter(t)
                        }, this._onTouchLeave = function(t) {
                            return e.onTouchLeave(t)
                        }, this._onTouchCancel = function(t) {
                            return e.onTouchCancel(t)
                        }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                    },
                    consumeDocumentTouches: function() {
                        this._documentTouchMove = function(t) {
                            t.preventDefault()
                        }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                    },
                    addTouchLockCallback: function(t, e, i) {
                        void 0 === i && (i = !1), this.touchLockCallbacks.push({
                            callback: t,
                            context: e,
                            onEnd: i
                        })
                    },
                    removeTouchLockCallback: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;)
                            if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                        return !1
                    },
                    onTouchStart: function(t) {
                        for (var e = this.touchLockCallbacks.length; e--;) {
                            var i = this.touchLockCallbacks[e];
                            !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                        }
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                            for (e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                        }
                    },
                    onTouchCancel: function(t) {
                        if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                            this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                        }
                    },
                    onTouchEnter: function(t) {
                        this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                    },
                    onTouchLeave: function(t) {
                        this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                    },
                    onTouchMove: function(t) {
                        this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                    },
                    onTouchEnd: function(t) {
                        for (var e = this.touchLockCallbacks.length; e--;) {
                            var i = this.touchLockCallbacks[e];
                            i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                        }
                        this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    },
                    stop: function() {
                        this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                    }
                }, X.Touch.prototype.constructor = X.Touch, X.InputHandler = function(t) {
                    this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new X.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new X.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new X.Point, this.snapPoint = new X.Point, this._dragPoint = new X.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new X.Point, this._pointerData = [], this._pointerData.push({
                        id: 0,
                        x: 0,
                        y: 0,
                        camX: 0,
                        camY: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    })
                }, X.InputHandler.prototype = {
                    start: function(t, e) {
                        if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                            this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                            for (var i = 0; i < 10; i++) this._pointerData[i] = {
                                id: i,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            };
                            this.snapOffset = new X.Point, this.enabled = !0, this._wasEnabled = !0
                        }
                        return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                    },
                    addedToGroup: function() {
                        this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                    },
                    removedFromGroup: function() {
                        this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                    },
                    reset: function() {
                        this.enabled = !1;
                        for (var t = 0; t < 10; t++) this._pointerData[t] = {
                            id: t,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        }
                    },
                    stop: function() {
                        !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                    },
                    destroy: function() {
                        this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                    },
                    validForInput: function(t, e, i) {
                        return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput || !i && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                    },
                    isPixelPerfect: function() {
                        return this.pixelPerfectClick || this.pixelPerfectOver
                    },
                    pointerX: function(t) {
                        return t = t || 0, this._pointerData[t].x
                    },
                    pointerY: function(t) {
                        return t = t || 0, this._pointerData[t].y
                    },
                    pointerDown: function(t) {
                        return t = t || 0, this._pointerData[t].isDown
                    },
                    pointerUp: function(t) {
                        return t = t || 0, this._pointerData[t].isUp
                    },
                    pointerTimeDown: function(t) {
                        return t = t || 0, this._pointerData[t].timeDown
                    },
                    pointerTimeUp: function(t) {
                        return t = t || 0, this._pointerData[t].timeUp
                    },
                    pointerOver: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 !== t) return this._pointerData[t].isOver;
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOver) return !0;
                        return !1
                    },
                    pointerOut: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 !== t) return this._pointerData[t].isOut;
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOut) return !0
                    },
                    pointerTimeOver: function(t) {
                        return t = t || 0, this._pointerData[t].timeOver
                    },
                    pointerTimeOut: function(t) {
                        return t = t || 0, this._pointerData[t].timeOut
                    },
                    pointerDragged: function(t) {
                        return t = t || 0, this._pointerData[t].isDragged
                    },
                    checkPointerDown: function(t, e) {
                        return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                    },
                    checkPointerOver: function(t, e) {
                        return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                    },
                    checkPixel: function(t, e, i) {
                        if (this.sprite.texture.baseTexture.source) {
                            if (null === t && null === e && (this.game.input.getLocalPosition(this.sprite, i, this._tempPoint), t = this._tempPoint.x, e = this._tempPoint.y), 0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                            if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                        }
                        return !1
                    },
                    update: function(t) {
                        if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = X.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                    },
                    _pointerOverHandler: function(t, e) {
                        var i, s;
                        null !== this.sprite && (!1 !== (i = this._pointerData[t.id]).isOver && !t.dirty || (s = !1 === i.isOver, i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === X.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)))
                    },
                    _pointerOutHandler: function(t, e) {
                        var i;
                        null !== this.sprite && ((i = this._pointerData[t.id]).isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === X.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t)))
                    },
                    _touchedHandler: function(t) {
                        var e;
                        null === this.sprite || !(e = this._pointerData[t.id]).isDown && e.isOver && (this.pixelPerfectClick && !this.checkPixel(null, null, t) || (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === X.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite) || (this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, 0 < this.dragTimeThreshold ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop())))
                    },
                    dragTimeElapsed: function(t) {
                        this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                    },
                    _releasedHandler: function(t) {
                        var e, i;
                        null === this.sprite || (e = this._pointerData[t.id]).isDown && t.isUp && (e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown, i = this.checkPointerOver(t), this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.type === X.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i = i && this.checkPointerOver(t)), !(e.isOver = i) && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t))
                    },
                    updateDrag: function(t, e) {
                        if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                        var i, s, n = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                            a = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                        return this.sprite.fixedToCamera ? (this.allowHorizontalDrag && (this.sprite.cameraOffset.x = n), this.allowVerticalDrag && (this.sprite.cameraOffset.y = a), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y))) : (i = this.game.camera.x - this._pointerData[t.id].camX, s = this.game.camera.y - this._pointerData[t.id].camY, this.allowHorizontalDrag && (this.sprite.x = n + i), this.allowVerticalDrag && (this.sprite.y = a + s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))), this.sprite.events.onDragUpdate.dispatch(this.sprite, t, n, a, this.snapPoint, e), !0
                    },
                    justOver: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                    },
                    justOut: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                    },
                    justPressed: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                    },
                    justReleased: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                    },
                    overDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                    },
                    downDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                    },
                    enableDrag: function(t, e, i, s, n, a) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 255), void 0 === n && (n = null), void 0 === a && (a = null), this._dragPoint = new X.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new X.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, n && (this.boundsRect = n), a && (this.boundsSprite = a)
                    },
                    disableDrag: function() {
                        if (this._pointerData)
                            for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                        this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                    },
                    startDrag: function(t) {
                        var e, i = this.sprite.x,
                            s = this.sprite.y;
                        this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera ? (this.dragFromCenter && (e = this.sprite.getBounds(), this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - e.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - e.centerY)), this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)) : (this.dragFromCenter && (e = this.sprite.getBounds(), this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - e.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - e.centerY)), this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))), this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(i, s), this.sprite.events.onDragStart$dispatch(this.sprite, t, i, s), this._pendingDrag = !1
                    },
                    globalToLocalX: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                    },
                    globalToLocalY: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                    },
                    stopDrag: function(t) {
                        this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                    },
                    setDragLock: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                    },
                    enableSnap: function(t, e, i, s, n, a) {
                        void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = a, this.snapOnDrag = i, this.snapOnRelease = s
                    },
                    disableSnap: function() {
                        this.snapOnDrag = !1, this.snapOnRelease = !1
                    },
                    checkBoundsRect: function() {
                        this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                    },
                    checkBoundsSprite: function() {
                        this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                    }
                }, X.InputHandler.prototype.constructor = X.InputHandler, X.Gamepad = function(t) {
                    this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new X.SinglePad(t, this), new X.SinglePad(t, this), new X.SinglePad(t, this), new X.SinglePad(t, this)]
                }, X.Gamepad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    start: function() {
                        var e;
                        this._active || (this._active = !0, (e = this)._onGamepadConnected = function(t) {
                            return e.onGamepadConnected(t)
                        }, this._onGamepadDisconnected = function(t) {
                            return e.onGamepadDisconnected(t)
                        }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1))
                    },
                    onGamepadConnected: function(t) {
                        t = t.gamepad;
                        this._rawPads.push(t), this._gamepads[t.index].connect(t)
                    },
                    onGamepadDisconnected: function(t) {
                        var e, i = t.gamepad;
                        for (e in this._rawPads) this._rawPads[e].index === i.index && this._rawPads.splice(e, 1);
                        this._gamepads[i.index].disconnect()
                    },
                    update: function() {
                        this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                    },
                    _pollGamepads: function() {
                        var t;
                        if (this._active && (navigator.getGamepads ? t = navigator.getGamepads() : navigator.webkitGetGamepads ? t = navigator.webkitGetGamepads() : navigator.webkitGamepads && (t = navigator.webkitGamepads()), t)) {
                            for (var e = !(this._rawPads = []), i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                            for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                            if (e) {
                                for (var n, a = {
                                        rawIndices: {},
                                        padIndices: {}
                                    }, o = 0; o < this._gamepads.length; o++)
                                    if ((n = this._gamepads[o]).connected)
                                        for (var r = 0; r < this._rawPads.length; r++) this._rawPads[r].index === n.index && (a.rawIndices[n.index] = !0, a.padIndices[o] = !0);
                                for (var h = 0; h < this._gamepads.length; h++)
                                    if (n = this._gamepads[h], !a.padIndices[h]) {
                                        this._rawPads.length < 1 && n.disconnect();
                                        for (var l = 0; l < this._rawPads.length && !a.padIndices[h]; l++) {
                                            var c = this._rawPads[l];
                                            !c || a.rawIndices[c.index] ? n.disconnect() : (n.connect(c), a.rawIndices[c.index] = !0, a.padIndices[h] = !0)
                                        }
                                    }
                            }
                        }
                    },
                    setDeadZones: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                    },
                    stop: function() {
                        this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                    },
                    reset: function() {
                        this.update();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                    },
                    justPressed: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                        return !1
                    },
                    justReleased: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                        return !1
                    },
                    isDown: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++)
                            if (!0 === this._gamepads[e].isDown(t)) return !0;
                        return !1
                    },
                    destroy: function() {
                        this.stop();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                    }
                }, X.Gamepad.prototype.constructor = X.Gamepad, Object.defineProperty(X.Gamepad.prototype, "active", {
                    get: function() {
                        return this._active
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "supported", {
                    get: function() {
                        return this._gamepadSupportAvailable
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "padsConnected", {
                    get: function() {
                        return this._rawPads.length
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "pad1", {
                    get: function() {
                        return this._gamepads[0]
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "pad2", {
                    get: function() {
                        return this._gamepads[1]
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "pad3", {
                    get: function() {
                        return this._gamepads[2]
                    }
                }), Object.defineProperty(X.Gamepad.prototype, "pad4", {
                    get: function() {
                        return this._gamepads[3]
                    }
                }), X.Gamepad.BUTTON_0 = 0, X.Gamepad.BUTTON_1 = 1, X.Gamepad.BUTTON_2 = 2, X.Gamepad.BUTTON_3 = 3, X.Gamepad.BUTTON_4 = 4, X.Gamepad.BUTTON_5 = 5, X.Gamepad.BUTTON_6 = 6, X.Gamepad.BUTTON_7 = 7, X.Gamepad.BUTTON_8 = 8, X.Gamepad.BUTTON_9 = 9, X.Gamepad.BUTTON_10 = 10, X.Gamepad.BUTTON_11 = 11, X.Gamepad.BUTTON_12 = 12, X.Gamepad.BUTTON_13 = 13, X.Gamepad.BUTTON_14 = 14, X.Gamepad.BUTTON_15 = 15, X.Gamepad.AXIS_0 = 0, X.Gamepad.AXIS_1 = 1, X.Gamepad.AXIS_2 = 2, X.Gamepad.AXIS_3 = 3, X.Gamepad.AXIS_4 = 4, X.Gamepad.AXIS_5 = 5, X.Gamepad.AXIS_6 = 6, X.Gamepad.AXIS_7 = 7, X.Gamepad.AXIS_8 = 8, X.Gamepad.AXIS_9 = 9, X.Gamepad.XBOX360_A = 0, X.Gamepad.XBOX360_B = 1, X.Gamepad.XBOX360_X = 2, X.Gamepad.XBOX360_Y = 3, X.Gamepad.XBOX360_LEFT_BUMPER = 4, X.Gamepad.XBOX360_RIGHT_BUMPER = 5, X.Gamepad.XBOX360_LEFT_TRIGGER = 6, X.Gamepad.XBOX360_RIGHT_TRIGGER = 7, X.Gamepad.XBOX360_BACK = 8, X.Gamepad.XBOX360_START = 9, X.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, X.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, X.Gamepad.XBOX360_DPAD_LEFT = 14, X.Gamepad.XBOX360_DPAD_RIGHT = 15, X.Gamepad.XBOX360_DPAD_UP = 12, X.Gamepad.XBOX360_DPAD_DOWN = 13, X.Gamepad.XBOX360_STICK_LEFT_X = 0, X.Gamepad.XBOX360_STICK_LEFT_Y = 1, X.Gamepad.XBOX360_STICK_RIGHT_X = 2, X.Gamepad.XBOX360_STICK_RIGHT_Y = 3, X.Gamepad.PS3XC_X = 0, X.Gamepad.PS3XC_CIRCLE = 1, X.Gamepad.PS3XC_SQUARE = 2, X.Gamepad.PS3XC_TRIANGLE = 3, X.Gamepad.PS3XC_L1 = 4, X.Gamepad.PS3XC_R1 = 5, X.Gamepad.PS3XC_L2 = 6, X.Gamepad.PS3XC_R2 = 7, X.Gamepad.PS3XC_SELECT = 8, X.Gamepad.PS3XC_START = 9, X.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, X.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, X.Gamepad.PS3XC_DPAD_UP = 12, X.Gamepad.PS3XC_DPAD_DOWN = 13, X.Gamepad.PS3XC_DPAD_LEFT = 14, X.Gamepad.PS3XC_DPAD_RIGHT = 15, X.Gamepad.PS3XC_STICK_LEFT_X = 0, X.Gamepad.PS3XC_STICK_LEFT_Y = 1, X.Gamepad.PS3XC_STICK_RIGHT_X = 2, X.Gamepad.PS3XC_STICK_RIGHT_Y = 3, X.SinglePad = function(t, e) {
                    this.game = t, this.index = null, this.connected = !1, (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
                }, X.SinglePad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    getButton: function(t) {
                        return this._buttons[t] || null
                    },
                    pollStatus: function() {
                        if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                            for (var t = 0; t < this._buttonsLen; t++) {
                                var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                                e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                            }
                            for (var i = 0; i < this._axesLen; i++) {
                                var s = this._rawPad.axes[i];
                                0 < s && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                            }
                            this._prevTimestamp = this._rawPad.timestamp
                        }
                    },
                    connect: function(t) {
                        var e = !this.connected;
                        this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                        for (var i, s = 0; s < this._axesLen; s++) this._axes[s] = t.axes[s];
                        for (i in t.buttons) i = parseInt(i, 10), this._buttons[i] = new X.DeviceButton(this, i);
                        e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                    },
                    disconnect: function() {
                        var t = this.connected,
                            e = this.index;
                        this.connected = !1, this.index = null, this._rawPad = void 0;
                        for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                    },
                    destroy: function() {
                        this._rawPad = void 0;
                        for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                    },
                    processAxisChange: function(t, e) {
                        this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                    },
                    processButtonDown: function(t, e) {
                        this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                    },
                    processButtonUp: function(t, e) {
                        this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                    },
                    processButtonFloat: function(t, e) {
                        this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                    },
                    axis: function(t) {
                        return !!this._axes[t] && this._axes[t]
                    },
                    isDown: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isDown
                    },
                    isUp: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isUp
                    },
                    justReleased: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justReleased(e)
                    },
                    justPressed: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justPressed(e)
                    },
                    buttonValue: function(t) {
                        return this._buttons[t] ? this._buttons[t].value : null
                    },
                    reset: function() {
                        for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                    }
                }, X.SinglePad.prototype.constructor = X.SinglePad, X.Key = function(t, e) {
                    this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new X.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new X.Signal, this._justDown = !1, this._justUp = !1
                }, X.Key.prototype = {
                    update: function() {
                        this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                    },
                    processKeyDown: function(t) {
                        this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                    },
                    processKeyUp: function(t) {
                        this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                    },
                    downDuration: function(t) {
                        return void 0 === t && (t = 50), this.isDown && this.duration < t
                    },
                    upDuration: function(t) {
                        return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                    }
                }, Object.defineProperty(X.Key.prototype, "justDown", {
                    get: function() {
                        var t = this._justDown;
                        return this._justDown = !1, t
                    }
                }), Object.defineProperty(X.Key.prototype, "justUp", {
                    get: function() {
                        var t = this._justUp;
                        return this._justUp = !1, t
                    }
                }), Object.defineProperty(X.Key.prototype, "enabled", {
                    get: function() {
                        return this._enabled
                    },
                    set: function(t) {
                        (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                    }
                }), X.Key.prototype.constructor = X.Key, X.Keyboard = function(t) {
                    this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, (this.callbackContext = this).onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
                }, X.Keyboard.prototype = {
                    addCallbacks: function(t, e, i, s) {
                        this.callbackContext = t, null != e && (this.onDownCallback = e), null != i && (this.onUpCallback = i), null != s && (this.onPressCallback = s)
                    },
                    addKey: function(t) {
                        return this._keys[t] || (this._keys[t] = new X.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                    },
                    addKeys: function(t) {
                        var e, i = {};
                        for (e in t) i[e] = this.addKey(t[e]);
                        return i
                    },
                    removeKey: function(t) {
                        this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                    },
                    createCursorKeys: function() {
                        return this.addKeys({
                            up: X.KeyCode.UP,
                            down: X.KeyCode.DOWN,
                            left: X.KeyCode.LEFT,
                            right: X.KeyCode.RIGHT
                        })
                    },
                    start: function() {
                        var e;
                        this.game.device.cocoonJS || null !== this._onKeyDown || ((e = this)._onKeyDown = function(t) {
                            return e.processKeyDown(t)
                        }, this._onKeyUp = function(t) {
                            return e.processKeyUp(t)
                        }, this._onKeyPress = function(t) {
                            return e.processKeyPress(t)
                        }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1))
                    },
                    stop: function() {
                        window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                    },
                    destroy: function() {
                        this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                    },
                    addKeyCapture: function(t) {
                        if ("object" == typeof t)
                            for (var e in t) this._capture[t[e]] = !0;
                        else this._capture[t] = !0
                    },
                    removeKeyCapture: function(t) {
                        delete this._capture[t]
                    },
                    clearCaptures: function() {
                        this._capture = {}
                    },
                    update: function() {
                        for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                    },
                    processKeyDown: function(t) {
                        var e;
                        this.event = t, this.game.input.enabled && this.enabled && (e = t.keyCode, this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new X.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t))
                    },
                    processKeyPress: function(t) {
                        this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                    },
                    processKeyUp: function(t) {
                        var e;
                        this.event = t, this.game.input.enabled && this.enabled && (e = t.keyCode, this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new X.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t))
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.event = null;
                        for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                    },
                    downDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].downDuration(e) : null
                    },
                    upDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].upDuration(e) : null
                    },
                    isDown: function(t) {
                        return this._keys[t] ? this._keys[t].isDown : null
                    }
                }, Object.defineProperty(X.Keyboard.prototype, "lastChar", {
                    get: function() {
                        return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                    }
                }), Object.defineProperty(X.Keyboard.prototype, "lastKey", {
                    get: function() {
                        return this._keys[this._k]
                    }
                }), X.Keyboard.prototype.constructor = X.Keyboard, X.KeyCode = {
                    A: "A".charCodeAt(0),
                    B: "B".charCodeAt(0),
                    C: "C".charCodeAt(0),
                    D: "D".charCodeAt(0),
                    E: "E".charCodeAt(0),
                    F: "F".charCodeAt(0),
                    G: "G".charCodeAt(0),
                    H: "H".charCodeAt(0),
                    I: "I".charCodeAt(0),
                    J: "J".charCodeAt(0),
                    K: "K".charCodeAt(0),
                    L: "L".charCodeAt(0),
                    M: "M".charCodeAt(0),
                    N: "N".charCodeAt(0),
                    O: "O".charCodeAt(0),
                    P: "P".charCodeAt(0),
                    Q: "Q".charCodeAt(0),
                    R: "R".charCodeAt(0),
                    S: "S".charCodeAt(0),
                    T: "T".charCodeAt(0),
                    U: "U".charCodeAt(0),
                    V: "V".charCodeAt(0),
                    W: "W".charCodeAt(0),
                    X: "X".charCodeAt(0),
                    Y: "Y".charCodeAt(0),
                    Z: "Z".charCodeAt(0),
                    ZERO: "0".charCodeAt(0),
                    ONE: "1".charCodeAt(0),
                    TWO: "2".charCodeAt(0),
                    THREE: "3".charCodeAt(0),
                    FOUR: "4".charCodeAt(0),
                    FIVE: "5".charCodeAt(0),
                    SIX: "6".charCodeAt(0),
                    SEVEN: "7".charCodeAt(0),
                    EIGHT: "8".charCodeAt(0),
                    NINE: "9".charCodeAt(0),
                    NUMPAD_0: 96,
                    NUMPAD_1: 97,
                    NUMPAD_2: 98,
                    NUMPAD_3: 99,
                    NUMPAD_4: 100,
                    NUMPAD_5: 101,
                    NUMPAD_6: 102,
                    NUMPAD_7: 103,
                    NUMPAD_8: 104,
                    NUMPAD_9: 105,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_ADD: 107,
                    NUMPAD_ENTER: 108,
                    NUMPAD_SUBTRACT: 109,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123,
                    F13: 124,
                    F14: 125,
                    F15: 126,
                    COLON: 186,
                    EQUALS: 187,
                    COMMA: 188,
                    UNDERSCORE: 189,
                    PERIOD: 190,
                    QUESTION_MARK: 191,
                    TILDE: 192,
                    OPEN_BRACKET: 219,
                    BACKWARD_SLASH: 220,
                    CLOSED_BRACKET: 221,
                    QUOTES: 222,
                    BACKSPACE: 8,
                    TAB: 9,
                    CLEAR: 12,
                    ENTER: 13,
                    SHIFT: 16,
                    CONTROL: 17,
                    ALT: 18,
                    CAPS_LOCK: 20,
                    ESC: 27,
                    SPACEBAR: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    PLUS: 43,
                    MINUS: 44,
                    INSERT: 45,
                    DELETE: 46,
                    HELP: 47,
                    NUM_LOCK: 144
                }, X.KeyCode) X.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/) && (X.Keyboard[e] = X.KeyCode[e]);
            for (i in X.Component = function() {}, X.Component.Angle = function() {}, X.Component.Angle.prototype = {
                    angle: {
                        get: function() {
                            return X.Math.wrapAngle(X.Math.radToDeg(this.rotation))
                        },
                        set: function(t) {
                            this.rotation = X.Math.degToRad(X.Math.wrapAngle(t))
                        }
                    }
                }, X.Component.Animation = function() {}, X.Component.Animation.prototype = {
                    play: function(t, e, i, s) {
                        if (this.animations) return this.animations.play(t, e, i, s)
                    }
                }, X.Component.AutoCull = function() {}, X.Component.AutoCull.prototype = {
                    autoCull: !1,
                    inCamera: {
                        get: function() {
                            return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                }, X.Component.Bounds = function() {}, X.Component.Bounds.prototype = {
                    offsetX: {
                        get: function() {
                            return this.anchor.x * this.width
                        }
                    },
                    offsetY: {
                        get: function() {
                            return this.anchor.y * this.height
                        }
                    },
                    centerX: {
                        get: function() {
                            return this.x - this.offsetX + .5 * this.width
                        },
                        set: function(t) {
                            this.x = t + this.offsetX - .5 * this.width
                        }
                    },
                    centerY: {
                        get: function() {
                            return this.y - this.offsetY + .5 * this.height
                        },
                        set: function(t) {
                            this.y = t + this.offsetY - .5 * this.height
                        }
                    },
                    left: {
                        get: function() {
                            return this.x - this.offsetX
                        },
                        set: function(t) {
                            this.x = t + this.offsetX
                        }
                    },
                    right: {
                        get: function() {
                            return this.x + this.width - this.offsetX
                        },
                        set: function(t) {
                            this.x = t - this.width + this.offsetX
                        }
                    },
                    top: {
                        get: function() {
                            return this.y - this.offsetY
                        },
                        set: function(t) {
                            this.y = t + this.offsetY
                        }
                    },
                    bottom: {
                        get: function() {
                            return this.y + this.height - this.offsetY
                        },
                        set: function(t) {
                            this.y = t - this.height + this.offsetY
                        }
                    },
                    alignIn: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                                case X.TOP_LEFT:
                                this.left = t.left - i,
                            this.top = t.top - s;
                            break;
                            case X.TOP_CENTER:
                                    this.centerX = t.centerX + i,
                                this.top = t.top - s;
                                break;
                            case X.TOP_RIGHT:
                                    this.right = t.right + i,
                                this.top = t.top - s;
                                break;
                            case X.LEFT_CENTER:
                                    this.left = t.left - i,
                                this.centerY = t.centerY + s;
                                break;
                            case X.CENTER:
                                    this.centerX = t.centerX + i,
                                this.centerY = t.centerY + s;
                                break;
                            case X.RIGHT_CENTER:
                                    this.right = t.right + i,
                                this.centerY = t.centerY + s;
                                break;
                            case X.BOTTOM_LEFT:
                                    this.left = t.left - i,
                                this.bottom = t.bottom + s;
                                break;
                            case X.BOTTOM_CENTER:
                                    this.centerX = t.centerX + i,
                                this.bottom = t.bottom + s;
                                break;
                            case X.BOTTOM_RIGHT:
                                    this.right = t.right + i,
                                this.bottom = t.bottom + s
                        }
                        return this
                    },
                    alignTo: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                                case X.TOP_LEFT:
                                this.left = t.left - i,
                            this.bottom = t.top - s;
                            break;
                            case X.TOP_CENTER:
                                    this.centerX = t.centerX + i,
                                this.bottom = t.top - s;
                                break;
                            case X.TOP_RIGHT:
                                    this.right = t.right + i,
                                this.bottom = t.top - s;
                                break;
                            case X.LEFT_TOP:
                                    this.right = t.left - i,
                                this.top = t.top - s;
                                break;
                            case X.LEFT_CENTER:
                                    this.right = t.left - i,
                                this.centerY = t.centerY + s;
                                break;
                            case X.LEFT_BOTTOM:
                                    this.right = t.left - i,
                                this.bottom = t.bottom + s;
                                break;
                            case X.RIGHT_TOP:
                                    this.left = t.right + i,
                                this.top = t.top - s;
                                break;
                            case X.RIGHT_CENTER:
                                    this.left = t.right + i,
                                this.centerY = t.centerY + s;
                                break;
                            case X.RIGHT_BOTTOM:
                                    this.left = t.right + i,
                                this.bottom = t.bottom + s;
                                break;
                            case X.BOTTOM_LEFT:
                                    this.left = t.left - i,
                                this.top = t.bottom + s;
                                break;
                            case X.BOTTOM_CENTER:
                                    this.centerX = t.centerX + i,
                                this.top = t.bottom + s;
                                break;
                            case X.BOTTOM_RIGHT:
                                    this.right = t.right + i,
                                this.top = t.bottom + s
                        }
                        return this
                    }
                }, X.Group.prototype.alignIn = X.Component.Bounds.prototype.alignIn, X.Group.prototype.alignTo = X.Component.Bounds.prototype.alignTo, X.Component.BringToTop = function() {}, X.Component.BringToTop.prototype.bringToTop = function() {
                    return this.parent && this.parent.bringToTop(this), this
                }, X.Component.BringToTop.prototype.sendToBack = function() {
                    return this.parent && this.parent.sendToBack(this), this
                }, X.Component.BringToTop.prototype.moveUp = function() {
                    return this.parent && this.parent.moveUp(this), this
                }, X.Component.BringToTop.prototype.moveDown = function() {
                    return this.parent && this.parent.moveDown(this), this
                }, X.Component.Core = function() {}, X.Component.Core.install = function(t) {
                    X.Utils.mixinPrototype(this, X.Component.Core.prototype), this.components = {};
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e],
                            s = "Destroy" === i ? !0 : !1;
                        X.Utils.mixinPrototype(this, X.Component[i].prototype, s), this.components[i] = !0
                    }
                }, X.Component.Core.init = function(t, e, i, s, n) {
                    this.game = t, this.key = s, this.data = {}, this.position.set(e, i), this.world = new X.Point(e, i), this.previousPosition = new X.Point(e, i), this.events = new X.Events(this), this._bounds = new X.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new X.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, n), this.components.FixedToCamera && (this.cameraOffset = new X.Point(e, i))
                }, X.Component.Core.preUpdate = function() {
                    if (!this.pendingDestroy) {
                        if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                        for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                        return !0
                    }
                    this.destroy()
                }, X.Component.Core.prototype = {
                    game: null,
                    name: "",
                    data: {},
                    components: {},
                    z: 0,
                    events: void 0,
                    animations: void 0,
                    key: "",
                    world: null,
                    debug: !1,
                    previousPosition: null,
                    previousRotation: 0,
                    renderOrderID: 0,
                    fresh: !0,
                    pendingDestroy: !1,
                    _bounds: null,
                    _exists: !0,
                    exists: {
                        get: function() {
                            return this._exists
                        },
                        set: function(t) {
                            t ? (this._exists = !0, this.body && this.body.type === X.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === X.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                        }
                    },
                    update: function() {},
                    postUpdate: function() {
                        this.customRender && this.key.render(), this.components.PhysicsBody && X.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && X.Component.FixedToCamera.postUpdate.call(this);
                        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                    }
                }, X.Component.Crop = function() {}, X.Component.Crop.prototype = {
                    cropRect: null,
                    _crop: null,
                    crop: function(t, e) {
                        void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new X.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                    },
                    updateCrop: function() {
                        var t, e, i, s, n, a, o, r;
                        this.cropRect && (t = this.texture.crop.x, e = this.texture.crop.y, i = this.texture.crop.width, s = this.texture.crop.height, this._crop = X.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y, n = Math.max(this._frame.x, this._crop.x), a = Math.max(this._frame.y, this._crop.y), o = Math.min(this._frame.right, this._crop.right) - n, r = Math.min(this._frame.bottom, this._crop.bottom) - a, this.texture.crop.x = n, this.texture.crop.y = a, this.texture.crop.width = o, this.texture.crop.height = r, this.texture.frame.width = Math.min(o, this.cropRect.width), this.texture.frame.height = Math.min(r, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === n && e === a && i === o && s === r || (this.texture.requiresReTint = !0))
                    }
                }, X.Component.Delta = function() {}, X.Component.Delta.prototype = {
                    deltaX: {
                        get: function() {
                            return this.world.x - this.previousPosition.x
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this.world.y - this.previousPosition.y
                        }
                    },
                    deltaZ: {
                        get: function() {
                            return this.rotation - this.previousRotation
                        }
                    }
                }, X.Component.Destroy = function() {}, X.Component.Destroy.prototype = {
                    destroyPhase: !1,
                    destroy: function(t, e) {
                        if (null !== this.game && !this.destroyPhase) {
                            void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof X.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                            var i = this.children.length;
                            if (t)
                                for (; i--;) this.children[i].destroy(t);
                            else
                                for (; i--;) this.removeChild(this.children[i]);
                            this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), X.Video && this.key instanceof X.Video && this.key.onChangeSource.remove(this.resizeFrame, this), X.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                        }
                    }
                }, X.Events = function(t) {
                    this.parent = t
                }, X.Events.prototype = {
                    destroy: function() {
                        this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                    },
                    onAddedToGroup: null,
                    onRemovedFromGroup: null,
                    onRemovedFromWorld: null,
                    onDestroy: null,
                    onKilled: null,
                    onRevived: null,
                    onOutOfBounds: null,
                    onEnterBounds: null,
                    onInputOver: null,
                    onInputOut: null,
                    onInputDown: null,
                    onInputUp: null,
                    onDragStart: null,
                    onDragUpdate: null,
                    onDragStop: null,
                    onAnimationStart: null,
                    onAnimationComplete: null,
                    onAnimationLoop: null
                }, X.Events.prototype.constructor = X.Events, X.Events.prototype) X.Events.prototype.hasOwnProperty(i) && 0 === i.indexOf("on") && null === X.Events.prototype[i] && function(t, e) {
                "use strict";
                Object.defineProperty(X.Events.prototype, t, {
                    get: function() {
                        return this[e] || (this[e] = new X.Signal)
                    }
                }), X.Events.prototype[t + "$dispatch"] = function() {
                    return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
                }
            }(i, "_" + i);
            X.Component.FixedToCamera = function() {}, X.Component.FixedToCamera.postUpdate = function() {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
            }, X.Component.FixedToCamera.prototype = {
                _fixedToCamera: !1,
                fixedToCamera: {
                    get: function() {
                        return this._fixedToCamera
                    },
                    set: function(t) {
                        t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                    }
                },
                cameraOffset: new X.Point
            }, X.Component.Health = function() {}, X.Component.Health.prototype = {
                health: 1,
                maxHealth: 100,
                damage: function(t) {
                    return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
                },
                setHealth: function(t) {
                    return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
                },
                heal: function(t) {
                    return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
                }
            }, X.Component.InCamera = function() {}, X.Component.InCamera.prototype = {
                inCamera: {
                    get: function() {
                        return this.game.world.camera.view.intersects(this._bounds)
                    }
                }
            }, X.Component.InputEnabled = function() {}, X.Component.InputEnabled.prototype = {
                input: null,
                inputEnabled: {
                    get: function() {
                        return this.input && this.input.enabled
                    },
                    set: function(t) {
                        t ? null === this.input ? (this.input = new X.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                    }
                }
            }, X.Component.InWorld = function() {}, X.Component.InWorld.preUpdate = function() {
                if (this.autoCull || this.checkWorldBounds) {
                    if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                        if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                        else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                    if (this.checkWorldBounds)
                        if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                        else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
                }
                return !0
            }, X.Component.InWorld.prototype = {
                checkWorldBounds: !1,
                outOfBoundsKill: !1,
                outOfCameraBoundsKill: !1,
                _outOfBoundsFired: !1,
                inWorld: {
                    get: function() {
                        return this.game.world.bounds.intersects(this.getBounds())
                    }
                }
            }, X.Component.LifeSpan = function() {}, X.Component.LifeSpan.preUpdate = function() {
                return !(0 < this.lifespan && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1))
            }, X.Component.LifeSpan.prototype = {
                alive: !0,
                lifespan: 0,
                revive: function(t) {
                    return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
                },
                kill: function() {
                    return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
                }
            }, X.Component.LoadTexture = function() {}, X.Component.LoadTexture.prototype = {
                customRender: !1,
                _frame: null,
                loadTexture: function(t, e, i) {
                    e = t === X.PENDING_ATLAS ? (t = e, 0) : e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                    var s = this.game.cache,
                        n = !0,
                        a = !this.texture.baseTexture.scaleMode;
                    X.RenderTexture && t instanceof X.RenderTexture ? (this.key = t.key, this.setTexture(t)) : X.BitmapData && t instanceof X.BitmapData ? (this.customRender = !0, this.setTexture(t.texture), n = s.hasFrameData(t.key, X.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, X.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0)) : X.Video && t instanceof X.Video ? (this.customRender = !0, i = t.texture.valid, this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = i) : X.Tilemap && t instanceof X.TilemapLayer ? this.setTexture(PIXI.Texture.fromCanvas(t.canvas)) : t instanceof PIXI.Texture ? this.setTexture(t) : (s = s.getImage(t, !0), this.key = s.key, this.setTexture(new PIXI.Texture(s.base)), this.texture.baseTexture.skipRender = "__default" === t, n = !this.animations.loadFrameData(s.frameData, e)), n && (this._frame = X.Rectangle.clone(this.texture.frame)), a || (this.texture.baseTexture.scaleMode = 1)
                },
                setFrame: function(t) {
                    this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                        x: t.spriteSourceSizeX,
                        y: t.spriteSourceSizeY,
                        width: t.sourceSizeW,
                        height: t.sourceSizeH
                    }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
                },
                resizeFrame: function(t, e, i) {
                    this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
                },
                resetFrame: function() {
                    this._frame && this.setFrame(this._frame)
                },
                frame: {
                    get: function() {
                        return this.animations.frame
                    },
                    set: function(t) {
                        this.animations.frame = t
                    }
                },
                frameName: {
                    get: function() {
                        return this.animations.frameName
                    },
                    set: function(t) {
                        this.animations.frameName = t
                    }
                }
            }, X.Component.Overlap = function() {}, X.Component.Overlap.prototype = {
                overlap: function(t) {
                    return X.Rectangle.intersects(this.getBounds(), t.getBounds())
                }
            }, X.Component.PhysicsBody = function() {}, X.Component.PhysicsBody.preUpdate = function() {
                return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || !(this.renderOrderID = -1))
            }, X.Component.PhysicsBody.postUpdate = function() {
                this.exists && this.body && this.body.postUpdate()
            }, X.Component.PhysicsBody.prototype = {
                body: null,
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(t) {
                        this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(t) {
                        this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                    }
                }
            }, X.Component.Reset = function() {}, X.Component.Reset.prototype.reset = function(t, e, i) {
                return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
            }, X.Component.ScaleMinMax = function() {}, X.Component.ScaleMinMax.prototype = {
                transformCallback: null,
                transformCallbackContext: this,
                scaleMin: null,
                scaleMax: null,
                checkTransform: function(t) {
                    this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
                },
                setScaleMinMax: function(t, e, i, s) {
                    void 0 === e ? e = i = s = t : void 0 === i && (i = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new X.Point(t, e), null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, s) : this.scaleMax = new X.Point(i, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
                }
            }, X.Component.Smoothed = function() {}, X.Component.Smoothed.prototype = {
                smoothed: {
                    get: function() {
                        return !this.texture.baseTexture.scaleMode
                    },
                    set: function(t) {
                        t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                    }
                }
            }, X.GameObjectFactory = function(t) {
                this.game = t, this.world = this.game.world
            }, X.GameObjectFactory.prototype = {
                existing: function(t) {
                    return this.world.add(t)
                },
                weapon: function(t, e, i, s) {
                    var n = this.game.plugins.add(X.Weapon);
                    return n.createBullets(t, e, i, s), n
                },
                image: function(t, e, i, s, n) {
                    return void 0 === n && (n = this.world), n.add(new X.Image(this.game, t, e, i, s))
                },
                sprite: function(t, e, i, s, n) {
                    return void 0 === n && (n = this.world), n.create(t, e, i, s)
                },
                creature: function(t, e, i, s, n) {
                    void 0 === n && (n = this.world);
                    s = new X.Creature(this.game, t, e, i, s);
                    return n.add(s), s
                },
                tween: function(t) {
                    return this.game.tweens.create(t)
                },
                group: function(t, e, i, s, n) {
                    return new X.Group(this.game, t, e, i, s, n)
                },
                physicsGroup: function(t, e, i, s) {
                    return new X.Group(this.game, e, i, s, !0, t)
                },
                spriteBatch: function(t, e, i) {
                    return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === i && (i = !1), new X.SpriteBatch(this.game, t, e, i)
                },
                audio: function(t, e, i, s) {
                    return this.game.sound.add(t, e, i, s)
                },
                sound: function(t, e, i, s) {
                    return this.game.sound.add(t, e, i, s)
                },
                audioSprite: function(t) {
                    return this.game.sound.addSprite(t)
                },
                tileSprite: function(t, e, i, s, n, a, o) {
                    return void 0 === o && (o = this.world), o.add(new X.TileSprite(this.game, t, e, i, s, n, a))
                },
                rope: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = this.world), a.add(new X.Rope(this.game, t, e, i, s, n))
                },
                text: function(t, e, i, s, n) {
                    return void 0 === n && (n = this.world), n.add(new X.Text(this.game, t, e, i, s))
                },
                button: function(t, e, i, s, n, a, o, r, h, l) {
                    return void 0 === l && (l = this.world), l.add(new X.Button(this.game, t, e, i, s, n, a, o, r, h))
                },
                graphics: function(t, e, i) {
                    return void 0 === i && (i = this.world), i.add(new X.Graphics(this.game, t, e))
                },
                emitter: function(t, e, i) {
                    return this.game.particles.add(new X.Particles.Arcade.Emitter(this.game, t, e, i))
                },
                retroFont: function(t, e, i, s, n, a, o, r, h) {
                    return new X.RetroFont(this.game, t, e, i, s, n, a, o, r, h)
                },
                bitmapText: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = this.world), a.add(new X.BitmapText(this.game, t, e, i, s, n))
                },
                tilemap: function(t, e, i, s, n) {
                    return new X.Tilemap(this.game, t, e, i, s, n)
                },
                renderTexture: function(t, e, i, s) {
                    void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                    e = new X.RenderTexture(this.game, t, e, i);
                    return s && this.game.cache.addRenderTexture(i, e), e
                },
                video: function(t, e) {
                    return new X.Video(this.game, t, e)
                },
                bitmapData: function(t, e, i, s) {
                    void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                    e = new X.BitmapData(this.game, i, t, e);
                    return s && this.game.cache.addBitmapData(i, e), e
                },
                filter: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1);
                    return (t = new X.Filter[t](this.game)).init.apply(t, e), t
                },
                plugin: function(t) {
                    return this.game.plugins.add(t)
                }
            }, X.GameObjectFactory.prototype.constructor = X.GameObjectFactory, X.GameObjectCreator = function(t) {
                this.game = t, this.world = this.game.world
            }, X.GameObjectCreator.prototype = {
                image: function(t, e, i, s) {
                    return new X.Image(this.game, t, e, i, s)
                },
                sprite: function(t, e, i, s) {
                    return new X.Sprite(this.game, t, e, i, s)
                },
                tween: function(t) {
                    return new X.Tween(t, this.game, this.game.tweens)
                },
                group: function(t, e, i, s, n) {
                    return new X.Group(this.game, t, e, i, s, n)
                },
                spriteBatch: function(t, e, i) {
                    return void 0 === e && (e = "group"), void 0 === i && (i = !1), new X.SpriteBatch(this.game, t, e, i)
                },
                audio: function(t, e, i, s) {
                    return this.game.sound.add(t, e, i, s)
                },
                audioSprite: function(t) {
                    return this.game.sound.addSprite(t)
                },
                sound: function(t, e, i, s) {
                    return this.game.sound.add(t, e, i, s)
                },
                tileSprite: function(t, e, i, s, n, a) {
                    return new X.TileSprite(this.game, t, e, i, s, n, a)
                },
                rope: function(t, e, i, s, n) {
                    return new X.Rope(this.game, t, e, i, s, n)
                },
                text: function(t, e, i, s) {
                    return new X.Text(this.game, t, e, i, s)
                },
                button: function(t, e, i, s, n, a, o, r, h) {
                    return new X.Button(this.game, t, e, i, s, n, a, o, r, h)
                },
                graphics: function(t, e) {
                    return new X.Graphics(this.game, t, e)
                },
                emitter: function(t, e, i) {
                    return new X.Particles.Arcade.Emitter(this.game, t, e, i)
                },
                retroFont: function(t, e, i, s, n, a, o, r, h) {
                    return new X.RetroFont(this.game, t, e, i, s, n, a, o, r, h)
                },
                bitmapText: function(t, e, i, s, n, a) {
                    return new X.BitmapText(this.game, t, e, i, s, n, a)
                },
                tilemap: function(t, e, i, s, n) {
                    return new X.Tilemap(this.game, t, e, i, s, n)
                },
                renderTexture: function(t, e, i, s) {
                    void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                    e = new X.RenderTexture(this.game, t, e, i);
                    return s && this.game.cache.addRenderTexture(i, e), e
                },
                bitmapData: function(t, e, i, s) {
                    void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                    e = new X.BitmapData(this.game, i, t, e);
                    return s && this.game.cache.addBitmapData(i, e), e
                },
                filter: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1);
                    return (t = new X.Filter[t](this.game)).init.apply(t, e), t
                }
            }, X.GameObjectCreator.prototype.constructor = X.GameObjectCreator, X.Sprite = function(t, e, i, s, n) {
                e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = X.SPRITE, this.physicsType = X.SPRITE, PIXI.Sprite.call(this, X.Cache.DEFAULT), X.Component.Core.init.call(this, t, e, i, s, n)
            }, X.Sprite.prototype = Object.create(PIXI.Sprite.prototype), X.Sprite.prototype.constructor = X.Sprite, X.Component.Core.install.call(X.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), X.Sprite.prototype.preUpdatePhysics = X.Component.PhysicsBody.preUpdate, X.Sprite.prototype.preUpdateLifeSpan = X.Component.LifeSpan.preUpdate, X.Sprite.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.Sprite.prototype.preUpdateCore = X.Component.Core.preUpdate, X.Sprite.prototype.preUpdate = function() {
                return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.Image = function(t, e, i, s, n) {
                e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = X.IMAGE, PIXI.Sprite.call(this, X.Cache.DEFAULT), X.Component.Core.init.call(this, t, e, i, s, n)
            }, X.Image.prototype = Object.create(PIXI.Sprite.prototype), X.Image.prototype.constructor = X.Image, X.Component.Core.install.call(X.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), X.Image.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.Image.prototype.preUpdateCore = X.Component.Core.preUpdate, X.Image.prototype.preUpdate = function() {
                return !!this.preUpdateInWorld() && this.preUpdateCore()
            }, X.Button = function(t, e, i, s, n, a, o, r, h, l) {
                e = e || 0, i = i || 0, s = s || null, n = n || null, a = a || this, X.Image.call(this, t, e, i, s, r), this.type = X.BUTTON, this.physicsType = X.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new X.Signal, this.onInputOut = new X.Signal, this.onInputDown = new X.Signal, this.onInputUp = new X.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = X.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(o, r, h, l), null !== n && this.onInputUp.add(n, a), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
            }, X.Button.prototype = Object.create(X.Image.prototype), X.Button.prototype.constructor = X.Button;
            X.Button.prototype.clearFrames = function() {
                this.setFrames(null, null, null, null)
            }, X.Button.prototype.removedFromWorld = function() {
                this.inputEnabled = !1
            }, X.Button.prototype.setStateFrame = function(t, e, i) {
                var s = "_on" + t + "Frame";
                null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
            }, X.Button.prototype.changeStateFrame = function(t) {
                if (this.freezeFrames) return !1;
                t = this["_on" + t + "Frame"];
                return "string" == typeof t ? (this.frameName = t, !0) : "number" == typeof t && (this.frame = t, !0)
            }, X.Button.prototype.setFrames = function(t, e, i, s) {
                this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", s, this.input.pointerUp())
            }, X.Button.prototype.setStateSound = function(t, e, i) {
                var s = "on" + t + "Sound",
                    t = "on" + t + "SoundMarker";
                e instanceof X.Sound || e instanceof X.AudioSprite ? (this[s] = e, this[t] = "string" == typeof i ? i : "") : (this[s] = null, this[t] = "")
            }, X.Button.prototype.playStateSound = function(t) {
                var e = this["on" + t + "Sound"];
                if (e) {
                    t = this["on" + t + "SoundMarker"];
                    return e.play(t), !0
                }
                return !1
            }, X.Button.prototype.setSounds = function(t, e, i, s, n, a, o, r) {
                this.setStateSound("Over", t, e), this.setStateSound("Out", n, a), this.setStateSound("Down", i, s), this.setStateSound("Up", o, r)
            }, X.Button.prototype.setOverSound = function(t, e) {
                this.setStateSound("Over", t, e)
            }, X.Button.prototype.setOutSound = function(t, e) {
                this.setStateSound("Out", t, e)
            }, X.Button.prototype.setDownSound = function(t, e) {
                this.setStateSound("Down", t, e)
            }, X.Button.prototype.setUpSound = function(t, e) {
                this.setStateSound("Up", t, e)
            }, X.Button.prototype.onInputOverHandler = function(t, e) {
                e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
            }, X.Button.prototype.onInputOutHandler = function(t, e) {
                this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
            }, X.Button.prototype.onInputDownHandler = function(t, e) {
                this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
            }, X.Button.prototype.onInputUpHandler = function(t, e, i) {
                this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
            }, X.SpriteBatch = function(t, e, i, s) {
                null != e || (e = t.world), PIXI.SpriteBatch.call(this), X.Group.call(this, t, e, i, s), this.type = X.SPRITEBATCH
            }, X.SpriteBatch.prototype = X.Utils.extend(!0, X.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, X.Group.prototype), X.SpriteBatch.prototype.constructor = X.SpriteBatch, X.BitmapData = function(t, e, i, s, n) {
                void 0 !== i && 0 !== i || (i = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === n && (n = !1), this.game = t, this.key = e, this.width = i, this.height = s, this.canvas = X.Canvas.create(this, i, s, null, n), this.context = this.canvas.getContext("2d", {
                    alpha: !0
                }), this.ctx = this.context, this.smoothProperty = t.renderType === X.CANVAS ? t.renderer.renderSession.smoothProperty : X.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, i, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new X.FrameData, this.textureFrame = this.frameData.addFrame(new X.Frame(0, 0, 0, i, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = X.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new X.Point, this._size = new X.Point, this._scale = new X.Point, this._rotate = 0, this._alpha = {
                    prev: 1,
                    current: 1
                }, this._anchor = new X.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new X.Circle, this._swapCanvas = void 0
            }, X.BitmapData.prototype = {
                move: function(t, e, i) {
                    return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
                },
                moveH: function(t, e) {
                    void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                    var i, s = this._swapCanvas.getContext("2d"),
                        n = this.height,
                        a = this.canvas;
                    return s.clearRect(0, 0, this.width, this.height), t < 0 ? (t = Math.abs(t), i = this.width - t, e && s.drawImage(a, 0, 0, t, n, i, 0, t, n), s.drawImage(a, t, 0, i, n, 0, 0, i, n)) : (i = this.width - t, e && s.drawImage(a, i, 0, t, n, 0, 0, t, n), s.drawImage(a, 0, 0, i, n, t, 0, i, n)), this.clear(), this.copy(this._swapCanvas)
                },
                moveV: function(t, e) {
                    void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                    var i, s = this._swapCanvas.getContext("2d"),
                        n = this.width,
                        a = this.canvas;
                    return s.clearRect(0, 0, this.width, this.height), t < 0 ? (t = Math.abs(t), i = this.height - t, e && s.drawImage(a, 0, 0, n, t, 0, i, n, t), s.drawImage(a, 0, t, n, i, 0, 0, n, i)) : (i = this.height - t, e && s.drawImage(a, 0, i, n, t, 0, 0, n, t), s.drawImage(a, 0, 0, n, i, 0, t, n, i)), this.clear(), this.copy(this._swapCanvas)
                },
                add: function(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                    else t.loadTexture(this);
                    return this
                },
                load: function(t) {
                    if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
                },
                clear: function(t, e, i, s) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
                },
                fill: function(t, e, i, s) {
                    return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
                },
                generateTexture: function(t) {
                    var e = new Image;
                    e.crossOrigin = "Anonymous", e.src = this.canvas.toDataURL("image/png");
                    e = this.game.cache.addImage(t, "", e);
                    return new PIXI.Texture(e.base)
                },
                resize: function(t, e) {
                    return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
                },
                update: function(t, e, i, s) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
                },
                processPixelRGB: function(t, e, i, s, n, a) {
                    void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === a && (a = this.height);
                    for (var o, r = i + n, h = s + a, l = X.Color.createColor(), c = !1, u = s; u < h; u++)
                        for (var d = i; d < r; d++) X.Color.unpackPixel(this.getPixel32(d, u), l), !1 !== (o = t.call(e, l, d, u)) && null != o && (this.setPixel32(d, u, o.r, o.g, o.b, o.a, !1), c = !0);
                    return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                },
                processPixel: function(t, e, i, s, n, a) {
                    void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === a && (a = this.height);
                    for (var o, r, h = i + n, l = s + a, c = !1, u = s; u < l; u++)
                        for (var d = i; d < h; d++) o = this.getPixel32(d, u), (r = t.call(e, o, d, u)) !== o && (this.pixels[u * this.width + d] = r, c = !0);
                    return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                },
                replaceRGB: function(t, e, i, s, n, a, o, r, h) {
                    var l = 0,
                        c = 0,
                        u = this.width,
                        d = this.height,
                        p = X.Color.packPixel(t, e, i, s);
                    void 0 !== h && h instanceof X.Rectangle && (l = h.x, c = h.y, u = h.width, d = h.height);
                    for (var f = 0; f < d; f++)
                        for (var g = 0; g < u; g++) this.getPixel32(l + g, c + f) === p && this.setPixel32(l + g, c + f, n, a, o, r, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                },
                setHSL: function(t, e, i, s) {
                    var n = t || 0 === t,
                        a = e || 0 === e,
                        o = i || 0 === i;
                    if (n || a || o) {
                        void 0 === s && (s = new X.Rectangle(0, 0, this.width, this.height));
                        for (var r = X.Color.createColor(), h = s.y; h < s.bottom; h++)
                            for (var l = s.x; l < s.right; l++) X.Color.unpackPixel(this.getPixel32(l, h), r, !0), n && (r.h = t), a && (r.s = e), o && (r.l = i), X.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(l, h, r.r, r.g, r.b, r.a, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    }
                },
                shiftHSL: function(t, e, i, s) {
                    if (null != t || (t = !1), null != e || (e = !1), null != i || (i = !1), t || e || i) {
                        void 0 === s && (s = new X.Rectangle(0, 0, this.width, this.height));
                        for (var n = X.Color.createColor(), a = s.y; a < s.bottom; a++)
                            for (var o = s.x; o < s.right; o++) X.Color.unpackPixel(this.getPixel32(o, a), n, !0), t && (n.h = this.game.math.wrap(n.h + t, 0, 1)), e && (n.s = this.game.math.clamp(n.s + e, 0, 1)), i && (n.l = this.game.math.clamp(n.l + i, 0, 1)), X.Color.HSLtoRGB(n.h, n.s, n.l, n), this.setPixel32(o, a, n.r, n.g, n.b, n.a, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    }
                },
                setPixel32: function(t, e, i, s, n, a, o) {
                    return void 0 === o && (o = !0), 0 <= t && t <= this.width && 0 <= e && e <= this.height && (X.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = a << 24 | n << 16 | s << 8 | i : this.pixels[e * this.width + t] = i << 24 | s << 16 | n << 8 | a, o && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
                },
                setPixel: function(t, e, i, s, n, a) {
                    return this.setPixel32(t, e, i, s, n, 255, a)
                },
                getPixel: function(t, e, i) {
                    i = i || X.Color.createColor();
                    e = ~~(t + e * this.width);
                    return e *= 4, i.r = this.data[e], i.g = this.data[++e], i.b = this.data[++e], i.a = this.data[++e], i
                },
                getPixel32: function(t, e) {
                    if (0 <= t && t <= this.width && 0 <= e && e <= this.height) return this.pixels[e * this.width + t]
                },
                getPixelRGB: function(t, e, i, s, n) {
                    return X.Color.unpackPixel(this.getPixel32(t, e), i, s, n)
                },
                getPixels: function(t) {
                    return this.context.getImageData(t.x, t.y, t.width, t.height)
                },
                getFirstPixel: function(t) {
                    void 0 === t && (t = 0);
                    var e = X.Color.createColor(),
                        i = 0,
                        s = 0,
                        n = 1,
                        a = !1;
                    for (1 === t ? (n = -1, s = this.height) : 3 === t && (n = -1, i = this.width); X.Color.unpackPixel(this.getPixel32(i, s), e), 0 === t || 1 === t ? ++i === this.width && (i = 0, ((s += n) >= this.height || s <= 0) && (a = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0, ((i += n) >= this.width || i <= 0) && (a = !0)), 0 === e.a && !a;);
                    return e.x = i, e.y = s, e
                },
                getBounds: function(t) {
                    return void 0 === t && (t = new X.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
                },
                addToWorld: function(t, e, i, s, n, a) {
                    n = n || 1, a = a || 1;
                    e = this.game.add.image(t, e, this);
                    return e.anchor.set(i, s), e.scale.set(n, a), e
                },
                copy: function(t, e, i, s, n, a, o, r, h, l, c, u, d, p, f, g, m) {
                    if (null != t || (t = this), (t instanceof X.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), (this._image = t) instanceof X.Sprite || t instanceof X.Image || t instanceof X.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof X.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, null != a || (a = t.x), null != o || (o = t.y), t.texture.trim && (a += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                    else {
                        if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof X.BitmapData) this._image = t.canvas;
                        else if ("string" == typeof t) {
                            if (null === (t = this.game.cache.getImage(t))) return;
                            this._image = t
                        }
                        this._size.set(this._image.width, this._image.height)
                    }
                    if (null != e || (e = 0), null != i || (i = 0), s && (this._size.x = s), n && (this._size.y = n), null != a || (a = e), null != o || (o = i), null != r || (r = this._size.x), null != h || (h = this._size.y), "number" == typeof l && (this._rotate = l), "number" == typeof c && (this._anchor.x = c), "number" == typeof u && (this._anchor.y = u), "number" == typeof d && (this._scale.x = d), "number" == typeof p && (this._scale.y = p), "number" == typeof f && (this._alpha.current = f), void 0 === g && (g = null), void 0 === m && (m = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                        f = this.context;
                        return this._alpha.prev = f.globalAlpha, f.save(), f.globalAlpha = this._alpha.current, g && (this.op = g), m && (a |= 0, o |= 0), f.translate(a, o), f.scale(this._scale.x, this._scale.y), f.rotate(this._rotate), f.drawImage(this._image, this._pos.x + e, this._pos.y + i, this._size.x, this._size.y, -r * this._anchor.x, -h * this._anchor.y, r, h), f.restore(), f.globalAlpha = this._alpha.prev, this.dirty = !0, this
                    }
                },
                copyTransform: function(t, e, i) {
                    if (void 0 === e && (e = null), void 0 === i && (i = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                    var s = t.worldTransform;
                    if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y) return this;
                    t.texture instanceof X.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                    var n = s.tx,
                        a = s.ty;
                    t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), i && (n |= 0, a |= 0);
                    i = this.context;
                    return this._alpha.prev = i.globalAlpha, i.save(), i.globalAlpha = this._alpha.current, e && (this.op = e), i[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, i.setTransform(s.a, s.b, s.c, s.d, n, a), i.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), i.restore(), i.globalAlpha = this._alpha.prev, this.dirty = !0, this
                },
                copyRect: function(t, e, i, s, n, a, o) {
                    return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, a, o)
                },
                draw: function(t, e, i, s, n, a, o) {
                    return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, a, o)
                },
                drawGroup: function(t, e, i) {
                    return 0 < t.total && t.forEachExists(this.drawGroupProxy, this, e, i), this
                },
                drawGroupProxy: function(t, e, i) {
                    if (t.hasOwnProperty("texture") && this.copyTransform(t, e, i), t.type === X.GROUP && t.exists) this.drawGroup(t, e, i);
                    else if (t.hasOwnProperty("children") && 0 < t.children.length)
                        for (var s = 0; s < t.children.length; s++) t.children[s].exists && this.copyTransform(t.children[s], e, i)
                },
                drawFull: function(t, e, i) {
                    if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                    var s;
                    if (t.type !== X.GROUP && t.type !== X.EMITTER && t.type !== X.BITMAPTEXT && (t.type === X.GRAPHICS ? (s = t.getBounds(), this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()) : this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, i)), t.children)
                        for (var n = 0; n < t.children.length; n++) this.drawFull(t.children[n], e, i);
                    return this
                },
                shadow: function(t, e, i, s) {
                    var n = this.context;
                    return null == t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = e || 5, n.shadowOffsetX = i || 10, n.shadowOffsetY = s || 10), this
                },
                alphaMask: function(t, e, i, s) {
                    return (null == s ? this.draw(e) : this.draw(e, s.x, s.y, s.width, s.height)).blendSourceAtop(), (null == i ? this.draw(t) : this.draw(t, i.x, i.y, i.width, i.height)).blendReset(), this
                },
                extract: function(s, n, a, o, r, t, h, l, c) {
                    return void 0 === r && (r = 255), void 0 === t && (t = !1), void 0 === h && (h = n), void 0 === l && (l = a), void 0 === c && (c = o), t && s.resize(this.width, this.height), this.processPixelRGB(function(t, e, i) {
                        return t.r === n && t.g === a && t.b === o && s.setPixel32(e, i, h, l, c, r, !1), !1
                    }, this), s.context.putImageData(s.imageData, 0, 0), s.dirty = !0, s
                },
                rect: function(t, e, i, s, n) {
                    return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
                },
                text: function(t, e, i, s, n, a) {
                    void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === a && (a = !0);
                    var o = this.context,
                        r = o.font;
                    return o.font = s, a && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = n, o.fillText(t, e, i), o.font = r, this
                },
                circle: function(t, e, i, s) {
                    var n = this.context;
                    return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
                },
                line: function(t, e, i, s, n, a) {
                    void 0 === n && (n = "#fff"), void 0 === a && (a = 1);
                    var o = this.context;
                    return o.beginPath(), o.moveTo(t, e), o.lineTo(i, s), o.lineWidth = a, o.strokeStyle = n, o.stroke(), o.closePath(), this
                },
                textureLine: function(t, e, i) {
                    if (void 0 === i && (i = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                        var s = t.length;
                        "no-repeat" === i && s > e.width && (s = e.width);
                        var n = this.context;
                        return n.fillStyle = n.createPattern(e, i), this._circle = new X.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), n.save(), n.translate(this._pos.x, this._pos.y), n.rotate(t.angle), n.fillRect(0, 0, s, e.height), n.restore(), this.dirty = !0, this
                    }
                },
                render: function() {
                    return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
                },
                destroy: function() {
                    this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
                },
                blendReset: function() {
                    return this.op = "source-over", this
                },
                blendSourceOver: function() {
                    return this.op = "source-over", this
                },
                blendSourceIn: function() {
                    return this.op = "source-in", this
                },
                blendSourceOut: function() {
                    return this.op = "source-out", this
                },
                blendSourceAtop: function() {
                    return this.op = "source-atop", this
                },
                blendDestinationOver: function() {
                    return this.op = "destination-over", this
                },
                blendDestinationIn: function() {
                    return this.op = "destination-in", this
                },
                blendDestinationOut: function() {
                    return this.op = "destination-out", this
                },
                blendDestinationAtop: function() {
                    return this.op = "destination-atop", this
                },
                blendXor: function() {
                    return this.op = "xor", this
                },
                blendAdd: function() {
                    return this.op = "lighter", this
                },
                blendMultiply: function() {
                    return this.op = "multiply", this
                },
                blendScreen: function() {
                    return this.op = "screen", this
                },
                blendOverlay: function() {
                    return this.op = "overlay", this
                },
                blendDarken: function() {
                    return this.op = "darken", this
                },
                blendLighten: function() {
                    return this.op = "lighten", this
                },
                blendColorDodge: function() {
                    return this.op = "color-dodge", this
                },
                blendColorBurn: function() {
                    return this.op = "color-burn", this
                },
                blendHardLight: function() {
                    return this.op = "hard-light", this
                },
                blendSoftLight: function() {
                    return this.op = "soft-light", this
                },
                blendDifference: function() {
                    return this.op = "difference", this
                },
                blendExclusion: function() {
                    return this.op = "exclusion", this
                },
                blendHue: function() {
                    return this.op = "hue", this
                },
                blendSaturation: function() {
                    return this.op = "saturation", this
                },
                blendColor: function() {
                    return this.op = "color", this
                },
                blendLuminosity: function() {
                    return this.op = "luminosity", this
                }
            }, Object.defineProperty(X.BitmapData.prototype, "smoothed", {
                get: function() {
                    X.Canvas.getSmoothingEnabled(this.context)
                },
                set: function(t) {
                    X.Canvas.setSmoothingEnabled(this.context, t)
                }
            }), Object.defineProperty(X.BitmapData.prototype, "op", {
                get: function() {
                    return this.context.globalCompositeOperation
                },
                set: function(t) {
                    this.context.globalCompositeOperation = t
                }
            }), X.BitmapData.getTransform = function(t, e, i, s, n, a) {
                return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof a && (a = 0), {
                    sx: i,
                    sy: s,
                    scaleX: i,
                    scaleY: s,
                    skewX: n,
                    skewY: a,
                    translateX: t,
                    translateY: e,
                    tx: t,
                    ty: e
                }
            }, X.BitmapData.prototype.constructor = X.BitmapData, PIXI.Graphics = function() {
                PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
            }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
                return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
            }, PIXI.Graphics.prototype.moveTo = function(t, e) {
                return this.drawShape(new PIXI.Polygon([t, e])), this
            }, PIXI.Graphics.prototype.lineTo = function(t, e) {
                return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                var n, a, o = this.currentPath.shape.points;
                0 === o.length && this.moveTo(0, 0);
                for (var r, h = o[o.length - 2], l = o[o.length - 1], c = 1; c <= 20; ++c) n = h + (t - h) * (r = c / 20), a = l + (e - l) * r, o.push(n + (t + (i - t) * r - n) * r, a + (e + (s - e) * r - a) * r);
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, a) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                for (var o, r, h, l, c, u, d = this.currentPath.shape.points, p = d[d.length - 2], f = d[d.length - 1], g = 1; g <= 20; ++g) h = (r = (o = 1 - (u = g / 20)) * o) * o, c = (l = u * u) * u, d.push(h * p + 3 * r * u * t + 3 * o * l * i + c * n, h * f + 3 * r * u * e + 3 * o * l * s + c * a);
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.arcTo = function(t, e, i, s, n) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                var a, o, r, h = this.currentPath.shape.points,
                    l = h[h.length - 2],
                    c = h[h.length - 1] - e,
                    u = l - t,
                    d = s - e,
                    p = i - t,
                    f = Math.abs(c * p - u * d);
                return f < 1e-8 || 0 === n ? h[h.length - 2] === t && h[h.length - 1] === e || h.push(t, e) : (o = c * c + u * u, r = d * d + p * p, a = c * d + u * p, i = (l = n * Math.sqrt(o) / f) * p + (s = n * Math.sqrt(r) / f) * u, h = l * d + s * c, o = u * (s + (f = l * a / o)), f = c * (s + f), r = p * (l + (a = s * a / r)), a = d * (l + a), o = Math.atan2(f - h, o - i), r = Math.atan2(a - h, r - i), this.arc(i + t, h + e, n, o, r, p * c < u * d)), this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.arc = function(t, e, i, s, n, a, o) {
                if (s === n) return this;
                void 0 === a && (a = !1), void 0 === o && (o = 40), !a && n <= s ? n += 2 * Math.PI : a && s <= n && (s += 2 * Math.PI);
                var r = a ? -1 * (s - n) : n - s,
                    h = Math.ceil(Math.abs(r) / (2 * Math.PI)) * o;
                if (0 == r) return this;
                n = t + Math.cos(s) * i, o = e + Math.sin(s) * i;
                a && this.filling ? this.moveTo(t, e) : this.moveTo(n, o);
                for (var l = this.currentPath.shape.points, c = r / (2 * h), u = 2 * c, d = Math.cos(c), p = Math.sin(c), f = h - 1, g = f % 1 / f, m = 0; m <= f; m++) {
                    var y = c + s + u * (m + g * m),
                        b = Math.cos(y),
                        y = -Math.sin(y);
                    l.push((d * b + p * y) * i + t, (d * -y + p * b) * i + e)
                }
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.beginFill = function(t, e) {
                return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
            }, PIXI.Graphics.prototype.endFill = function() {
                return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
            }, PIXI.Graphics.prototype.drawRect = function(t, e, i, s) {
                return this.drawShape(new PIXI.Rectangle(t, e, i, s)), this
            }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, s, n) {
                return this.drawShape(new PIXI.RoundedRectangle(t, e, i, s, n)), this
            }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
                return this.drawShape(new PIXI.Circle(t, e, i)), this
            }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, s) {
                return this.drawShape(new PIXI.Ellipse(t, e, i, s)), this
            }, PIXI.Graphics.prototype.drawPolygon = function(t) {
                (t instanceof X.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
                var e = t;
                if (!Array.isArray(e)) {
                    e = new Array(arguments.length);
                    for (var i = 0; i < e.length; ++i) e[i] = arguments[i]
                }
                return this.drawShape(new X.Polygon(e)), this
            }, PIXI.Graphics.prototype.clear = function() {
                return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
            }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
                void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
                var s = this.getBounds();
                s.width += i, s.height += i;
                i = new PIXI.CanvasBuffer(s.width * t, s.height * t), e = PIXI.Texture.fromCanvas(i.canvas, e);
                return e.baseTexture.resolution = t, i.context.scale(t, t), i.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, i.context), e
            }, PIXI.Graphics.prototype._renderWebGL = function(t) {
                if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                    if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                    var e;
                    if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode && (t.spriteBatch.currentBlendMode = this.blendMode, e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode], t.spriteBatch.gl.blendFunc(e[0], e[1])), this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                        t.spriteBatch.start();
                        for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                        t.spriteBatch.stop()
                    }
                    this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
                }
            }, PIXI.Graphics.prototype._renderCanvas = function(t) {
                if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                    if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                    var e = t.context,
                        i = this.worldTransform;
                    this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                    var s = t.resolution,
                        n = i.tx * t.resolution + t.shakeX,
                        a = i.ty * t.resolution + t.shakeY;
                    e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, a), PIXI.CanvasGraphics.renderGraphics(this, e);
                    for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }, PIXI.Graphics.prototype.getBounds = function(t) {
                if (!this._currentBounds) {
                    if (!this.renderable) return PIXI.EmptyRectangle;
                    this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                    var e = this._localBounds,
                        i = e.x,
                        s = e.width + e.x,
                        n = e.y,
                        a = e.height + e.y,
                        o = t || this.worldTransform,
                        r = o.a,
                        h = o.b,
                        l = o.c,
                        c = o.d,
                        u = o.tx,
                        d = o.ty,
                        p = r * s + l * a + u,
                        e = c * a + h * s + d,
                        t = r * i + l * a + u,
                        o = c * a + h * i + d,
                        a = r * i + l * n + u,
                        i = c * n + h * i + d,
                        u = r * s + l * n + u,
                        h = c * n + h * s + d,
                        s = p,
                        d = e,
                        p = p,
                        e = e;
                    p = u < (p = a < (p = t < p ? t : p) ? a : p) ? u : p, e = h < (e = i < (e = o < e ? o : e) ? i : e) ? h : e, s = (s = (s = s < t ? t : s) < a ? a : s) < u ? u : s, d = (d = (d = d < o ? o : d) < i ? i : d) < h ? h : d, this._bounds.x = p, this._bounds.width = s - p, this._bounds.y = e, this._bounds.height = d - e, this._currentBounds = this._bounds
                }
                return this._currentBounds
            }, PIXI.Graphics.prototype.getLocalBounds = function() {
                var t = this.worldTransform;
                this.worldTransform = PIXI.identityMatrix;
                for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                var i = this.getBounds();
                for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                return i
            }, PIXI.Graphics.prototype.containsPoint = function(t) {
                this.worldTransform.applyInverse(t, tempPoint);
                for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                    var s = e[i];
                    if (s.fill && s.shape && s.shape.contains(tempPoint.x, tempPoint.y)) return !0
                }
                return !1
            }, PIXI.Graphics.prototype.updateLocalBounds = function() {
                var t = 1 / 0,
                    e = -1 / 0,
                    i = 1 / 0,
                    s = -1 / 0;
                if (this.graphicsData.length)
                    for (var n, a, o, r, h, l = 0; l < this.graphicsData.length; l++) {
                        var c = this.graphicsData[l],
                            u = c.type,
                            d = c.lineWidth,
                            c = c.shape;
                        if (u === PIXI.Graphics.RECT || u === PIXI.Graphics.RREC) a = c.x - d / 2, o = c.y - d / 2, t = a < t ? a : t, e = e < a + (r = c.width + d) ? a + r : e, i = o < i ? o : i, s = s < o + (h = c.height + d) ? o + h : s;
                        else if (u === PIXI.Graphics.CIRC) a = c.x, o = c.y, t = a - (r = c.radius + d / 2) < t ? a - r : t, e = e < a + r ? a + r : e, i = o - (h = c.radius + d / 2) < i ? o - h : i, s = s < o + h ? o + h : s;
                        else if (u === PIXI.Graphics.ELIP) a = c.x, o = c.y, t = a - (r = c.width + d / 2) < t ? a - r : t, e = e < a + r ? a + r : e, i = o - (h = c.height + d / 2) < i ? o - h : i, s = s < o + h ? o + h : s;
                        else {
                            n = c.points;
                            for (var p = 0; p < n.length; p++) n[p] instanceof X.Point ? (a = n[p].x, o = n[p].y) : (a = n[p], o = n[p + 1], p < n.length - 1 && p++), t = a - d < t ? a - d : t, e = e < a + d ? a + d : e, i = o - d < i ? o - d : i, s = s < o + d ? o + d : s
                        }
                    } else s = i = e = t = 0;
                var f = this.boundsPadding;
                this._localBounds.x = t - f, this._localBounds.width = e - t + 2 * f, this._localBounds.y = i - f, this._localBounds.height = s - i + 2 * f
            }, PIXI.Graphics.prototype._generateCachedSprite = function() {
                var t, e, i = this.getLocalBounds();
                this._cachedSprite ? this._cachedSprite.buffer.resize(i.width, i.height) : (t = new PIXI.CanvasBuffer(i.width, i.height), e = PIXI.Texture.fromCanvas(t.canvas), this._cachedSprite = new PIXI.Sprite(e), this._cachedSprite.buffer = t, this._cachedSprite.worldTransform = this.worldTransform), this._cachedSprite.anchor.x = -i.x / i.width, this._cachedSprite.anchor.y = -i.y / i.height, this._cachedSprite.buffer.context.translate(-i.x, -i.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
            }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
                var t = this._cachedSprite,
                    e = t.texture,
                    i = t.buffer.canvas;
                e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
            }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
                this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
            }, PIXI.Graphics.prototype.drawShape = function(t) {
                this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof X.Polygon && (t = t.clone()).flatten();
                t = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
                return this.graphicsData.push(t), t.type === PIXI.Graphics.POLY && (t.shape.closed = this.filling, this.currentPath = t), this.dirty = !0, this._boundsDirty = !0, t
            }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
                }
            }), PIXI.GraphicsData = function(t, e, i, s, n, a, o) {
                this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = a, this.shape = o, this.type = o.type
            }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
                return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
            }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
                i = i || 2;
                var s, n, a, o, r, h, l, c = e && e.length,
                    u = c ? e[0] * i : t.length,
                    d = PIXI.EarCut.linkedList(t, 0, u, i, !0),
                    p = [];
                if (!d) return p;
                if (c && (d = PIXI.EarCut.eliminateHoles(t, e, d, i)), t.length > 80 * i) {
                    s = a = t[0], n = o = t[1];
                    for (var f = i; f < u; f += i)(r = t[f]) < s && (s = r), (h = t[f + 1]) < n && (n = h), a < r && (a = r), o < h && (o = h);
                    l = Math.max(a - s, o - n)
                }
                return PIXI.EarCut.earcutLinked(d, p, i, s, n, l), p
            }, PIXI.EarCut.linkedList = function(t, e, i, s, n) {
                for (var a, o = 0, r = e, h = i - s; r < i; r += s) o += (t[h] - t[r]) * (t[r + 1] + t[h + 1]), h = r;
                if (n === 0 < o)
                    for (r = e; r < i; r += s) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
                else
                    for (r = i - s; e <= r; r -= s) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
                return a
            }, PIXI.EarCut.filterPoints = function(t, e) {
                if (!t) return t;
                e = e || t;
                var i, s = t;
                do {
                    if (i = !1, s.steiner || !PIXI.EarCut.equals(s, s.next) && 0 !== PIXI.EarCut.area(s.prev, s, s.next)) s = s.next;
                    else {
                        if (PIXI.EarCut.removeNode(s), (s = e = s.prev) === s.next) return null;
                        i = !0
                    }
                } while (i || s !== e);
                return e
            }, PIXI.EarCut.earcutLinked = function(t, e, i, s, n, a, o) {
                if (t) {
                    !o && a && PIXI.EarCut.indexCurve(t, s, n, a);
                    for (var r, h, l = t; t.prev !== t.next;)
                        if (r = t.prev, h = t.next, a ? PIXI.EarCut.isEarHashed(t, s, n, a) : PIXI.EarCut.isEar(t)) e.push(r.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                        else if ((t = h) === l) {
                        o ? 1 === o ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, s, n, a, 2)) : 2 === o && PIXI.EarCut.splitEarcut(t, e, i, s, n, a) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, s, n, a, 1);
                        break
                    }
                }
            }, PIXI.EarCut.isEar = function(t) {
                var e = t.prev,
                    i = t,
                    s = t.next;
                if (0 <= PIXI.EarCut.area(e, i, s)) return !1;
                for (var n = t.next.next; n !== t.prev;) {
                    if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, n.x, n.y) && 0 <= PIXI.EarCut.area(n.prev, n, n.next)) return !1;
                    n = n.next
                }
                return !0
            }, PIXI.EarCut.isEarHashed = function(t, e, i, s) {
                var n = t.prev,
                    a = t,
                    o = t.next;
                if (0 <= PIXI.EarCut.area(n, a, o)) return !1;
                for (var r = (n.x < a.x ? n.x < o.x ? n : o : a.x < o.x ? a : o).x, h = (n.y < a.y ? n.y < o.y ? n : o : a.y < o.y ? a : o).y, l = (n.x > a.x ? n.x > o.x ? n : o : a.x > o.x ? a : o).x, c = (n.y > a.y ? n.y > o.y ? n : o : a.y > o.y ? a : o).y, u = PIXI.EarCut.zOrder(r, h, e, i, s), d = PIXI.EarCut.zOrder(l, c, e, i, s), p = t.nextZ; p && p.z <= d;) {
                    if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
                    p = p.nextZ
                }
                for (p = t.prevZ; p && p.z >= u;) {
                    if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
                    p = p.prevZ
                }
                return !0
            }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
                var s = t;
                do {
                    var n = s.prev,
                        a = s.next.next
                } while (PIXI.EarCut.intersects(n, s, s.next, a) && PIXI.EarCut.locallyInside(n, a) && PIXI.EarCut.locallyInside(a, n) && (e.push(n.i / i), e.push(s.i / i), e.push(a.i / i), PIXI.EarCut.removeNode(s), PIXI.EarCut.removeNode(s.next), s = t = a), (s = s.next) !== t);
                return s
            }, PIXI.EarCut.splitEarcut = function(t, e, i, s, n, a) {
                var o = t;
                do {
                    for (var r = o.next.next; r !== o.prev;) {
                        if (o.i !== r.i && PIXI.EarCut.isValidDiagonal(o, r)) {
                            var h = PIXI.EarCut.splitPolygon(o, r),
                                o = PIXI.EarCut.filterPoints(o, o.next),
                                h = PIXI.EarCut.filterPoints(h, h.next);
                            return PIXI.EarCut.earcutLinked(o, e, i, s, n, a), void PIXI.EarCut.earcutLinked(h, e, i, s, n, a)
                        }
                        r = r.next
                    }
                } while ((o = o.next) !== t)
            }, PIXI.EarCut.eliminateHoles = function(t, e, i, s) {
                for (var n, a, o = [], r = 0, h = e.length; r < h; r++) n = e[r] * s, a = r < h - 1 ? e[r + 1] * s : t.length, (a = PIXI.EarCut.linkedList(t, n, a, s, !1)) === a.next && (a.steiner = !0), o.push(PIXI.EarCut.getLeftmost(a));
                for (o.sort(compareX), r = 0; r < o.length; r++) PIXI.EarCut.eliminateHole(o[r], i), i = PIXI.EarCut.filterPoints(i, i.next);
                return i
            }, PIXI.EarCut.compareX = function(t, e) {
                return t.x - e.x
            }, PIXI.EarCut.eliminateHole = function(t, e) {
                (e = PIXI.EarCut.findHoleBridge(t, e)) && (t = PIXI.EarCut.splitPolygon(e, t), PIXI.EarCut.filterPoints(t, t.next))
            }, PIXI.EarCut.findHoleBridge = function(t, e) {
                var i, s, n = e,
                    a = t.x,
                    o = t.y,
                    r = -1 / 0;
                do {} while (o <= n.y && o >= n.next.y && ((s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y)) <= a && r < s && (r = s, i = n.x < n.next.x ? n : n.next)), (n = n.next) !== e);
                if (!i) return null;
                if (t.x === i.x) return i.prev;
                for (var h, l = i, c = 1 / 0, n = i.next; n !== l;) a >= n.x && n.x >= i.x && PIXI.EarCut.pointInTriangle(o < i.y ? a : r, o, i.x, i.y, o < i.y ? r : a, o, n.x, n.y) && ((h = Math.abs(o - n.y) / (a - n.x)) < c || h === c && n.x > i.x) && PIXI.EarCut.locallyInside(n, t) && (i = n, c = h), n = n.next;
                return i
            }, PIXI.EarCut.indexCurve = function(t, e, i, s) {
                for (var n = t; null === n.z && (n.z = PIXI.EarCut.zOrder(n.x, n.y, e, i, s)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next, n !== t;);
                n.prevZ.nextZ = null, n.prevZ = null, PIXI.EarCut.sortLinked(n)
            }, PIXI.EarCut.sortLinked = function(t) {
                var e, i, s, n, a, o, r, h, l = 1;
                do {
                    for (i = t, a = t = null, o = 0; i;) {
                        for (o++, s = i, e = r = 0; e < l && (r++, s = s.nextZ); e++);
                        for (h = l; 0 < r || 0 < h && s;) 0 !== r && (0 === h || !s || i.z <= s.z) ? (i = (n = i).nextZ, r--) : (s = (n = s).nextZ, h--), a ? a.nextZ = n : t = n, n.prevZ = a, a = n;
                        i = s
                    }
                } while (a.nextZ = null, l *= 2, 1 < o);
                return t
            }, PIXI.EarCut.zOrder = function(t, e, i, s, n) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }, PIXI.EarCut.getLeftmost = function(t) {
                for (var e = t, i = t; e.x < i.x && (i = e), e = e.next, e !== t;);
                return i
            }, PIXI.EarCut.pointInTriangle = function(t, e, i, s, n, a, o, r) {
                return 0 <= (n - o) * (e - r) - (t - o) * (a - r) && 0 <= (t - o) * (s - r) - (i - o) * (e - r) && 0 <= (i - o) * (a - r) - (n - o) * (s - r)
            }, PIXI.EarCut.isValidDiagonal = function(t, e) {
                return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
            }, PIXI.EarCut.area = function(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }, PIXI.EarCut.equals = function(t, e) {
                return t.x === e.x && t.y === e.y
            }, PIXI.EarCut.intersects = function(t, e, i, s) {
                return 0 < PIXI.EarCut.area(t, e, i) != 0 < PIXI.EarCut.area(t, e, s) && 0 < PIXI.EarCut.area(i, s, t) != 0 < PIXI.EarCut.area(i, s, e)
            }, PIXI.EarCut.intersectsPolygon = function(t, e) {
                var i = t;
                do {
                    if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0
                } while ((i = i.next) !== t);
                return !1
            }, PIXI.EarCut.locallyInside = function(t, e) {
                return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? 0 <= PIXI.EarCut.area(t, e, t.next) && 0 <= PIXI.EarCut.area(t, t.prev, e) : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
            }, PIXI.EarCut.middleInside = function(t, e) {
                for (var i = t, s = !1, n = (t.x + e.x) / 2, a = (t.y + e.y) / 2; i.y > a != i.next.y > a && n < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next, i !== t;);
                return s
            }, PIXI.EarCut.splitPolygon = function(t, e) {
                var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                    s = new PIXI.EarCut.Node(e.i, e.x, e.y),
                    n = t.next,
                    a = e.prev;
                return (t.next = e).prev = t, (i.next = n).prev = i, (s.next = i).prev = s, (a.next = s).prev = a, s
            }, PIXI.EarCut.insertNode = function(t, e, i, s) {
                i = new PIXI.EarCut.Node(t, e, i);
                return s ? (i.next = s.next, (i.prev = s).next.prev = i, s.next = i) : (i.prev = i).next = i, i
            }, PIXI.EarCut.removeNode = function(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }, PIXI.EarCut.Node = function(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
                var i, s = e.gl,
                    n = e.projection,
                    a = e.offset,
                    o = e.shaderManager.primitiveShader;
                t.dirty && PIXI.WebGLGraphics.updateGraphics(t, s);
                for (var r = t._webGL[s.id], h = 0; h < r.data.length; h++) 1 === r.data[h].mode ? (i = r.data[h], e.stencilManager.pushStencil(t, i, e), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = r.data[h], e.shaderManager.setShader(o), o = e.shaderManager.primitiveShader, s.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(o.flipY, 1), s.uniform2f(o.projectionVector, n.x, -n.y), s.uniform2f(o.offsetVector, -a.x, -a.y), s.uniform3fv(o.tintColor, PIXI.hex2rgb(t.tint)), s.uniform1f(o.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(o.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer), s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
            }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
                var i, s = (s = t._webGL[e.id]) || (t._webGL[e.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: e
                });
                if (t.dirty = !1, t.clearDirty) {
                    for (t.clearDirty = !1, i = 0; i < s.data.length; i++) {
                        var n = s.data[i];
                        n.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(n)
                    }
                    s.data = [], s.lastIndex = 0
                }
                for (i = s.lastIndex; i < t.graphicsData.length; i++) {
                    var a, o = t.graphicsData[i];
                    o.type === PIXI.Graphics.POLY ? (o.points = o.shape.points.slice(), o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])), o.fill && o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (a = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildPoly(o, a) || (a = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a))) : (a = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a))), 0 < o.lineWidth && (a = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildLine(o, a))) : (a = PIXI.WebGLGraphics.switchMode(s, 0), o.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(o, a) : o.type === PIXI.Graphics.CIRC || o.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(o, a) : o.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(o, a)), s.lastIndex++
                }
                for (i = 0; i < s.data.length; i++)(a = s.data[i]).dirty && a.upload()
            }, PIXI.WebGLGraphics.switchMode = function(t, e) {
                var i;
                return t.data.length ? (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)) : ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
            }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
                var i, s, n, a, o, r, h = t.shape,
                    l = h.x,
                    c = h.y,
                    u = h.width,
                    d = h.height;
                t.fill && (r = PIXI.hex2rgb(t.fillColor), i = t.fillAlpha, s = r[0] * i, n = r[1] * i, a = r[2] * i, o = e.points, h = e.indices, r = o.length / 6, o.push(l, c), o.push(s, n, a, i), o.push(l + u, c), o.push(s, n, a, i), o.push(l, c + d), o.push(s, n, a, i), o.push(l + u, c + d), o.push(s, n, a, i), h.push(r, r, 1 + r, 2 + r, 3 + r, 3 + r)), t.lineWidth && (r = t.points, t.points = [l, c, l + u, c, l + u, c + d, l, c + d, l, c], PIXI.WebGLGraphics.buildLine(t, e), t.points = r)
            }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
                var i = t.shape,
                    s = i.x,
                    n = i.y,
                    a = i.width,
                    o = i.height,
                    i = i.radius,
                    r = [];
                if (r.push(s, n + i), r = (r = (r = (r = r.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, n + o - i, s, n + o, s + i, n + o))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a - i, n + o, s + a, n + o, s + a, n + o - i))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a, n + i, s + a, n, s + a - i, n))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + i, n, s, n, s, n + i)), t.fill) {
                    for (var h = PIXI.hex2rgb(t.fillColor), l = t.fillAlpha, c = h[0] * l, u = h[1] * l, d = h[2] * l, p = e.points, f = e.indices, g = p.length / 6, m = PIXI.EarCut.Triangulate(r, null, 2), y = 0, y = 0; y < m.length; y += 3) f.push(m[y] + g), f.push(m[y] + g), f.push(m[y + 1] + g), f.push(m[y + 2] + g), f.push(m[y + 2] + g);
                    for (y = 0; y < r.length; y++) p.push(r[y], r[++y], c, u, d, l)
                }
                t.lineWidth && (h = t.points, t.points = r, PIXI.WebGLGraphics.buildLine(t, e), t.points = h)
            }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, a) {
                function o(t, e, i) {
                    return t + (e - t) * i
                }
                for (var r, h, l, c, u, d = [], p = 0; p <= 20; p++) r = o(t, i, u = p / 20), h = o(e, s, u), l = o(i, n, u), c = o(s, a, u), l = o(r, l, u), c = o(h, c, u), d.push(l, c);
                return d
            }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
                var i, s = t.shape,
                    n = s.x,
                    a = s.y,
                    o = t.type === PIXI.Graphics.CIRC ? (i = s.radius, s.radius) : (i = s.width, s.height),
                    r = 2 * Math.PI / 40,
                    h = 0;
                if (t.fill) {
                    var l = PIXI.hex2rgb(t.fillColor),
                        c = t.fillAlpha,
                        u = l[0] * c,
                        d = l[1] * c,
                        p = l[2] * c,
                        f = e.points,
                        g = e.indices,
                        m = f.length / 6;
                    for (g.push(m), h = 0; h < 41; h++) f.push(n, a, u, d, p, c), f.push(n + Math.sin(r * h) * i, a + Math.cos(r * h) * o, u, d, p, c), g.push(m++, m++);
                    g.push(m - 1)
                }
                if (t.lineWidth) {
                    l = t.points;
                    for (t.points = [], h = 0; h < 41; h++) t.points.push(n + Math.sin(r * h) * i, a + Math.cos(r * h) * o);
                    PIXI.WebGLGraphics.buildLine(t, e), t.points = l
                }
            }, PIXI.WebGLGraphics.buildLine = function(t, e) {
                var i = 0,
                    s = t.points;
                if (0 !== s.length) {
                    if (t.lineWidth % 2)
                        for (i = 0; i < s.length; i++) s[i] += .5;
                    var n, a = new PIXI.Point(s[0], s[1]),
                        o = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
                    a.x === o.x && a.y === o.y && ((s = s.slice()).pop(), s.pop(), n = (o = new PIXI.Point(s[s.length - 2], s[s.length - 1])).x + .5 * (a.x - o.x), o = o.y + .5 * (a.y - o.y), s.unshift(n, o), s.push(n, o));
                    var r, h, l, c, u, d, p, f, g, m = e.points,
                        y = e.indices,
                        b = s.length / 2,
                        v = s.length,
                        _ = m.length / 6,
                        x = t.lineWidth / 2,
                        e = PIXI.hex2rgb(t.lineColor),
                        w = t.lineAlpha,
                        P = e[0] * w,
                        T = e[1] * w,
                        S = e[2] * w,
                        C = s[0],
                        A = s[1],
                        E = s[2],
                        I = s[3],
                        B = -(A - I),
                        M = C - E,
                        k = Math.sqrt(B * B + M * M);
                    for (B /= k, M /= k, B *= x, M *= x, m.push(C - B, A - M, P, T, S, w), m.push(C + B, A + M, P, T, S, w), i = 1; i < b - 1; i++) C = s[2 * (i - 1)], A = s[2 * (i - 1) + 1], E = s[2 * i], I = s[2 * i + 1], c = s[2 * (i + 1)], g = s[2 * (i + 1) + 1], B = -(A - I), M = C - E, B /= k = Math.sqrt(B * B + M * M), M /= k, B *= x, M *= x, r = -(I - g), h = E - c, r /= k = Math.sqrt(r * r + h * h), h /= k, u = (-B + C) * (-M + I) - (-B + E) * (-M + A), f = (-(r *= x) + c) * (-(h *= x) + I) - (-r + E) * (-h + g), g = (l = -M + A - (-M + I)) * (p = -r + E - (-r + c)) - (d = -h + g - (-h + I)) * (c = -B + E - (-B + C)), Math.abs(g) < .1 ? (g += 10.1, m.push(E - B, I - M, P, T, S, w), m.push(E + B, I + M, P, T, S, w)) : 19600 < ((p = (c * f - p * u) / g) - E) * (p - E) + ((g = (d * u - l * f) / g) - I) + (g - I) ? (r = B - r, h = M - h, r /= k = Math.sqrt(r * r + h * h), h /= k, r *= x, h *= x, m.push(E - r, I - h), m.push(P, T, S, w), m.push(E + r, I + h), m.push(P, T, S, w), m.push(E - r, I - h), m.push(P, T, S, w), v++) : (m.push(p, g), m.push(P, T, S, w), m.push(E - (p - E), I - (g - I)), m.push(P, T, S, w));
                    for (C = s[2 * (b - 2)], A = s[2 * (b - 2) + 1], E = s[2 * (b - 1)], B = -(A - (I = s[2 * (b - 1) + 1])), M = C - E, B /= k = Math.sqrt(B * B + M * M), M /= k, B *= x, M *= x, m.push(E - B, I - M), m.push(P, T, S, w), m.push(E + B, I + M), m.push(P, T, S, w), y.push(_), i = 0; i < v; i++) y.push(_++);
                    y.push(_ - 1)
                }
            }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
                var i = t.points.slice();
                if (!(i.length < 6)) {
                    var s = e.indices;
                    e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                    for (var n, a = 1 / 0, o = -1 / 0, r = 1 / 0, h = -1 / 0, l = 0; l < i.length; l += 2) a = (n = i[l]) < a ? n : a, o = o < n ? n : o, r = (n = i[l + 1]) < r ? n : r, h = h < n ? n : h;
                    i.push(a, r, o, r, o, h, a, h);
                    for (var c = i.length / 2, l = 0; l < c; l++) s.push(l)
                }
            }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
                var i = t.points;
                if (!(i.length < 6)) {
                    var s = e.points,
                        n = e.indices,
                        a = i.length / 2,
                        e = PIXI.hex2rgb(t.fillColor),
                        o = t.fillAlpha,
                        r = e[0] * o,
                        h = e[1] * o,
                        l = e[2] * o,
                        c = PIXI.EarCut.Triangulate(i, null, 2);
                    if (!c) return !1;
                    for (var u = s.length / 6, d = 0, d = 0; d < c.length; d += 3) n.push(c[d] + u), n.push(c[d] + u), n.push(c[d + 1] + u), n.push(c[d + 2] + u), n.push(c[d + 2] + u);
                    for (d = 0; d < a; d++) s.push(i[2 * d], i[2 * d + 1], r, h, l, o);
                    return !0
                }
            }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
                this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
            }, PIXI.WebGLGraphicsData.prototype.reset = function() {
                this.points = [], this.indices = []
            }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                var t = this.gl;
                this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
            }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
                var i = t.worldAlpha;
                t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
                for (var s = 0; s < t.graphicsData.length; s++) {
                    var n, a, o, r, h, l, c, u, d = t.graphicsData[s],
                        p = d.shape,
                        f = d._fillTint,
                        g = d._lineTint;
                    if (e.lineWidth = d.lineWidth, d.type === PIXI.Graphics.POLY) {
                        e.beginPath();
                        var m = p.points;
                        e.moveTo(m[0], m[1]);
                        for (var y = 1; y < m.length / 2; y++) e.lineTo(m[2 * y], m[2 * y + 1]);
                        p.closed && e.lineTo(m[0], m[1]), m[0] === m[m.length - 2] && m[1] === m[m.length - 1] && e.closePath(), d.fill && (e.globalAlpha = d.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | f).toString(16)).substr(-6), e.fill()), d.lineWidth && (e.globalAlpha = d.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), e.stroke())
                    } else d.type === PIXI.Graphics.RECT ? (!d.fillColor && 0 !== d.fillColor || (e.globalAlpha = d.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | f).toString(16)).substr(-6), e.fillRect(p.x, p.y, p.width, p.height)), d.lineWidth && (e.globalAlpha = d.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), e.strokeRect(p.x, p.y, p.width, p.height))) : d.type === PIXI.Graphics.CIRC ? (e.beginPath(), e.arc(p.x, p.y, p.radius, 0, 2 * Math.PI), e.closePath(), d.fill && (e.globalAlpha = d.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | f).toString(16)).substr(-6), e.fill()), d.lineWidth && (e.globalAlpha = d.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), e.stroke())) : d.type === PIXI.Graphics.ELIP ? (o = 2 * p.width, u = 2 * p.height, c = p.x - o / 2, n = p.y - u / 2, e.beginPath(), r = o / 2 * .5522848, l = u / 2 * .5522848, a = c + o, h = n + u, o = c + o / 2, u = n + u / 2, e.moveTo(c, u), e.bezierCurveTo(c, u - l, o - r, n, o, n), e.bezierCurveTo(o + r, n, a, u - l, a, u), e.bezierCurveTo(a, u + l, o + r, h, o, h), e.bezierCurveTo(o - r, h, c, u + l, c, u), e.closePath(), d.fill && (e.globalAlpha = d.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | f).toString(16)).substr(-6), e.fill()), d.lineWidth && (e.globalAlpha = d.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), e.stroke())) : d.type === PIXI.Graphics.RREC && (r = p.x, h = p.y, l = p.width, c = p.height, u = p.radius, u = (p = Math.min(l, c) / 2 | 0) < u ? p : u, e.beginPath(), e.moveTo(r, h + u), e.lineTo(r, h + c - u), e.quadraticCurveTo(r, h + c, r + u, h + c), e.lineTo(r + l - u, h + c), e.quadraticCurveTo(r + l, h + c, r + l, h + c - u), e.lineTo(r + l, h + u), e.quadraticCurveTo(r + l, h, r + l - u, h), e.lineTo(r + u, h), e.quadraticCurveTo(r, h, r, h + u), e.closePath(), !d.fillColor && 0 !== d.fillColor || (e.globalAlpha = d.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | f).toString(16)).substr(-6), e.fill()), d.lineWidth && (e.globalAlpha = d.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), e.stroke()))
                }
            }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
                var i = t.graphicsData.length;
                if (0 !== i) {
                    e.beginPath();
                    for (var s = 0; s < i; s++) {
                        var n, a, o, r, h, l, c, u, d = t.graphicsData[s],
                            p = d.shape;
                        if (d.type === PIXI.Graphics.POLY) {
                            var f = p.points;
                            e.moveTo(f[0], f[1]);
                            for (var g = 1; g < f.length / 2; g++) e.lineTo(f[2 * g], f[2 * g + 1]);
                            f[0] === f[f.length - 2] && f[1] === f[f.length - 1] && e.closePath()
                        } else d.type === PIXI.Graphics.RECT ? (e.rect(p.x, p.y, p.width, p.height), e.closePath()) : d.type === PIXI.Graphics.CIRC ? (e.arc(p.x, p.y, p.radius, 0, 2 * Math.PI), e.closePath()) : d.type === PIXI.Graphics.ELIP ? (a = (r = 2 * p.width) / 2 * .5522848, l = (u = 2 * p.height) / 2 * .5522848, o = (c = p.x - r / 2) + r, h = (n = p.y - u / 2) + u, r = c + r / 2, u = n + u / 2, e.moveTo(c, u), e.bezierCurveTo(c, u - l, r - a, n, r, n), e.bezierCurveTo(r + a, n, o, u - l, o, u), e.bezierCurveTo(o, u + l, r + a, h, r, h), e.bezierCurveTo(r - a, h, c, u + l, c, u), e.closePath()) : d.type === PIXI.Graphics.RREC && (h = p.x, l = p.y, c = p.width, u = p.height, d = p.radius, d = (p = Math.min(c, u) / 2 | 0) < d ? p : d, e.moveTo(h, l + d), e.lineTo(h, l + u - d), e.quadraticCurveTo(h, l + u, h + d, l + u), e.lineTo(h + c - d, l + u), e.quadraticCurveTo(h + c, l + u, h + c, l + u - d), e.lineTo(h + c, l + d), e.quadraticCurveTo(h + c, l, h + c - d, l), e.lineTo(h + d, l), e.quadraticCurveTo(h, l, h, l + d), e.closePath())
                    }
                }
            }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
                if (16777215 !== t.tint)
                    for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                        var a = t.graphicsData[n],
                            o = 0 | a.fillColor,
                            r = 0 | a.lineColor;
                        a._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, a._lineTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * s * 255
                    }
            }, X.Graphics = function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = X.GRAPHICS, this.physicsType = X.SPRITE, this.anchor = new X.Point, PIXI.Graphics.call(this), X.Component.Core.init.call(this, t, e, i, "", null)
            }, X.Graphics.prototype = Object.create(PIXI.Graphics.prototype), X.Graphics.prototype.constructor = X.Graphics, X.Component.Core.install.call(X.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), X.Graphics.prototype.preUpdatePhysics = X.Component.PhysicsBody.preUpdate, X.Graphics.prototype.preUpdateLifeSpan = X.Component.LifeSpan.preUpdate, X.Graphics.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.Graphics.prototype.preUpdateCore = X.Component.Core.preUpdate, X.Graphics.prototype.preUpdate = function() {
                return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.Graphics.prototype.postUpdate = function() {
                X.Component.PhysicsBody.postUpdate.call(this), X.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }, X.Graphics.prototype.destroy = function(t) {
                this.clear(), X.Component.Destroy.prototype.destroy.call(this, t)
            }, X.Graphics.prototype.drawTriangle = function(t, e) {
                void 0 === e && (e = !1);
                var i, s = new X.Polygon(t);
                e ? (i = new X.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y), e = new X.Point(t[1].x - t[0].x, t[1].y - t[0].y), e = new X.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(e), 0 < i.dot(e) && this.drawPolygon(s)) : this.drawPolygon(s)
            }, X.Graphics.prototype.drawTriangles = function(t, e, i) {
                void 0 === i && (i = !1);
                var s, n = new X.Point,
                    a = new X.Point,
                    o = new X.Point,
                    r = [];
                if (e)
                    if (t[0] instanceof X.Point)
                        for (s = 0; s < e.length / 3; s++) r.push(t[e[3 * s]]), r.push(t[e[3 * s + 1]]), r.push(t[e[3 * s + 2]]), 3 === r.length && (this.drawTriangle(r, i), r = []);
                    else
                        for (s = 0; s < e.length; s++) n.x = t[2 * e[s]], n.y = t[2 * e[s] + 1], r.push(n.copyTo({})), 3 === r.length && (this.drawTriangle(r, i), r = []);
                else if (t[0] instanceof X.Point)
                    for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], i);
                else
                    for (s = 0; s < t.length / 6; s++) n.x = t[6 * s + 0], n.y = t[6 * s + 1], a.x = t[6 * s + 2], a.y = t[6 * s + 3], o.x = t[6 * s + 4], o.y = t[6 * s + 5], this.drawTriangle([n, a, o], i)
            }, X.RenderTexture = function(t, e, i, s, n, a) {
                void 0 === s && (s = ""), void 0 === n && (n = X.scaleModes.DEFAULT), void 0 === a && (a = 1), this.game = t, this.key = s, this.type = X.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, i, this.game.renderer, n, a), this.render = X.RenderTexture.prototype.render
            }, X.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), X.RenderTexture.prototype.constructor = X.RenderTexture, X.RenderTexture.prototype.renderXY = function(t, e, i, s) {
                t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
            }, X.RenderTexture.prototype.renderRawXY = function(t, e, i, s) {
                this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
            }, X.RenderTexture.prototype.render = function(t, e, i) {
                null == e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
            }, X.Text = function(t, e, i, s, n) {
                e = e || 0, i = i || 0, s = null == s ? "" : s.toString(), n = X.Utils.extend({}, n), this.type = X.TEXT, this.physicsType = X.SPRITE, this.padding = new X.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, X.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(n), "" !== s && this.updateText()
            }, X.Text.prototype = Object.create(X.Sprite.prototype), X.Text.prototype.constructor = X.Text, X.Text.prototype.preUpdate = function() {
                return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.Text.prototype.update = function() {}, X.Text.prototype.destroy = function(t) {
                this.texture.destroy(!0), X.Component.Destroy.prototype.destroy.call(this, t)
            }, X.Text.prototype.setShadow = function(t, e, i, s, n, a) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === a && (a = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = a, this.dirty = !0, this
            }, X.Text.prototype.setStyle = function(t, e) {
                void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
                var i = this.fontToComponents(t.font);
                return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
            }, X.Text.prototype.updateText = function() {
                this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
                var t = this.text;
                this.style.wordWrap && (t = this.runWordWrap(this.text));
                var e = t.split(/(?:\r\n|\r|\n)/),
                    i = this.style.tabs,
                    s = [],
                    n = 0,
                    a = this.determineFontProperties(this.style.font),
                    o = e.length;
                0 < this.style.maxLines && this.style.maxLines < e.length && (o = this.style.maxLines);
                for (var r = this._charCount = 0; r < o; r++) {
                    if (0 === i) {
                        var h = this.style.strokeThickness + this.padding.x;
                        0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(e[r]) : h += this.context.measureText(e[r]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                    } else {
                        var l = e[r].split(/(?:\t)/),
                            h = this.padding.x + this.style.strokeThickness;
                        if (Array.isArray(i))
                            for (var c = 0, u = 0; u < l.length; u++) {
                                var d = 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width);
                                0 < u && (c += i[u - 1]), h = c + d
                            } else
                                for (u = 0; u < l.length; u++) 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u]).width), h += this.game.math.snapToCeil(h, i) - h
                    }
                    s[r] = Math.ceil(h), n = Math.max(n, s[r])
                }
                this.canvas.width = n * this._res;
                var p, f, g = a.fontSize + this.style.strokeThickness + this.padding.y,
                    t = g * o,
                    m = this._lineSpacing;
                for (m < 0 && Math.abs(m) > g && (m = -g), 0 !== m && (t += 0 < m ? m * e.length : m * (e.length - 1)), this.canvas.height = t * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", r = this._charCount = 0; r < o; r++) p = this.style.strokeThickness / 2, f = this.style.strokeThickness / 2 + r * g + a.ascent, 0 < r && (f += m * r), "right" === this.style.align ? p += n - s[r] : "center" === this.style.align && (p += (n - s[r]) / 2), this.autoRound && (p = Math.round(p), f = Math.round(f)), 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.updateLine(e[r], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[r], p, f) : this.renderTabLine(e[r], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[r], p, f) : this.renderTabLine(e[r], p, f, !0)));
                this.updateTexture(), this.dirty = !1
            }, X.Text.prototype.renderTabLine = function(t, e, i, s) {
                var n = t.split(/(?:\t)/),
                    a = this.style.tabs,
                    o = 0;
                if (Array.isArray(a))
                    for (var r = 0, h = 0; h < n.length; h++) 0 < h && (r += a[h - 1]), o = e + r, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
                else
                    for (h = 0; h < n.length; h++) {
                        var l = Math.ceil(this.context.measureText(n[h]).width),
                            o = this.game.math.snapToCeil(e, a);
                        s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + l
                    }
            }, X.Text.prototype.updateShadow = function(t) {
                t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
            }, X.Text.prototype.measureLine = function(t) {
                for (var e = 0, i = 0; i < t.length; i++) {
                    var s, n = t[i];
                    (0 < this.fontWeights.length || 0 < this.fontStyles.length) && (s = this.fontToComponents(this.context.font), this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s)), this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(n).width, this._charCount++
                }
                return Math.ceil(e)
            }, X.Text.prototype.updateLine = function(t, e, i) {
                for (var s = 0; s < t.length; s++) {
                    var n, a = t[s];
                    (0 < this.fontWeights.length || 0 < this.fontStyles.length) && (n = this.fontToComponents(this.context.font), this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)), this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(a, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(a, e, i)), e += this.context.measureText(a).width, this._charCount++
                }
            }, X.Text.prototype.clearColors = function() {
                return this.colors = [], this.strokeColors = [], this.dirty = !0, this
            }, X.Text.prototype.clearFontValues = function() {
                return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
            }, X.Text.prototype.addColor = function(t, e) {
                return this.colors[e] = t, this.dirty = !0, this
            }, X.Text.prototype.addStrokeColor = function(t, e) {
                return this.strokeColors[e] = t, this.dirty = !0, this
            }, X.Text.prototype.addFontStyle = function(t, e) {
                return this.fontStyles[e] = t, this.dirty = !0, this
            }, X.Text.prototype.addFontWeight = function(t, e) {
                return this.fontWeights[e] = t, this.dirty = !0, this
            }, X.Text.prototype.precalculateWordWrap = function(t) {
                return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
            }, X.Text.prototype.runWordWrap = function(t) {
                return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
            }, X.Text.prototype.advancedWordWrap = function(t) {
                for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), a = n.length, o = 0; o < a; o++) {
                    var r = "",
                        h = (h = n[o]).replace(/^ *|\s*$/gi, "");
                    if (e.measureText(h).width < i) s += h + "\n";
                    else {
                        for (var l = i, c = h.split(" "), u = 0; u < c.length; u++) {
                            var d = c[u],
                                p = d + " ",
                                f = e.measureText(p).width;
                            if (l < f) {
                                if (0 === u) {
                                    for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l)););
                                    if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                    var m = d.substr(g.length);
                                    c[u] = m, r += g
                                }
                                m = c[u].length ? u : u + 1, m = c.slice(m).join(" ").replace(/[ \n]*$/gi, "");
                                n[o + 1] = m + " " + (n[o + 1] || ""), a = n.length;
                                break
                            }
                            r += p, l -= f
                        }
                        s += r.replace(/[ \n]*$/gi, "") + "\n"
                    }
                }
                return s.replace(/[\s|\n]*$/gi, "")
            }, X.Text.prototype.basicWordWrap = function(t) {
                for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                    for (var n = this.style.wordWrapWidth, a = i[s].split(" "), o = 0; o < a.length; o++) {
                        var r = this.context.measureText(a[o]).width,
                            h = r + this.context.measureText(" ").width;
                        n < h ? (0 < o && (e += "\n"), e += a[o] + " ", n = this.style.wordWrapWidth - r) : (n -= h, e += a[o] + " ")
                    }
                    s < i.length - 1 && (e += "\n")
                }
                return e
            }, X.Text.prototype.updateFont = function(t) {
                t = this.componentsToFont(t);
                this.style.font !== t && (this.style.font = t, this.dirty = !0, this.parent && this.updateTransform())
            }, X.Text.prototype.fontToComponents = function(t) {
                var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
                if (e) {
                    var i = e[5].trim();
                    return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                        font: t,
                        fontStyle: e[1] || "normal",
                        fontVariant: e[2] || "normal",
                        fontWeight: e[3] || "normal",
                        fontSize: e[4] || "medium",
                        fontFamily: i
                    }
                }
                return {
                    font: t
                }
            }, X.Text.prototype.componentsToFont = function(t) {
                var e = [],
                    i = t.fontStyle;
                return i && "normal" !== i && e.push(i), (i = t.fontVariant) && "normal" !== i && e.push(i), (i = t.fontWeight) && "normal" !== i && e.push(i), (i = t.fontSize) && "medium" !== i && e.push(i), (i = t.fontFamily) && e.push(i), e.length || e.push(t.font), e.join(" ")
            }, X.Text.prototype.setText = function(t, e) {
                return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
            }, X.Text.prototype.parseList = function(t) {
                if (!Array.isArray(t)) return this;
                for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
                return this.text = e, this.dirty = !0, this
            }, X.Text.prototype.setTextBounds = function(t, e, i, s) {
                return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, s) : this.textBounds = new X.Rectangle(t, e, i, s), this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)), this.updateTexture(), this
            }, X.Text.prototype.updateTexture = function() {
                var t = this.texture.baseTexture,
                    e = this.texture.crop,
                    i = this.texture.frame,
                    s = this.canvas.width,
                    n = this.canvas.height;
                t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds && (e = this.textBounds.x, i = this.textBounds.y, "right" === this.style.boundsAlignH ? e += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (e += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? i += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (i += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -e, this.pivot.y = -i), this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
            }, X.Text.prototype._renderWebGL = function(t) {
                this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
            }, X.Text.prototype._renderCanvas = function(t) {
                this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
            }, X.Text.prototype.determineFontProperties = function(t) {
                var e = X.Text.fontPropertiesCache[t];
                if (!e) {
                    e = {};
                    var i = X.Text.fontPropertiesCanvas,
                        s = X.Text.fontPropertiesContext;
                    s.font = t;
                    var n = Math.ceil(s.measureText("|MÃq").width),
                        a = 2 * (o = Math.ceil(s.measureText("|MÃq").width)),
                        o = 1.4 * o | 0;
                    if (i.width = n, i.height = a, s.fillStyle = "#f00", s.fillRect(0, 0, n, a), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|MÃq", 0, o), !s.getImageData(0, 0, n, a)) return e.ascent = o, e.descent = 6 + o, e.fontSize = e.ascent + e.descent, X.Text.fontPropertiesCache[t] = e;
                    for (var r, h = s.getImageData(0, 0, n, a).data, s = h.length, l = 4 * n, c = 0, u = !1, d = 0; d < o; d++) {
                        for (r = 0; r < l; r += 4)
                            if (255 !== h[c + r]) {
                                u = !0;
                                break
                            }
                        if (u) break;
                        c += l
                    }
                    for (e.ascent = o - d, c = s - l, u = !1, d = a; o < d; d--) {
                        for (r = 0; r < l; r += 4)
                            if (255 !== h[c + r]) {
                                u = !0;
                                break
                            }
                        if (u) break;
                        c -= l
                    }
                    e.descent = d - o, e.descent += 6, e.fontSize = e.ascent + e.descent, X.Text.fontPropertiesCache[t] = e
                }
                return e
            }, X.Text.prototype.getBounds = function(t) {
                return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
            }, Object.defineProperty(X.Text.prototype, "text", {
                get: function() {
                    return this._text
                },
                set: function(t) {
                    t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
                }
            }), Object.defineProperty(X.Text.prototype, "cssFont", {
                get: function() {
                    return this.componentsToFont(this._fontComponents)
                },
                set: function(t) {
                    t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "font", {
                get: function() {
                    return this._fontComponents.fontFamily
                },
                set: function(t) {
                    t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "fontSize", {
                get: function() {
                    var t = this._fontComponents.fontSize;
                    return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
                },
                set: function(t) {
                    "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "fontWeight", {
                get: function() {
                    return this._fontComponents.fontWeight || "normal"
                },
                set: function(t) {
                    t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "fontStyle", {
                get: function() {
                    return this._fontComponents.fontStyle || "normal"
                },
                set: function(t) {
                    t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "fontVariant", {
                get: function() {
                    return this._fontComponents.fontVariant || "normal"
                },
                set: function(t) {
                    t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
                }
            }), Object.defineProperty(X.Text.prototype, "fill", {
                get: function() {
                    return this.style.fill
                },
                set: function(t) {
                    t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "align", {
                get: function() {
                    return this.style.align
                },
                set: function(t) {
                    t !== this.style.align && (this.style.align = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "resolution", {
                get: function() {
                    return this._res
                },
                set: function(t) {
                    t !== this._res && (this._res = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "tabs", {
                get: function() {
                    return this.style.tabs
                },
                set: function(t) {
                    t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "boundsAlignH", {
                get: function() {
                    return this.style.boundsAlignH
                },
                set: function(t) {
                    t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "boundsAlignV", {
                get: function() {
                    return this.style.boundsAlignV
                },
                set: function(t) {
                    t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "stroke", {
                get: function() {
                    return this.style.stroke
                },
                set: function(t) {
                    t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "strokeThickness", {
                get: function() {
                    return this.style.strokeThickness
                },
                set: function(t) {
                    t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "wordWrap", {
                get: function() {
                    return this.style.wordWrap
                },
                set: function(t) {
                    t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "wordWrapWidth", {
                get: function() {
                    return this.style.wordWrapWidth
                },
                set: function(t) {
                    t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "lineSpacing", {
                get: function() {
                    return this._lineSpacing
                },
                set: function(t) {
                    t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
                }
            }), Object.defineProperty(X.Text.prototype, "shadowOffsetX", {
                get: function() {
                    return this.style.shadowOffsetX
                },
                set: function(t) {
                    t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "shadowOffsetY", {
                get: function() {
                    return this.style.shadowOffsetY
                },
                set: function(t) {
                    t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "shadowColor", {
                get: function() {
                    return this.style.shadowColor
                },
                set: function(t) {
                    t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "shadowBlur", {
                get: function() {
                    return this.style.shadowBlur
                },
                set: function(t) {
                    t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "shadowStroke", {
                get: function() {
                    return this.style.shadowStroke
                },
                set: function(t) {
                    t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "shadowFill", {
                get: function() {
                    return this.style.shadowFill
                },
                set: function(t) {
                    t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
                }
            }), Object.defineProperty(X.Text.prototype, "width", {
                get: function() {
                    return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
                },
                set: function(t) {
                    this.scale.x = t / this.texture.frame.width, this._width = t
                }
            }), Object.defineProperty(X.Text.prototype, "height", {
                get: function() {
                    return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
                },
                set: function(t) {
                    this.scale.y = t / this.texture.frame.height, this._height = t
                }
            }), X.Text.fontPropertiesCache = {}, X.Text.fontPropertiesCanvas = document.createElement("canvas"), X.Text.fontPropertiesContext = X.Text.fontPropertiesCanvas.getContext("2d"), X.BitmapText = function(t, e, i, s, n, a, o) {
                e = e || 0, i = i || 0, s = s || "", n = n || "", a = a || 32, o = o || "left", PIXI.DisplayObjectContainer.call(this), this.type = X.BITMAPTEXT, this.physicsType = X.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new X.Point, this._prevAnchor = new X.Point, this._glyphs = [], this._maxWidth = 0, this._text = n.toString() || "", this._data = t.cache.getBitmapFont(s), this._font = s, this._fontSize = a, this._align = o, this._tint = 16777215, this.updateText(), this.dirty = !1, X.Component.Core.init.call(this, t, e, i, "", null)
            }, X.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), X.BitmapText.prototype.constructor = X.BitmapText, X.Component.Core.install.call(X.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), X.BitmapText.prototype.preUpdatePhysics = X.Component.PhysicsBody.preUpdate, X.BitmapText.prototype.preUpdateLifeSpan = X.Component.LifeSpan.preUpdate, X.BitmapText.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.BitmapText.prototype.preUpdateCore = X.Component.Core.preUpdate, X.BitmapText.prototype.preUpdate = function() {
                return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.BitmapText.prototype.postUpdate = function() {
                X.Component.PhysicsBody.postUpdate.call(this), X.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === X.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
            }, X.BitmapText.prototype.setText = function(t) {
                this.text = t
            }, X.BitmapText.prototype.scanLine = function(t, e, i) {
                for (var s = 0, n = 0, a = -1, o = 0, r = null, h = 0 < this._maxWidth ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                    var u = c === i.length - 1;
                    if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                        width: n,
                        text: i.substr(0, c),
                        end: u,
                        chars: l
                    };
                    var d, p = i.charCodeAt(c),
                        f = t.chars[p];
                    void 0 === f && (p = 32, f = t.chars[p]);
                    var g = r && f.kerning[r] ? f.kerning[r] : 0;
                    if (/(\s)/.test(i.charAt(c)) && (a = c, o = n), d = (g + f.texture.width + f.xOffset) * e, h && h <= n + d && -1 < a) return {
                        width: o || n,
                        text: i.substr(0, c - (c - a)),
                        end: u,
                        chars: l
                    };
                    n += (f.xAdvance + g) * e, l.push(s + (f.xOffset + g) * e), s += (f.xAdvance + g) * e, r = p
                }
                return {
                    width: n,
                    text: i,
                    end: u,
                    chars: l
                }
            }, X.BitmapText.prototype.cleanText = function(t, e) {
                void 0 === e && (e = "");
                var i = this._data.font;
                if (!i) return "";
                for (var s = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), n = 0; n < s.length; n++) {
                    for (var a = "", o = s[n], r = 0; r < o.length; r++) a = i.chars[o.charCodeAt(r)] ? a.concat(o[r]) : a.concat(e);
                    s[n] = a
                }
                return s.join("\n")
            }, X.BitmapText.prototype.updateText = function() {
                var t = this._data.font;
                if (t) {
                    var e = this.text,
                        i = this._fontSize / t.size,
                        s = [],
                        n = 0;
                    this.textWidth = 0;
                    do {} while ((c = this.scanLine(t, i, e)).y = n, s.push(c), c.width > this.textWidth && (this.textWidth = c.width), n += t.lineHeight * i, e = e.substr(c.text.length + 1), !1 === c.end);
                    this.textHeight = n;
                    for (var a = 0, o = 0, r = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                        var c = s[l];
                        "right" === this._align ? o = this.textWidth - c.width : "center" === this._align && (o = (this.textWidth - c.width) / 2);
                        for (var u = 0; u < c.text.length; u++) {
                            var d = c.text.charCodeAt(u),
                                p = t.chars[d];
                            void 0 === p && (d = 32, p = t.chars[32]);
                            d = this._glyphs[a];
                            d ? d.texture = p.texture : ((d = new PIXI.Sprite(p.texture)).name = c.text[u], this._glyphs.push(d)), d.position.x = c.chars[u] + o - r, d.position.y = c.y + p.yOffset * i - h, d.scale.set(i), d.tint = this.tint, d.texture.requiresReTint = !0, d.parent || this.addChild(d), a++
                        }
                    }
                    for (l = a; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
                }
            }, X.BitmapText.prototype.purgeGlyphs = function() {
                for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
                return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
            }, X.BitmapText.prototype.updateTransform = function() {
                !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
            }, Object.defineProperty(X.BitmapText.prototype, "align", {
                get: function() {
                    return this._align
                },
                set: function(t) {
                    t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "tint", {
                get: function() {
                    return this._tint
                },
                set: function(t) {
                    t !== this._tint && (this._tint = t, this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "font", {
                get: function() {
                    return this._font
                },
                set: function(t) {
                    t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "fontSize", {
                get: function() {
                    return this._fontSize
                },
                set: function(t) {
                    (t = parseInt(t, 10)) !== this._fontSize && 0 < t && (this._fontSize = t, this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "text", {
                get: function() {
                    return this._text
                },
                set: function(t) {
                    t !== this._text && (this._text = t.toString() || "", this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "maxWidth", {
                get: function() {
                    return this._maxWidth
                },
                set: function(t) {
                    t !== this._maxWidth && (this._maxWidth = t, this.updateText())
                }
            }), Object.defineProperty(X.BitmapText.prototype, "smoothed", {
                get: function() {
                    return !this._data.base.scaleMode
                },
                set: function(t) {
                    this._data.base.scaleMode = t ? 0 : 1
                }
            }), X.RetroFont = function(t, e, i, s, n, a, o, r, h, l) {
                if (!t.cache.checkImageKey(e)) return !1;
                null != a || (a = t.cache.getImage(e).width / i), this.characterWidth = i, this.characterHeight = s, this.characterSpacingX = o || 0, this.characterSpacingY = r || 0, this.characterPerRow = a, this.offsetX = h || 0, this.offsetY = l || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new X.FrameData;
                for (var c = this.offsetX, u = this.offsetY, d = 0, p = 0; p < n.length; p++) {
                    var f = this.frameData.addFrame(new X.Frame(p, c, u, this.characterWidth, this.characterHeight));
                    this.grabData[n.charCodeAt(p)] = f.index, ++d === this.characterPerRow ? (d = 0, c = this.offsetX, u += this.characterHeight + this.characterSpacingY) : c += this.characterWidth + this.characterSpacingX
                }
                t.cache.updateFrameData(e, this.frameData), this.stamp = new X.Image(t, 0, 0, e, 0), X.RenderTexture.call(this, t, 100, 100, "", X.scaleModes.NEAREST), this.type = X.RETROFONT
            }, X.RetroFont.prototype = Object.create(X.RenderTexture.prototype), X.RetroFont.prototype.constructor = X.RetroFont, X.RetroFont.ALIGN_LEFT = "left", X.RetroFont.ALIGN_RIGHT = "right", X.RetroFont.ALIGN_CENTER = "center", X.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", X.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", X.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", X.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", X.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", X.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", X.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", X.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", X.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", X.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", X.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", X.RetroFont.prototype.setFixedWidth = function(t, e) {
                void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
            }, X.RetroFont.prototype.setText = function(t, e, i, s, n, a) {
                this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = n || "left", this.autoUpperCase = !a, 0 < t.length && (this.text = t)
            }, X.RetroFont.prototype.buildRetroFontText = function() {
                var t = 0,
                    e = 0;
                if (this.clear(), this.multiLine) {
                    var i = this._text.split("\n");
                    0 < this.fixedWidth ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                    for (var s = 0; s < i.length; s++) t = 0, this.align === X.RetroFont.ALIGN_RIGHT ? t = this.width - i[s].length * (this.characterWidth + this.customSpacingX) : this.align === X.RetroFont.ALIGN_CENTER && (t = this.width / 2 - i[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(i[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
                } else 0 < this.fixedWidth ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === X.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === X.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
                this.requiresReTint = !0
            }, X.RetroFont.prototype.pasteLine = function(t, e, i, s) {
                for (var n = 0; n < t.length; n++)
                    if (" " === t.charAt(n)) e += this.characterWidth + s;
                    else if (0 <= this.grabData[t.charCodeAt(n)] && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
            }, X.RetroFont.prototype.getLongestLine = function() {
                var t = 0;
                if (0 < this._text.length)
                    for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
                return t
            }, X.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
                for (var e = "", i = 0; i < this._text.length; i++) {
                    var s = this._text[i],
                        n = s.charCodeAt(0);
                    (0 <= this.grabData[n] || !t && "\n" === s) && (e = e.concat(s))
                }
                return e
            }, X.RetroFont.prototype.updateOffset = function(t, e) {
                if (this.offsetX !== t || this.offsetY !== e) {
                    for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), a = n.length; a--;) n[a].x += i, n[a].y += s;
                    this.buildRetroFontText()
                }
            }, Object.defineProperty(X.RetroFont.prototype, "text", {
                get: function() {
                    return this._text
                },
                set: function(t) {
                    (t = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = t, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
                }
            }), Object.defineProperty(X.RetroFont.prototype, "smoothed", {
                get: function() {
                    return this.stamp.smoothed
                },
                set: function(t) {
                    this.stamp.smoothed = t, this.buildRetroFontText()
                }
            }), X.Rope = function(t, e, i, s, n, a) {
                this.points = [], this.points = a, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = X.ROPE, PIXI.Rope.call(this, X.Cache.DEFAULT, this.points), X.Component.Core.init.call(this, t, e, i, s, n)
            }, X.Rope.prototype = Object.create(PIXI.Rope.prototype), X.Rope.prototype.constructor = X.Rope, X.Component.Core.install.call(X.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), X.Rope.prototype.preUpdatePhysics = X.Component.PhysicsBody.preUpdate, X.Rope.prototype.preUpdateLifeSpan = X.Component.LifeSpan.preUpdate, X.Rope.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.Rope.prototype.preUpdateCore = X.Component.Core.preUpdate, X.Rope.prototype.preUpdate = function() {
                return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.Rope.prototype.update = function() {
                this._hasUpdateAnimation && this.updateAnimation.call(this)
            }, X.Rope.prototype.reset = function(t, e) {
                return X.Component.Reset.prototype.reset.call(this, t, e), this
            }, Object.defineProperty(X.Rope.prototype, "updateAnimation", {
                get: function() {
                    return this._updateAnimation
                },
                set: function(t) {
                    t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
                }
            }), Object.defineProperty(X.Rope.prototype, "segments", {
                get: function() {
                    for (var t, e, i, s, n = [], a = 0; a < this.points.length; a++) s = 4 * a, t = this.vertices[s] * this.scale.x, e = this.vertices[1 + s] * this.scale.y, i = this.vertices[4 + s] * this.scale.x, s = this.vertices[3 + s] * this.scale.y, i = X.Math.difference(t, i), s = X.Math.difference(e, s), t += this.world.x, e += this.world.y, s = new X.Rectangle(t, e, i, s), n.push(s);
                    return n
                }
            }), X.TileSprite = function(t, e, i, s, n, a, o) {
                e = e || 0, i = i || 0, s = s || 256, n = n || 256, a = a || null, o = o || null, this.type = X.TILESPRITE, this.physicsType = X.SPRITE, this._scroll = new X.Point;
                var r = t.cache.getImage("__default", !0);
                PIXI.TilingSprite.call(this, new PIXI.Texture(r.base), s, n), X.Component.Core.init.call(this, t, e, i, a, o)
            }, X.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), X.TileSprite.prototype.constructor = X.TileSprite, X.Component.Core.install.call(X.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), X.TileSprite.prototype.preUpdatePhysics = X.Component.PhysicsBody.preUpdate, X.TileSprite.prototype.preUpdateLifeSpan = X.Component.LifeSpan.preUpdate, X.TileSprite.prototype.preUpdateInWorld = X.Component.InWorld.preUpdate, X.TileSprite.prototype.preUpdateCore = X.Component.Core.preUpdate, X.TileSprite.prototype.preUpdate = function() {
                return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
            }, X.TileSprite.prototype.autoScroll = function(t, e) {
                this._scroll.set(t, e)
            }, X.TileSprite.prototype.stopScroll = function() {
                this._scroll.set(0, 0)
            }, X.TileSprite.prototype.destroy = function(t) {
                X.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
            }, X.TileSprite.prototype.reset = function(t, e) {
                return X.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
            }, X.Device = function() {
                this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
            }, X.Device = new X.Device, X.Device.onInitialized = new X.Signal, X.Device.whenReady = function(t, e, i) {
                var s = this._readyCheck;
                this.deviceReadyAt || !s ? t.call(e, this) : s._monitor || i ? (s._queue = s._queue || [], s._queue.push([t, e])) : (s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]), t = void 0 !== window.cordova, e = navigator.isCocoonJS, "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : t && !e ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1)))
            }, X.Device._readyCheck = function() {
                var t = this._readyCheck;
                if (document.body) {
                    if (!this.deviceReadyAt) {
                        this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                        for (; i = t._queue.shift();) {
                            var e = i[0],
                                i = i[1];
                            e.call(i, this)
                        }
                        this._readyCheck = null, this._initialize = null, this.onInitialized = null
                    }
                } else window.setTimeout(t._monitor, 20)
            }, X.Device._initialize = function() {
                var t, e, n = this;
                (function() {
                    var t = navigator.userAgent;
                    /Playstation Vita/.test(t) ? n.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? n.kindle = !0 : /Android/.test(t) ? n.android = !0 : /CrOS/.test(t) ? n.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (n.iOS = !0, navigator.appVersion.match(/OS (\d+)/), n.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? n.linux = !0 : /Mac OS/.test(t) ? n.macOS = !0 : /Windows/.test(t) && (n.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (n.android = !1, n.iOS = !1, n.macOS = !1, n.windows = !0, n.windowsPhone = !0);
                    var e = /Silk/.test(t);
                    (n.windows || n.macOS || n.linux && !e || n.chromeOS) && (n.desktop = !0), (n.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (n.desktop = !1)
                })(),
                function() {
                    var t = navigator.userAgent;
                    if (/Arora/.test(t) ? n.arora = !0 : /Edge\/\d+/.test(t) ? n.edge = !0 : /Chrome\/(\d+)/.test(t) && !n.windowsPhone ? (n.chrome = !0, n.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? n.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (n.firefox = !0, n.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && n.iOS ? n.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (n.ie = !0, n.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? n.midori = !0 : /Opera/.test(t) ? n.opera = !0 : /Safari\/(\d+)/.test(t) && !n.windowsPhone ? (n.safari = !0, /Version\/(\d+)\./.test(t) && (n.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (n.ie = !0, n.trident = !0, n.tridentVersion = parseInt(RegExp.$1, 10), n.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (n.silk = !0), navigator.standalone && (n.webApp = !0), void 0 !== window.cordova && (n.cordova = !0), void 0 !== r && (n.node = !0), n.node && "object" == typeof r.versions && (n.nodeWebkit = !!r.versions["node-webkit"], n.electron = !!r.versions.electron), navigator.isCocoonJS && (n.cocoonJS = !0), n.cocoonJS) try {
                        n.cocoonJSApp = "undefined" != typeof CocoonJS
                    } catch (t) {
                        n.cocoonJSApp = !1
                    }
                    void 0 !== window.ejecta && (n.ejecta = !0), /Crosswalk/.test(t) && (n.crosswalk = !0)
                }(),
                function() {
                    n.audioData = !!window.Audio, n.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                    var t, e, i = document.createElement("audio");
                    try {
                        !!i.canPlayType && (i.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (n.ogg = !0), (i.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || i.canPlayType("audio/opus;").replace(/^no$/, "")) && (n.opus = !0), i.canPlayType("audio/mpeg;").replace(/^no$/, "") && (n.mp3 = !0), i.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (n.wav = !0), (i.canPlayType("audio/x-m4a;") || i.canPlayType("audio/aac;").replace(/^no$/, "")) && (n.m4a = !0), i.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (n.webm = !0), "" !== i.canPlayType('audio/mp4;codecs="ec-3"')) && (n.edge ? n.dolby = !0 : n.safari && 9 <= n.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent) && (t = parseInt(RegExp.$1, 10), e = parseInt(RegExp.$2, 10), (10 === t && 11 <= e || 10 < t) && (n.dolby = !0)))
                    } catch (i) {}
                }(),
                function() {
                    var t = document.createElement("video");
                    try {
                        !!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (n.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.h264Video = !0, n.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (n.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (n.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.hlsVideo = !0))
                    } catch (t) {}
                }(),
                function() {
                    var t, e, i = document.createElement("p"),
                        s = {
                            webkitTransform: "-webkit-transform",
                            OTransform: "-o-transform",
                            msTransform: "-ms-transform",
                            MozTransform: "-moz-transform",
                            transform: "transform"
                        };
                    for (e in document.body.insertBefore(i, null), s) void 0 !== i.style[e] && (i.style[e] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(i).getPropertyValue(s[e]));
                    document.body.removeChild(i), n.css3D = void 0 !== t && 0 < t.length && "none" !== t
                }(), n.pixelRatio = window.devicePixelRatio || 1, n.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), n.iPhone4 = 2 === n.pixelRatio && n.iPhone, n.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? n.typedArray = !0 : n.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (n.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), t = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === t[0] || 2712847316 !== t[0] && null), n.LITTLE_ENDIAN = n.littleEndian), n.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== n.littleEndian && function() {
                        if (void 0 === Uint8ClampedArray) return !1;
                        var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d");
                        return !!t && (t = t.createImageData(1, 1), PIXI.CanvasPool.remove(this), t.data instanceof Uint8ClampedArray)
                    }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (n.vibration = !0),
                    function() {
                        n.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS;
                        try {
                            n.localStorage = !!localStorage.getItem
                        } catch (e) {
                            n.localStorage = !1
                        }
                        n.file = !!(window.File && window.FileReader && window.FileList && window.Blob), n.fileSystem = !!window.requestFileSystem;
                        var e = {
                            stencil: !0
                        };
                        n.webGL = function() {
                            try {
                                var t = document.createElement("canvas");
                                return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl", e) || t.getContext("experimental-webgl", e))
                            } catch (t) {
                                return !1
                            }
                        }(), n.webGL = !!n.webGL, n.worker = !!window.Worker, n.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, n.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, n.getUserMedia = n.getUserMedia && !!navigator.getUserMedia && !!window.URL, n.firefox && n.firefoxVersion < 21 && (n.getUserMedia = !1), !n.iOS && (n.ie || n.firefox || n.chrome) && (n.canvasBitBltShift = !0), (n.safari || n.mobileSafari) && (n.canvasBitBltShift = !1)
                    }(),
                    function() {
                        for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                            if (e[t[i]]) {
                                n.fullscreen = !0, n.requestFullscreen = t[i];
                                break
                            }
                        var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                        if (n.fullscreen)
                            for (i = 0; i < s.length; i++)
                                if (document[s[i]]) {
                                    n.cancelFullscreen = s[i];
                                    break
                                }
                        window.Element && Element.ALLOW_KEYBOARD_INPUT && (n.fullscreenKeyboard = !0)
                    }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && 1 <= window.navigator.maxTouchPoints) && (n.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (n.mspointer = !0), n.cocoonJS || ("onwheel" in window || n.ie && "WheelEvent" in window ? n.wheelEvent = "wheel" : "onmousewheel" in window ? n.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent" in window && (n.wheelEvent = "DOMMouseScroll"))
            }, X.Device.canPlayAudio = function(t) {
                return !!("mp3" === t && this.mp3 || "ogg" === t && (this.ogg || this.opus) || "m4a" === t && this.m4a || "opus" === t && this.opus || "wav" === t && this.wav || "webm" === t && this.webm || "mp4" === t && this.dolby)
            }, X.Device.canPlayVideo = function(t) {
                return !!("webm" === t && (this.webmVideo || this.vp9Video) || "mp4" === t && (this.mp4Video || this.h264Video) || ("ogg" === t || "ogv" === t) && this.oggVideo || "mpeg" === t && this.hlsVideo)
            }, X.Device.isConsoleOpen = function() {
                return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && 0 < console.profiles.length
            }, X.Device.isAndroidStockBrowser = function() {
                var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                return t && t[1] < 537
            }, X.Canvas = {
                create: function(t, e, i, s, n) {
                    e = e || 256, i = i || 256;
                    t = n ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                    return "string" == typeof s && "" !== s && (t.id = s), t.width = e, t.height = i, t.style.display = "block", t
                },
                setBackgroundColor: function(t, e) {
                    return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
                },
                setTouchAction: function(t, e) {
                    return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
                },
                setUserSelect: function(t, e) {
                    return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
                },
                addToDOM: function(t, e, i) {
                    var s;
                    return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s = s || document.body, i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
                },
                removeFromDOM: function(t) {
                    t.parentNode && t.parentNode.removeChild(t)
                },
                setTransform: function(t, e, i, s, n, a, o) {
                    return t.setTransform(s, a, o, n, e, i), t
                },
                setSmoothingEnabled: function(t, e) {
                    var i = X.Canvas.getSmoothingPrefix(t);
                    return i && (t[i] = e), t
                },
                getSmoothingPrefix: function(t) {
                    var e, i = ["i", "webkitI", "msI", "mozI", "oI"];
                    for (e in i) {
                        var s = i[e] + "mageSmoothingEnabled";
                        if (s in t) return s
                    }
                    return null
                },
                getSmoothingEnabled: function(t) {
                    var e = X.Canvas.getSmoothingPrefix(t);
                    if (e) return t[e]
                },
                setImageRenderingCrisp: function(t) {
                    for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                    return t.style.msInterpolationMode = "nearest-neighbor", t
                },
                setImageRenderingBicubic: function(t) {
                    return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
                }
            }, X.RequestAnimationFrame = function(t, e) {
                void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
                for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"];
                this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
            }, X.RequestAnimationFrame.prototype = {
                start: function() {
                    this.isRunning = !0;
                    var e = this;
                    !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                        return e.updateSetTimeout()
                    }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(t) {
                        return e.updateRAF(t)
                    }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
                },
                updateRAF: function(t) {
                    this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
                },
                updateSetTimeout: function() {
                    this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
                },
                stop: function() {
                    this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
                },
                isSetTimeOut: function() {
                    return this._isSetTimeOut
                },
                isRAF: function() {
                    return !1 === this._isSetTimeOut
                }
            }, X.RequestAnimationFrame.prototype.constructor = X.RequestAnimationFrame, X.Math = {
                PI2: 2 * Math.PI,
                between: function(t, e) {
                    return Math.floor(Math.random() * (e - t + 1) + t)
                },
                fuzzyEqual: function(t, e, i) {
                    return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
                },
                fuzzyLessThan: function(t, e, i) {
                    return void 0 === i && (i = 1e-4), t < e + i
                },
                fuzzyGreaterThan: function(t, e, i) {
                    return void 0 === i && (i = 1e-4), e - i < t
                },
                fuzzyCeil: function(t, e) {
                    return void 0 === e && (e = 1e-4), Math.ceil(t - e)
                },
                fuzzyFloor: function(t, e) {
                    return void 0 === e && (e = 1e-4), Math.floor(t + e)
                },
                average: function() {
                    for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                    return t / e
                },
                shear: function(t) {
                    return t % 1
                },
                snapTo: function(t, e, i) {
                    return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
                },
                snapToFloor: function(t, e, i) {
                    return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
                },
                snapToCeil: function(t, e, i) {
                    return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
                },
                roundTo: function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 10);
                    e = Math.pow(i, -e);
                    return Math.round(t * e) / e
                },
                floorTo: function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 10);
                    e = Math.pow(i, -e);
                    return Math.floor(t * e) / e
                },
                ceilTo: function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 10);
                    e = Math.pow(i, -e);
                    return Math.ceil(t * e) / e
                },
                rotateToAngle: function(t, e, i) {
                    return void 0 === i && (i = .05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= X.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += X.Math.PI2 : e -= X.Math.PI2), t < e ? t += i : e < t && (t -= i))), t
                },
                getShortestAngle: function(t, e) {
                    t = e - t;
                    return 0 == t ? 0 : t - 360 * Math.floor((t + 180) / 360)
                },
                angleBetween: function(t, e, i, s) {
                    return Math.atan2(s - e, i - t)
                },
                angleBetweenY: function(t, e, i, s) {
                    return Math.atan2(i - t, s - e)
                },
                angleBetweenPoints: function(t, e) {
                    return Math.atan2(e.y - t.y, e.x - t.x)
                },
                angleBetweenPointsY: function(t, e) {
                    return Math.atan2(e.x - t.x, e.y - t.y)
                },
                reverseAngle: function(t) {
                    return this.normalizeAngle(t + Math.PI, !0)
                },
                normalizeAngle: function(t) {
                    return 0 <= (t %= 2 * Math.PI) ? t : t + 2 * Math.PI
                },
                maxAdd: function(t, e, i) {
                    return Math.min(t + e, i)
                },
                minSub: function(t, e, i) {
                    return Math.max(t - e, i)
                },
                wrap: function(t, e, i) {
                    i -= e;
                    if (i <= 0) return 0;
                    t = (t - e) % i;
                    return t < 0 && (t += i), t + e
                },
                wrapValue: function(t, e, i) {
                    return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
                },
                isOdd: function(t) {
                    return !!(1 & t)
                },
                isEven: function(t) {
                    return !(1 & t)
                },
                min: function() {
                    for (var t, e = 1, i = 0, s = (t = 1 === arguments.length && "object" == typeof arguments[0] ? arguments[0] : arguments).length; e < s; e++) t[e] < t[i] && (i = e);
                    return t[i]
                },
                max: function() {
                    for (var t, e = 1, i = 0, s = (t = 1 === arguments.length && "object" == typeof arguments[0] ? arguments[0] : arguments).length; e < s; e++) t[e] > t[i] && (i = e);
                    return t[i]
                },
                minProperty: function(t) {
                    for (var e, i = 1, s = 0, n = (e = 2 === arguments.length && "object" == typeof arguments[1] ? arguments[1] : arguments.slice(1)).length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                    return e[s][t]
                },
                maxProperty: function(t) {
                    for (var e, i = 1, s = 0, n = (e = 2 === arguments.length && "object" == typeof arguments[1] ? arguments[1] : arguments.slice(1)).length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                    return e[s][t]
                },
                wrapAngle: function(t, e) {
                    return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
                },
                linearInterpolation: function(t, e) {
                    var i = t.length - 1,
                        s = i * e,
                        n = Math.floor(s);
                    return e < 0 ? this.linear(t[0], t[1], s) : 1 < e ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[i < n + 1 ? i : n + 1], s - n)
                },
                bezierInterpolation: function(t, e) {
                    for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                    return i
                },
                catmullRomInterpolation: function(t, e) {
                    var i = t.length - 1,
                        s = i * e,
                        n = Math.floor(s);
                    return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : 1 < e ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
                },
                linear: function(t, e, i) {
                    return (e - t) * i + t
                },
                bernstein: function(t, e) {
                    return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
                },
                factorial: function(t) {
                    if (0 === t) return 1;
                    for (var e = t; --t;) e *= t;
                    return e
                },
                catmullRom: function(t, e, i, s, n) {
                    var a = .5 * (i - t),
                        t = .5 * (s - e),
                        s = n * n;
                    return n * s * (2 * e - 2 * i + a + t) + (-3 * e + 3 * i - 2 * a - t) * s + a * n + e
                },
                difference: function(t, e) {
                    return Math.abs(t - e)
                },
                roundAwayFromZero: function(t) {
                    return 0 < t ? Math.ceil(t) : Math.floor(t)
                },
                sinCosGenerator: function(t, e, i, s) {
                    void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                    for (var n = e, a = i, o = s * Math.PI / t, r = [], h = [], l = 0; l < t; l++) n += (a -= n * o) * o, r[l] = a, h[l] = n;
                    return {
                        sin: h,
                        cos: r,
                        length: t
                    }
                },
                distance: function(t, e, i, s) {
                    i = t - i, s = e - s;
                    return Math.sqrt(i * i + s * s)
                },
                distanceSq: function(t, e, i, s) {
                    i = t - i, s = e - s;
                    return i * i + s * s
                },
                distancePow: function(t, e, i, s, n) {
                    return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
                },
                clamp: function(t, e, i) {
                    return t < e ? e : i < t ? i : t
                },
                clampBottom: function(t, e) {
                    return t < e ? e : t
                },
                within: function(t, e, i) {
                    return Math.abs(t - e) <= i
                },
                mapLinear: function(t, e, i, s, n) {
                    return s + (t - e) * (n - s) / (i - e)
                },
                smoothstep: function(t, e, i) {
                    return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, i) {
                    return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
                },
                sign: function(t) {
                    return t < 0 ? -1 : 0 < t ? 1 : 0
                },
                percent: function(t, e, i) {
                    return void 0 === i && (i = 0), e < t || e < i ? 1 : t < i || t < i ? 0 : (t - i) / e
                }
            };
            var n = Math.PI / 180,
                o = 180 / Math.PI;
            return X.Math.degToRad = function(t) {
                return t * n
            }, X.Math.radToDeg = function(t) {
                return t * o
            }, X.RandomDataGenerator = function(t) {
                void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
            }, X.RandomDataGenerator.prototype = {
                rnd: function() {
                    var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                    return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                },
                sow: function(t) {
                    if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                        for (var e = 0; e < t.length && null != t[e]; e++) {
                            var i = t[e];
                            this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                        }
                },
                hash: function(t) {
                    var e, i, s = 4022871197;
                    for (t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
                    return 2.3283064365386963e-10 * (s >>> 0)
                },
                integer: function() {
                    return 4294967296 * this.rnd.apply(this)
                },
                frac: function() {
                    return this.rnd.apply(this) + 11102230246251565e-32 * (2097152 * this.rnd.apply(this) | 0)
                },
                real: function() {
                    return this.integer() + this.frac()
                },
                integerInRange: function(t, e) {
                    return Math.floor(this.realInRange(0, e - t + 1) + t)
                },
                between: function(t, e) {
                    return this.integerInRange(t, e)
                },
                realInRange: function(t, e) {
                    return this.frac() * (e - t) + t
                },
                normal: function() {
                    return 1 - 2 * this.frac()
                },
                uuid: function() {
                    for (var t = "", e = "", e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                    return e
                },
                pick: function(t) {
                    return t[this.integerInRange(0, t.length - 1)]
                },
                sign: function() {
                    return this.pick([-1, 1])
                },
                weightedPick: function(t) {
                    return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
                },
                timestamp: function(t, e) {
                    return this.realInRange(t || 9466848e5, e || 1577862e6)
                },
                angle: function() {
                    return this.integerInRange(-180, 180)
                },
                state: function(t) {
                    return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                }
            }, X.RandomDataGenerator.prototype.constructor = X.RandomDataGenerator, X.QuadTree = function(t, e, i, s, n, a, o) {
                this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, a, o)
            }, X.QuadTree.prototype = {
                reset: function(t, e, i, s, n, a, o) {
                    this.maxObjects = n || 10, this.maxLevels = a || 4, this.level = o || 0, this.bounds = {
                        x: Math.round(t),
                        y: Math.round(e),
                        width: i,
                        height: s,
                        subWidth: Math.floor(i / 2),
                        subHeight: Math.floor(s / 2),
                        right: Math.round(t) + Math.floor(i / 2),
                        bottom: Math.round(e) + Math.floor(s / 2)
                    }, this.objects.length = 0, this.nodes.length = 0
                },
                populate: function(t) {
                    t.forEach(this.populateHandler, this, !0)
                },
                populateHandler: function(t) {
                    t.body && t.exists && this.insert(t.body)
                },
                split: function() {
                    this.nodes[0] = new X.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new X.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new X.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new X.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                },
                insert: function(t) {
                    var e, i = 0;
                    if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                        if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                            for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                    } else this.nodes[e].insert(t)
                },
                getIndex: function(t) {
                    var e = -1;
                    return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                },
                retrieve: function(t) {
                    if (t instanceof X.Rectangle) var e = this.objects,
                        i = this.getIndex(t);
                    else {
                        if (!t.body) return this._empty;
                        e = this.objects, i = this.getIndex(t.body)
                    }
                    return this.nodes[0] && (e = -1 !== i ? e.concat(this.nodes[i].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
                },
                clear: function() {
                    this.objects.length = 0;
                    for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                    this.nodes.length = 0
                }
            }, X.QuadTree.prototype.constructor = X.QuadTree, X.Net = function(t) {
                this.game = t
            }, X.Net.prototype = {
                getHostName: function() {
                    return window.location && window.location.hostname ? window.location.hostname : null
                },
                checkDomainName: function(t) {
                    return -1 !== window.location.hostname.indexOf(t)
                },
                updateQueryString: function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                    var n, a = "",
                        o = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi"),
                        a = o.test(s) ? null != e ? s.replace(o, "$1" + t + "=" + e + "$2$3") : s.replace(o, "$1$3").replace(/(&|\?)$/, "") : (null != e && (n = -1 !== s.indexOf("?") ? "&" : "?", s = (o = s.split("#"))[0] + n + t + "=" + e, o[1] && (s += "#" + o[1])), s);
                    if (!i) return a;
                    window.location.href = a
                },
                getQueryString: function(t) {
                    void 0 === t && (t = "");
                    var e, i = {},
                        s = location.search.substring(1).split("&");
                    for (e in s) {
                        var n = s[e].split("=");
                        if (1 < n.length) {
                            if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                            i[this.decodeURI(n[0])] = this.decodeURI(n[1])
                        }
                    }
                    return i
                },
                decodeURI: function(t) {
                    return decodeURIComponent(t.replace(/\+/g, " "))
                }
            }, X.Net.prototype.constructor = X.Net, X.TweenManager = function(t) {
                this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                    Power0: X.Easing.Power0,
                    Power1: X.Easing.Power1,
                    Power2: X.Easing.Power2,
                    Power3: X.Easing.Power3,
                    Power4: X.Easing.Power4,
                    Linear: X.Easing.Linear.None,
                    Quad: X.Easing.Quadratic.Out,
                    Cubic: X.Easing.Cubic.Out,
                    Quart: X.Easing.Quartic.Out,
                    Quint: X.Easing.Quintic.Out,
                    Sine: X.Easing.Sinusoidal.Out,
                    Expo: X.Easing.Exponential.Out,
                    Circ: X.Easing.Circular.Out,
                    Elastic: X.Easing.Elastic.Out,
                    Back: X.Easing.Back.Out,
                    Bounce: X.Easing.Bounce.Out,
                    "Quad.easeIn": X.Easing.Quadratic.In,
                    "Cubic.easeIn": X.Easing.Cubic.In,
                    "Quart.easeIn": X.Easing.Quartic.In,
                    "Quint.easeIn": X.Easing.Quintic.In,
                    "Sine.easeIn": X.Easing.Sinusoidal.In,
                    "Expo.easeIn": X.Easing.Exponential.In,
                    "Circ.easeIn": X.Easing.Circular.In,
                    "Elastic.easeIn": X.Easing.Elastic.In,
                    "Back.easeIn": X.Easing.Back.In,
                    "Bounce.easeIn": X.Easing.Bounce.In,
                    "Quad.easeOut": X.Easing.Quadratic.Out,
                    "Cubic.easeOut": X.Easing.Cubic.Out,
                    "Quart.easeOut": X.Easing.Quartic.Out,
                    "Quint.easeOut": X.Easing.Quintic.Out,
                    "Sine.easeOut": X.Easing.Sinusoidal.Out,
                    "Expo.easeOut": X.Easing.Exponential.Out,
                    "Circ.easeOut": X.Easing.Circular.Out,
                    "Elastic.easeOut": X.Easing.Elastic.Out,
                    "Back.easeOut": X.Easing.Back.Out,
                    "Bounce.easeOut": X.Easing.Bounce.Out,
                    "Quad.easeInOut": X.Easing.Quadratic.InOut,
                    "Cubic.easeInOut": X.Easing.Cubic.InOut,
                    "Quart.easeInOut": X.Easing.Quartic.InOut,
                    "Quint.easeInOut": X.Easing.Quintic.InOut,
                    "Sine.easeInOut": X.Easing.Sinusoidal.InOut,
                    "Expo.easeInOut": X.Easing.Exponential.InOut,
                    "Circ.easeInOut": X.Easing.Circular.InOut,
                    "Elastic.easeInOut": X.Easing.Elastic.InOut,
                    "Back.easeInOut": X.Easing.Back.InOut,
                    "Bounce.easeInOut": X.Easing.Bounce.InOut
                }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
            }, X.TweenManager.prototype = {
                getAll: function() {
                    return this._tweens
                },
                removeAll: function() {
                    for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                    this._add = []
                },
                removeFrom: function(t, e) {
                    if (void 0 === e && (e = !0), Array.isArray(t))
                        for (i = 0, s = t.length; i < s; i++) this.removeFrom(t[i]);
                    else if (t.type === X.GROUP && e)
                        for (var i = 0, s = t.children.length; i < s; i++) this.removeFrom(t.children[i]);
                    else {
                        for (i = 0, s = this._tweens.length; i < s; i++) t === this._tweens[i].target && this.remove(this._tweens[i]);
                        for (i = 0, s = this._add.length; i < s; i++) t === this._add[i].target && this.remove(this._add[i])
                    }
                },
                add: function(t) {
                    (t._manager = this)._add.push(t)
                },
                create: function(t) {
                    return new X.Tween(t, this.game, this)
                },
                remove: function(t) {
                    var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
                },
                update: function() {
                    var t = this._add.length,
                        e = this._tweens.length;
                    if (0 === e && 0 === t) return !1;
                    for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                    return 0 < t && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                },
                isTweening: function(e) {
                    return this._tweens.some(function(t) {
                        return t.target === e
                    })
                },
                _pauseAll: function() {
                    for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._pause()
                },
                _resumeAll: function() {
                    for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._resume()
                },
                pauseAll: function() {
                    for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].pause()
                },
                resumeAll: function() {
                    for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].resume(!0)
                }
            }, X.TweenManager.prototype.constructor = X.TweenManager, X.Tween = function(t, e, i) {
                this.game = e, this.target = t, this.manager = i, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new X.Signal, this.onLoop = new X.Signal, this.onRepeat = new X.Signal, this.onChildComplete = new X.Signal, this.onComplete = new X.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = i.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
            }, X.Tween.prototype = {
                to: function(t, e, i, s, n, a, o) {
                    return (void 0 === e || e <= 0) && (e = 1e3), null != i || (i = X.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === o && (o = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning || (this.timeline.push(new X.TweenData(this).to(t, e, i, n, a, o)), s && this.start()), this
                },
                from: function(t, e, i, s, n, a, o) {
                    return void 0 === e && (e = 1e3), null != i || (i = X.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === o && (o = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning || (this.timeline.push(new X.TweenData(this).from(t, e, i, n, a, o)), s && this.start()), this
                },
                start: function(t) {
                    if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                    for (var e = 0; e < this.timeline.length; e++)
                        for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                    for (e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                    return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
                },
                stop: function(t) {
                    return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
                },
                updateTweenData: function(t, e, i) {
                    if (0 === this.timeline.length) return this;
                    if (void 0 === i && (i = 0), -1 === i)
                        for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                    else this.timeline[i][t] = e;
                    return this
                },
                delay: function(t, e) {
                    return this.updateTweenData("delay", t, e)
                },
                repeat: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
                },
                repeatDelay: function(t, e) {
                    return this.updateTweenData("repeatDelay", t, e)
                },
                yoyo: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
                },
                yoyoDelay: function(t, e) {
                    return this.updateTweenData("yoyoDelay", t, e)
                },
                easing: function(t, e) {
                    return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
                },
                interpolation: function(t, e, i) {
                    return void 0 === e && (e = X.Math), this.updateTweenData("interpolationFunction", t, i), this.updateTweenData("interpolationContext", e, i)
                },
                repeatAll: function(t) {
                    return void 0 === t && (t = 0), this.repeatCounter = t, this
                },
                chain: function() {
                    for (var t = arguments.length; t--;) 0 < t ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                    return this
                },
                loop: function(t) {
                    return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
                },
                onUpdateCallback: function(t, e) {
                    return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                },
                pause: function() {
                    this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
                },
                _pause: function() {
                    this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
                },
                resume: function() {
                    if (this.isPaused) {
                        this.isPaused = !1, this._codePaused = !1;
                        for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                    }
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                update: function(t) {
                    if (this.pendingDelete || !this.target) return !1;
                    if (this.isPaused) return !0;
                    t = this.timeline[this.current].update(t);
                    if (t === X.TweenData.PENDING) return !0;
                    if (t === X.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                    if (t === X.TweenData.LOOPED) return (-1 === this.timeline[this.current].repeatCounter ? this.onLoop : this.onRepeat).dispatch(this.target, this), !0;
                    if (t === X.TweenData.COMPLETE) {
                        t = !1;
                        return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, t = !0) : ++this.current === this.timeline.length && (t = !(this.current = 0)), t ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : 0 < this.repeatCounter ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                    }
                },
                generateData: function(t, e) {
                    if (null === this.game || null === this.target) return null;
                    void 0 === t && (t = 60), void 0 === e && (e = []);
                    for (var i = 0; i < this.timeline.length; i++)
                        for (var s in this.timeline[i].vEnd) this.properties[s] = this.target[s] || 0, Array.isArray(this.properties[s]) || (this.properties[s] *= 1);
                    for (i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                    for (i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                    return e
                }
            }, Object.defineProperty(X.Tween.prototype, "totalDuration", {
                get: function() {
                    for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                    return t
                }
            }), X.Tween.prototype.constructor = X.Tween, X.TweenData = function(t) {
                this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = X.Easing.Default, this.interpolationFunction = X.Math.linearInterpolation, this.interpolationContext = X.Math, this.isRunning = !1, this.isFrom = !1
            }, X.TweenData.PENDING = 0, X.TweenData.RUNNING = 1, X.TweenData.LOOPED = 2, X.TweenData.COMPLETE = 3, X.TweenData.prototype = {
                to: function(t, e, i, s, n, a) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = a, this.isFrom = !1, this
                },
                from: function(t, e, i, s, n, a) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = a, this.isFrom = !0, this
                },
                start: function() {
                    if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, 0 < this.delay ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                    return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
                },
                loadValues: function() {
                    for (var t in this.parent.properties) {
                        if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                            if (0 === this.vEnd[t].length) continue;
                            0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                        }
                        void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                    }
                    return this
                },
                update: function(t) {
                    if (this.isRunning) {
                        if (t < this.startTime) return X.TweenData.RUNNING
                    } else {
                        if (!(t >= this.startTime)) return X.TweenData.PENDING;
                        this.isRunning = !0
                    }
                    var e, t = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                    for (e in this.parent.reverse ? (this.dt -= t * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += t * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                        var i = this.vStart[e],
                            s = this.vEnd[e];
                        Array.isArray(s) ? this.parent.target[e] = this.interpolationFunction.call(this.interpolationContext, s, this.value) : this.parent.target[e] = i + (s - i) * this.value
                    }
                    return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : X.TweenData.RUNNING
                },
                generateData: function(t) {
                    this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                    var e = [],
                        i = !1,
                        s = 1 / t * 1e3;
                    do {
                        this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                        var n, a = {};
                        for (n in this.vEnd) {
                            var o = this.vStart[n],
                                r = this.vEnd[n];
                            Array.isArray(r) ? a[n] = this.interpolationFunction(r, this.value) : a[n] = o + (r - o) * this.value
                        }
                    } while (e.push(a), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0), !i);
                    return this.yoyo && ((t = e.slice()).reverse(), e = e.concat(t)), e
                },
                repeat: function() {
                    if (this.yoyo) {
                        if (this.inReverse && 0 === this.repeatCounter) {
                            for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                            return this.inReverse = !1, X.TweenData.COMPLETE
                        }
                        this.inReverse = !this.inReverse
                    } else if (0 === this.repeatCounter) return X.TweenData.COMPLETE;
                    if (this.inReverse)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                    else {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        0 < this.repeatCounter && this.repeatCounter--
                    }
                    return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, X.TweenData.LOOPED
                }
            }, X.TweenData.prototype.constructor = X.TweenData, X.Easing = {
                Linear: {
                    None: function(t) {
                        return t
                    }
                },
                Quadratic: {
                    In: function(t) {
                        return t * t
                    },
                    Out: function(t) {
                        return t * (2 - t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                    }
                },
                Cubic: {
                    In: function(t) {
                        return t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                    }
                },
                Quartic: {
                    In: function(t) {
                        return t * t * t * t
                    },
                    Out: function(t) {
                        return 1 - --t * t * t * t
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                    }
                },
                Quintic: {
                    In: function(t) {
                        return t * t * t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                    }
                },
                Sinusoidal: {
                    In: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                    },
                    Out: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                    }
                },
                Exponential: {
                    In: function(t) {
                        return 0 === t ? 0 : Math.pow(1024, t - 1)
                    },
                    Out: function(t) {
                        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                    }
                },
                Circular: {
                    In: function(t) {
                        return 1 - Math.sqrt(1 - t * t)
                    },
                    Out: function(t) {
                        return Math.sqrt(1 - --t * t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                    }
                },
                Elastic: {
                    In: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * --t) * Math.sin((t - e) * (2 * Math.PI) / .4))
                    },
                    Out: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                    },
                    InOut: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * --t) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * --t) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                    }
                },
                Back: {
                    In: function(t) {
                        return t * t * (2.70158 * t - 1.70158)
                    },
                    Out: function(t) {
                        return --t * t * (2.70158 * t + 1.70158) + 1
                    },
                    InOut: function(t) {
                        var e = 2.5949095;
                        return (t *= 2) < 1 ? t * t * ((1 + e) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + e) * t + e) + 2)
                    }
                },
                Bounce: {
                    In: function(t) {
                        return 1 - X.Easing.Bounce.Out(1 - t)
                    },
                    Out: function(t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                    },
                    InOut: function(t) {
                        return t < .5 ? .5 * X.Easing.Bounce.In(2 * t) : .5 * X.Easing.Bounce.Out(2 * t - 1) + .5
                    }
                }
            }, X.Easing.Default = X.Easing.Linear.None, X.Easing.Power0 = X.Easing.Linear.None, X.Easing.Power1 = X.Easing.Quadratic.Out, X.Easing.Power2 = X.Easing.Cubic.Out, X.Easing.Power3 = X.Easing.Quartic.Out, X.Easing.Power4 = X.Easing.Quintic.Out, X.Time = function(t) {
                this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new X.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
            }, X.Time.prototype = {
                boot: function() {
                    this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
                },
                add: function(t) {
                    return this._timers.push(t), t
                },
                create: function(t) {
                    void 0 === t && (t = !0);
                    t = new X.Timer(this.game, t);
                    return this._timers.push(t), t
                },
                removeAll: function() {
                    for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                    this._timers = [], this.events.removeAll()
                },
                refresh: function() {
                    var t = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - t
                },
                update: function(t) {
                    var e = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
                },
                updateTimers: function() {
                    for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
                },
                updateAdvancedTiming: function() {
                    this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
                },
                gamePaused: function() {
                    this._pauseStarted = Date.now(), this.events.pause();
                    for (var t = this._timers.length; t--;) this._timers[t]._pause()
                },
                gameResumed: function() {
                    this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                    for (var t = this._timers.length; t--;) this._timers[t]._resume()
                },
                totalElapsedSeconds: function() {
                    return .001 * (this.time - this._started)
                },
                elapsedSince: function(t) {
                    return this.time - t
                },
                elapsedSecondsSince: function(t) {
                    return .001 * (this.time - t)
                },
                reset: function() {
                    this._started = this.time, this.removeAll()
                }
            }, Object.defineProperty(X.Time.prototype, "desiredFps", {
                get: function() {
                    return this._desiredFps
                },
                set: function(t) {
                    this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
                }
            }), X.Time.prototype.constructor = X.Time, X.Timer = function(t, e) {
                void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new X.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
            }, X.Timer.MINUTE = 6e4, X.Timer.SECOND = 1e3, X.Timer.HALF = 500, X.Timer.QUARTER = 250, X.Timer.prototype = {
                create: function(t, e, i, s, n, a) {
                    var o = t = Math.round(t);
                    0 === this._now ? o += this.game.time.time : o += this._now;
                    a = new X.TimerEvent(this, t, o, i, e, s, n, a);
                    return this.events.push(a), this.order(), this.expired = !1, a
                },
                add: function(t, e, i) {
                    return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                repeat: function(t, e, i, s) {
                    return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
                },
                loop: function(t, e, i) {
                    return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                start: function(t) {
                    if (!this.running) {
                        this._started = this.game.time.time + (t || 0), this.running = !0;
                        for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                    }
                },
                stop: function(t) {
                    this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
                },
                remove: function(t) {
                    for (var e = 0; e < this.events.length; e++)
                        if (this.events[e] === t) return this.events[e].pendingDelete = !0;
                    return !1
                },
                order: function() {
                    0 < this.events.length && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                },
                sortHandler: function(t, e) {
                    return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                },
                clearPendingEvents: function() {
                    for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                    this._len = this.events.length, this._i = 0
                },
                update: function(t) {
                    if (this.paused) return !0;
                    if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && 0 < this._len) {
                        for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? this.events[this._i].tick = this._newTick : 0 < this.events[this._i].repeatCount ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick) : (this._marked++, this.events[this._i].pendingDelete = !0), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args), this._i++;
                        this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                    }
                    return !this.expired || !this.autoDestroy
                },
                pause: function() {
                    this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
                },
                _pause: function() {
                    !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
                },
                adjustEvents: function(t) {
                    for (var e, i = 0; i < this.events.length; i++) this.events[i].pendingDelete || ((e = this.events[i].tick - t) < 0 && (e = 0), this.events[i].tick = this._now + e);
                    var s = this.nextTick - t;
                    this.nextTick = s < 0 ? this._now : this._now + s
                },
                resume: function() {
                    var t;
                    this.paused && (t = this.game.time.time, this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1)
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                removeAll: function() {
                    this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                },
                destroy: function() {
                    this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
                }
            }, Object.defineProperty(X.Timer.prototype, "next", {
                get: function() {
                    return this.nextTick
                }
            }), Object.defineProperty(X.Timer.prototype, "duration", {
                get: function() {
                    return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                }
            }), Object.defineProperty(X.Timer.prototype, "length", {
                get: function() {
                    return this.events.length
                }
            }), Object.defineProperty(X.Timer.prototype, "ms", {
                get: function() {
                    return this.running ? this._now - this._started - this._pauseTotal : 0
                }
            }), Object.defineProperty(X.Timer.prototype, "seconds", {
                get: function() {
                    return this.running ? .001 * this.ms : 0
                }
            }), X.Timer.prototype.constructor = X.Timer, X.TimerEvent = function(t, e, i, s, n, a, o, r) {
                this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = a, this.callbackContext = o, this.args = r, this.pendingDelete = !1
            }, X.TimerEvent.prototype.constructor = X.TimerEvent, X.AnimationManager = function(t) {
                this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
            }, X.AnimationManager.prototype = {
                loadFrameData: function(t, e) {
                    if (void 0 === t) return !1;
                    if (this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(t);
                    return this._frameData = t, null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
                },
                copyFrameData: function(t, e) {
                    if (this._frameData = t.clone(), this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                    return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
                },
                add: function(t, e, i, s, n) {
                    return e = e || [], i = i || 60, void 0 === s && (s = !1), void 0 === n && (n = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, n, this._outputFrames), this._anims[t] = new X.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
                },
                validateFrames: function(t, e) {
                    void 0 === e && (e = !0);
                    for (var i = 0; i < t.length; i++)
                        if (!0 === e) {
                            if (t[i] > this._frameData.total) return !1
                        } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                    return !0
                },
                play: function(t, e, i, s) {
                    if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
                },
                stop: function(t, e) {
                    void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
                },
                update: function() {
                    return !(this.updateIfVisible && !this.sprite.visible || !this.currentAnim || !this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))
                },
                next: function(t) {
                    this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                previous: function(t) {
                    this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                getAnimation: function(t) {
                    return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                },
                refreshFrame: function() {},
                destroy: function() {
                    var t = null;
                    for (t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                    this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
                }
            }, X.AnimationManager.prototype.constructor = X.AnimationManager, Object.defineProperty(X.AnimationManager.prototype, "frameData", {
                get: function() {
                    return this._frameData
                }
            }), Object.defineProperty(X.AnimationManager.prototype, "frameTotal", {
                get: function() {
                    return this._frameData.total
                }
            }), Object.defineProperty(X.AnimationManager.prototype, "paused", {
                get: function() {
                    return this.currentAnim.isPaused
                },
                set: function(t) {
                    this.currentAnim.paused = t
                }
            }), Object.defineProperty(X.AnimationManager.prototype, "name", {
                get: function() {
                    if (this.currentAnim) return this.currentAnim.name
                }
            }), Object.defineProperty(X.AnimationManager.prototype, "frame", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.index
                },
                set: function(t) {
                    "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
                }
            }), Object.defineProperty(X.AnimationManager.prototype, "frameName", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.name
                },
                set: function(t) {
                    "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) && (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)))
                }
            }), X.Animation = function(t, e, i, s, n, a, o) {
                void 0 === o && (o = !1), this.game = t, this._parent = e, this._frameData = s, this.name = i, this._frames = [], this._frames = this._frames.concat(n), this.delay = 1e3 / a, this.loop = o, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new X.Signal, this.onUpdate = null, this.onComplete = new X.Signal, this.onLoop = new X.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
            }, X.Animation.prototype = {
                play: function(t, e, i) {
                    return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this
                },
                restart: function() {
                    this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
                },
                reverse: function() {
                    return this.reversed = !this.reversed, this
                },
                reverseOnce: function() {
                    return this.onComplete.addOnce(this.reverse, this), this.reverse()
                },
                setFrame: function(t, e) {
                    var i;
                    if (void 0 === e && (e = !1), "string" == typeof t)
                        for (var s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                    else if ("number" == typeof t)
                        if (e) i = t;
                        else
                            for (s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                    i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
                },
                stop: function(t, e) {
                    void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                },
                onPause: function() {
                    this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
                },
                onResume: function() {
                    this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
                },
                update: function() {
                    return !this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
                },
                updateCurrentFrame: function(t, e) {
                    if (void 0 === e && (e = !1), !this._frameData) return !1;
                    var i = this.currentFrame.index;
                    return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
                },
                next: function(t) {
                    void 0 === t && (t = 1);
                    t = this._frameIndex + t;
                    t >= this._frames.length && (this.loop ? t %= this._frames.length : t = this._frames.length - 1), t !== this._frameIndex && (this._frameIndex = t, this.updateCurrentFrame(!0))
                },
                previous: function(t) {
                    void 0 === t && (t = 1);
                    t = this._frameIndex - t;
                    t < 0 && (this.loop ? t = this._frames.length + t : t++), t !== this._frameIndex && (this._frameIndex = t, this.updateCurrentFrame(!0))
                },
                updateFrameData: function(t) {
                    this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                },
                destroy: function() {
                    this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
                },
                complete: function() {
                    this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                }
            }, X.Animation.prototype.constructor = X.Animation, Object.defineProperty(X.Animation.prototype, "paused", {
                get: function() {
                    return this.isPaused
                },
                set: function(t) {
                    (this.isPaused = t) ? this._pauseStartTime = this.game.time.time: this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
                }
            }), Object.defineProperty(X.Animation.prototype, "reversed", {
                get: function() {
                    return this.isReversed
                },
                set: function(t) {
                    this.isReversed = t
                }
            }), Object.defineProperty(X.Animation.prototype, "frameTotal", {
                get: function() {
                    return this._frames.length
                }
            }), Object.defineProperty(X.Animation.prototype, "frame", {
                get: function() {
                    return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                },
                set: function(t) {
                    this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
                }
            }), Object.defineProperty(X.Animation.prototype, "speed", {
                get: function() {
                    return 1e3 / this.delay
                },
                set: function(t) {
                    0 < t && (this.delay = 1e3 / t)
                }
            }), Object.defineProperty(X.Animation.prototype, "enableUpdate", {
                get: function() {
                    return null !== this.onUpdate
                },
                set: function(t) {
                    t && null === this.onUpdate ? this.onUpdate = new X.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
                }
            }), X.Animation.generateFrameNames = function(t, e, i, s, n) {
                void 0 === s && (s = "");
                var a = [],
                    o = "";
                if (e < i)
                    for (var r = e; r <= i; r++) o = t + (o = "number" == typeof n ? X.Utils.pad(r.toString(), n, "0", 1) : r.toString()) + s, a.push(o);
                else
                    for (r = e; i <= r; r--) o = t + (o = "number" == typeof n ? X.Utils.pad(r.toString(), n, "0", 1) : r.toString()) + s, a.push(o);
                return a
            }, X.Frame = function(t, e, i, s, n, a) {
                this.index = t, this.x = e, this.y = i, this.width = s, this.height = n, this.name = a, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(n / 2), this.distance = X.Math.distance(0, 0, s, n), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = n, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
            }, X.Frame.prototype = {
                resize: function(t, e) {
                    this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = X.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
                },
                setTrim: function(t, e, i, s, n, a, o) {
                    (this.trimmed = t) && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = a, this.spriteSourceSizeH = o)
                },
                clone: function() {
                    var t, e = new X.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                    for (t in this) this.hasOwnProperty(t) && (e[t] = this[t]);
                    return e
                },
                getRect: function(t) {
                    return void 0 === t ? t = new X.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                }
            }, X.Frame.prototype.constructor = X.Frame, X.FrameData = function() {
                this._frames = [], this._frameNames = []
            }, X.FrameData.prototype = {
                addFrame: function(t) {
                    return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                },
                getFrame: function(t) {
                    return t >= this._frames.length && (t = 0), this._frames[t]
                },
                getFrameByName: function(t) {
                    return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                },
                checkFrameName: function(t) {
                    return null != this._frameNames[t]
                },
                clone: function() {
                    for (var t, e = new X.FrameData, i = 0; i < this._frames.length; i++) e._frames.push(this._frames[i].clone());
                    for (t in this._frameNames) this._frameNames.hasOwnProperty(t) && e._frameNames.push(this._frameNames[t]);
                    return e
                },
                getFrameRange: function(t, e, i) {
                    void 0 === i && (i = []);
                    for (var s = t; s <= e; s++) i.push(this._frames[s]);
                    return i
                },
                getFrames: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                    else
                        for (s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                    return i
                },
                getFrameIndexes: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                    else
                        for (s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                    return i
                },
                destroy: function() {
                    this._frames = null, this._frameNames = null
                }
            }, X.FrameData.prototype.constructor = X.FrameData, Object.defineProperty(X.FrameData.prototype, "total", {
                get: function() {
                    return this._frames.length
                }
            }), X.AnimationParser = {
                spriteSheet: function(t, e, i, s, n, a, o) {
                    var r = e;
                    if ("string" == typeof e && (r = t.cache.getImage(e)), null === r) return null;
                    var h = r.width,
                        t = r.height;
                    i <= 0 && (i = Math.floor(-h / Math.min(-1, i))), s <= 0 && (s = Math.floor(-t / Math.min(-1, s)));
                    var e = Math.floor((h - a) / (i + o)),
                        r = Math.floor((t - a) / (s + o)),
                        l = -1 !== n ? n : e * r;
                    if (0 === h || 0 === t || h < i || t < s || 0 === l) return null;
                    for (var c = new X.FrameData, u = a, d = a, p = 0; p < l; p++) c.addFrame(new X.Frame(p, u, d, i, s, "")), (u += i + o) + i > h && (u = a, d += s + o);
                    return c
                },
                JSONData: function(t, e) {
                    if (e.frames) {
                        for (var i, s = new X.FrameData, n = e.frames, a = 0; a < n.length; a++) i = s.addFrame(new X.Frame(a, n[a].frame.x, n[a].frame.y, n[a].frame.w, n[a].frame.h, n[a].filename)), n[a].trimmed && i.setTrim(n[a].trimmed, n[a].sourceSize.w, n[a].sourceSize.h, n[a].spriteSourceSize.x, n[a].spriteSourceSize.y, n[a].spriteSourceSize.w, n[a].spriteSourceSize.h);
                        return s
                    }
                },
                JSONDataPyxel: function(t, e) {
                    if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                            e[t]
                        }), 1 === e.layers.length) {
                        for (var i = new X.FrameData, s = e.tileheight, n = e.tilewidth, a = e.layers[0].tiles, o = 0; o < a.length; o++) i.addFrame(new X.Frame(o, a[o].x, a[o].y, n, s, "frame_" + o)).setTrim(!1);
                        return i
                    }
                },
                JSONDataHash: function(t, e) {
                    if (e.frames) {
                        var i, s, n = new X.FrameData,
                            a = e.frames,
                            o = 0;
                        for (s in a) i = n.addFrame(new X.Frame(o, a[s].frame.x, a[s].frame.y, a[s].frame.w, a[s].frame.h, s)), a[s].trimmed && i.setTrim(a[s].trimmed, a[s].sourceSize.w, a[s].sourceSize.h, a[s].spriteSourceSize.x, a[s].spriteSourceSize.y, a[s].spriteSourceSize.w, a[s].spriteSourceSize.h), o++;
                        return n
                    }
                },
                XMLData: function(t, e) {
                    if (e.getElementsByTagName("TextureAtlas")) {
                        for (var i, s, n, a, o, r, h, l, c, u, d = new X.FrameData, p = e.getElementsByTagName("SubTexture"), f = 0; f < p.length; f++) i = (s = p[f].attributes).name.value, n = parseInt(s.x.value, 10), a = parseInt(s.y.value, 10), o = parseInt(s.width.value, 10), r = parseInt(s.height.value, 10), l = h = null, s.frameX && (h = Math.abs(parseInt(s.frameX.value, 10)), l = Math.abs(parseInt(s.frameY.value, 10)), c = parseInt(s.frameWidth.value, 10), u = parseInt(s.frameHeight.value, 10)), i = d.addFrame(new X.Frame(f, n, a, o, r, i)), null === h && null === l || i.setTrim(!0, o, r, h, l, c, u);
                        return d
                    }
                }
            }, X.Cache = function(t) {
                this.game = t, this.autoResolveURL = !1, this._cache = {
                    canvas: {},
                    image: {},
                    texture: {},
                    sound: {},
                    video: {},
                    text: {},
                    json: {},
                    xml: {},
                    physics: {},
                    tilemap: {},
                    binary: {},
                    bitmapData: {},
                    bitmapFont: {},
                    shader: {},
                    renderTexture: {}
                }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new X.Signal, this._cacheMap = [], this._cacheMap[X.Cache.CANVAS] = this._cache.canvas, this._cacheMap[X.Cache.IMAGE] = this._cache.image, this._cacheMap[X.Cache.TEXTURE] = this._cache.texture, this._cacheMap[X.Cache.SOUND] = this._cache.sound, this._cacheMap[X.Cache.TEXT] = this._cache.text, this._cacheMap[X.Cache.PHYSICS] = this._cache.physics, this._cacheMap[X.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[X.Cache.BINARY] = this._cache.binary, this._cacheMap[X.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[X.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[X.Cache.JSON] = this._cache.json, this._cacheMap[X.Cache.XML] = this._cache.xml, this._cacheMap[X.Cache.VIDEO] = this._cache.video, this._cacheMap[X.Cache.SHADER] = this._cache.shader, this._cacheMap[X.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
            }, X.Cache.CANVAS = 1, X.Cache.IMAGE = 2, X.Cache.TEXTURE = 3, X.Cache.SOUND = 4, X.Cache.TEXT = 5, X.Cache.PHYSICS = 6, X.Cache.TILEMAP = 7, X.Cache.BINARY = 8, X.Cache.BITMAPDATA = 9, X.Cache.BITMAPFONT = 10, X.Cache.JSON = 11, X.Cache.XML = 12, X.Cache.VIDEO = 13, X.Cache.SHADER = 14, X.Cache.RENDER_TEXTURE = 15, X.Cache.DEFAULT = null, X.Cache.MISSING = null, X.Cache.prototype = {
                addCanvas: function(t, e, i) {
                    void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                        canvas: e,
                        context: i
                    }
                },
                addImage: function(t, e, i) {
                    this.checkImageKey(t) && this.removeImage(t);
                    var s = {
                        key: t,
                        url: e,
                        data: i,
                        base: new PIXI.BaseTexture(i),
                        frame: new X.Frame(0, 0, 0, i.width, i.height, t),
                        frameData: new X.FrameData
                    };
                    return s.frameData.addFrame(new X.Frame(0, 0, 0, i.width, i.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? X.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (X.Cache.MISSING = new PIXI.Texture(s.base)), s
                },
                addDefaultImage: function() {
                    var t = new Image;
                    t.crossOrigin = "Anonymous", t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                    t = this.addImage("__default", null, t);
                    t.base.skipRender = !0, X.Cache.DEFAULT = new PIXI.Texture(t.base)
                },
                addMissingImage: function() {
                    var t = new Image;
                    t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                    t = this.addImage("__missing", null, t);
                    X.Cache.MISSING = new PIXI.Texture(t.base)
                },
                addSound: function(t, e, i, s, n) {
                    void 0 === s && (n = !(s = !0)), void 0 === n && (n = !(s = !1));
                    var a = n ? !0 : !1;
                    this._cache.sound[t] = {
                        url: e,
                        data: i,
                        isDecoding: !1,
                        decoded: a,
                        webAudio: s,
                        audioTag: n,
                        locked: this.game.sound.touchLocked
                    }, this._resolveURL(e, this._cache.sound[t])
                },
                addText: function(t, e, i) {
                    this._cache.text[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.text[t])
                },
                addPhysicsData: function(t, e, i, s) {
                    this._cache.physics[t] = {
                        url: e,
                        data: i,
                        format: s
                    }, this._resolveURL(e, this._cache.physics[t])
                },
                addTilemap: function(t, e, i, s) {
                    this._cache.tilemap[t] = {
                        url: e,
                        data: i,
                        format: s
                    }, this._resolveURL(e, this._cache.tilemap[t])
                },
                addBinary: function(t, e) {
                    this._cache.binary[t] = e
                },
                addBitmapData: function(t, e, i) {
                    return e.key = t, void 0 === i && (i = new X.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                        data: e,
                        frameData: i
                    }, e
                },
                addBitmapFont: function(t, e, i, s, n, a, o) {
                    i = {
                        url: e,
                        data: i,
                        font: null,
                        base: new PIXI.BaseTexture(i)
                    };
                    void 0 === a && (a = 0), void 0 === o && (o = 0), i.font = "json" === n ? X.LoaderParser.jsonBitmapFont(s, i.base, a, o) : X.LoaderParser.xmlBitmapFont(s, i.base, a, o), this._cache.bitmapFont[t] = i, this._resolveURL(e, i)
                },
                addJSON: function(t, e, i) {
                    this._cache.json[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.json[t])
                },
                addXML: function(t, e, i) {
                    this._cache.xml[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.xml[t])
                },
                addVideo: function(t, e, i, s) {
                    this._cache.video[t] = {
                        url: e,
                        data: i,
                        isBlob: s,
                        locked: !0
                    }, this._resolveURL(e, this._cache.video[t])
                },
                addShader: function(t, e, i) {
                    this._cache.shader[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.shader[t])
                },
                addRenderTexture: function(t, e) {
                    this._cache.renderTexture[t] = {
                        texture: e,
                        frame: new X.Frame(0, 0, 0, e.width, e.height, "", "")
                    }
                },
                addSpriteSheet: function(t, e, i, s, n, a, o, r) {
                    void 0 === a && (a = -1), void 0 === o && (o = 0), void 0 === r && (r = 0);
                    r = {
                        key: t,
                        url: e,
                        data: i,
                        frameWidth: s,
                        frameHeight: n,
                        margin: o,
                        spacing: r,
                        base: new PIXI.BaseTexture(i),
                        frameData: X.AnimationParser.spriteSheet(this.game, i, s, n, a, o, r)
                    };
                    this._cache.image[t] = r, this._resolveURL(e, r)
                },
                addTextureAtlas: function(t, e, i, s, n) {
                    i = {
                        key: t,
                        url: e,
                        data: i,
                        base: new PIXI.BaseTexture(i)
                    };
                    n === X.Loader.TEXTURE_ATLAS_XML_STARLING ? i.frameData = X.AnimationParser.XMLData(this.game, s, t) : n === X.Loader.TEXTURE_ATLAS_JSON_PYXEL ? i.frameData = X.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? i.frameData = X.AnimationParser.JSONData(this.game, s, t) : i.frameData = X.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = i, this._resolveURL(e, i)
                },
                reloadSound: function(t) {
                    var e = this,
                        i = this.getSound(t);
                    i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                        return e.reloadSoundComplete(t)
                    }, !1), i.data.load())
                },
                reloadSoundComplete: function(t) {
                    var e = this.getSound(t);
                    e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
                },
                updateSound: function(t, e, i) {
                    t = this.getSound(t);
                    t && (t[e] = i)
                },
                decodedSound: function(t, e) {
                    t = this.getSound(t);
                    t.data = e, t.decoded = !0, t.isDecoding = !1
                },
                isSoundDecoded: function(t) {
                    t = this.getItem(t, X.Cache.SOUND, "isSoundDecoded");
                    if (t) return t.decoded
                },
                isSoundReady: function(t) {
                    t = this.getItem(t, X.Cache.SOUND, "isSoundDecoded");
                    if (t) return t.decoded && !this.game.sound.touchLocked
                },
                checkKey: function(t, e) {
                    return !!this._cacheMap[t][e]
                },
                checkURL: function(t) {
                    return !!this._urlMap[this._resolveURL(t)]
                },
                checkCanvasKey: function(t) {
                    return this.checkKey(X.Cache.CANVAS, t)
                },
                checkImageKey: function(t) {
                    return this.checkKey(X.Cache.IMAGE, t)
                },
                checkTextureKey: function(t) {
                    return this.checkKey(X.Cache.TEXTURE, t)
                },
                checkSoundKey: function(t) {
                    return this.checkKey(X.Cache.SOUND, t)
                },
                checkTextKey: function(t) {
                    return this.checkKey(X.Cache.TEXT, t)
                },
                checkPhysicsKey: function(t) {
                    return this.checkKey(X.Cache.PHYSICS, t)
                },
                checkTilemapKey: function(t) {
                    return this.checkKey(X.Cache.TILEMAP, t)
                },
                checkBinaryKey: function(t) {
                    return this.checkKey(X.Cache.BINARY, t)
                },
                checkBitmapDataKey: function(t) {
                    return this.checkKey(X.Cache.BITMAPDATA, t)
                },
                checkBitmapFontKey: function(t) {
                    return this.checkKey(X.Cache.BITMAPFONT, t)
                },
                checkJSONKey: function(t) {
                    return this.checkKey(X.Cache.JSON, t)
                },
                checkXMLKey: function(t) {
                    return this.checkKey(X.Cache.XML, t)
                },
                checkVideoKey: function(t) {
                    return this.checkKey(X.Cache.VIDEO, t)
                },
                checkShaderKey: function(t) {
                    return this.checkKey(X.Cache.SHADER, t)
                },
                checkRenderTextureKey: function(t) {
                    return this.checkKey(X.Cache.RENDER_TEXTURE, t)
                },
                getItem: function(t, e, i, s) {
                    return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : null
                },
                getCanvas: function(t) {
                    return this.getItem(t, X.Cache.CANVAS, "getCanvas", "canvas")
                },
                getImage: function(t, e) {
                    null != t || (t = "__default"), void 0 === e && (e = !1);
                    t = this.getItem(t, X.Cache.IMAGE, "getImage");
                    return null === t && (t = this.getItem("__missing", X.Cache.IMAGE, "getImage")), e ? t : t.data
                },
                getTextureFrame: function(t) {
                    return this.getItem(t, X.Cache.TEXTURE, "getTextureFrame", "frame")
                },
                getSound: function(t) {
                    return this.getItem(t, X.Cache.SOUND, "getSound")
                },
                getSoundData: function(t) {
                    return this.getItem(t, X.Cache.SOUND, "getSoundData", "data")
                },
                getText: function(t) {
                    return this.getItem(t, X.Cache.TEXT, "getText", "data")
                },
                getPhysicsData: function(t, e, i) {
                    t = this.getItem(t, X.Cache.PHYSICS, "getPhysicsData", "data");
                    if (null === t || null == e) return t;
                    if (t[e]) {
                        var s, n = t[e];
                        if (!n || !i) return n;
                        for (s in n)
                            if (s = n[s], s.fixtureKey === i) return s
                    }
                    return null
                },
                getTilemapData: function(t) {
                    return this.getItem(t, X.Cache.TILEMAP, "getTilemapData")
                },
                getBinary: function(t) {
                    return this.getItem(t, X.Cache.BINARY, "getBinary")
                },
                getBitmapData: function(t) {
                    return this.getItem(t, X.Cache.BITMAPDATA, "getBitmapData", "data")
                },
                getBitmapFont: function(t) {
                    return this.getItem(t, X.Cache.BITMAPFONT, "getBitmapFont")
                },
                getJSON: function(t, e) {
                    t = this.getItem(t, X.Cache.JSON, "getJSON", "data");
                    return t ? e ? X.Utils.extend(!0, Array.isArray(t) ? [] : {}, t) : t : null
                },
                getXML: function(t) {
                    return this.getItem(t, X.Cache.XML, "getXML", "data")
                },
                getVideo: function(t) {
                    return this.getItem(t, X.Cache.VIDEO, "getVideo")
                },
                getShader: function(t) {
                    return this.getItem(t, X.Cache.SHADER, "getShader", "data")
                },
                getRenderTexture: function(t) {
                    return this.getItem(t, X.Cache.RENDER_TEXTURE, "getRenderTexture")
                },
                getBaseTexture: function(t, e) {
                    return void 0 === e && (e = X.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
                },
                getFrame: function(t, e) {
                    return void 0 === e && (e = X.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
                },
                getFrameCount: function(t, e) {
                    e = this.getFrameData(t, e);
                    return e ? e.total : 0
                },
                getFrameData: function(t, e) {
                    return void 0 === e && (e = X.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
                },
                hasFrameData: function(t, e) {
                    return void 0 === e && (e = X.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
                },
                updateFrameData: function(t, e, i) {
                    void 0 === i && (i = X.Cache.IMAGE), this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
                },
                getFrameByIndex: function(t, e, i) {
                    i = this.getFrameData(t, i);
                    return i ? i.getFrame(e) : null
                },
                getFrameByName: function(t, e, i) {
                    i = this.getFrameData(t, i);
                    return i ? i.getFrameByName(e) : null
                },
                getURL: function(t) {
                    return (t = this._resolveURL(t)) ? this._urlMap[t] : null
                },
                getKeys: function(t) {
                    void 0 === t && (t = X.Cache.IMAGE);
                    var e = [];
                    if (this._cacheMap[t])
                        for (var i in this._cacheMap[t]) "__default" !== i && "__missing" !== i && e.push(i);
                    return e
                },
                removeCanvas: function(t) {
                    delete this._cache.canvas[t]
                },
                removeImage: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = this.getImage(t, !0);
                    e && i.base && i.base.destroy(), delete this._cache.image[t]
                },
                removeSound: function(t) {
                    delete this._cache.sound[t]
                },
                removeText: function(t) {
                    delete this._cache.text[t]
                },
                removePhysics: function(t) {
                    delete this._cache.physics[t]
                },
                removeTilemap: function(t) {
                    delete this._cache.tilemap[t]
                },
                removeBinary: function(t) {
                    delete this._cache.binary[t]
                },
                removeBitmapData: function(t) {
                    delete this._cache.bitmapData[t]
                },
                removeBitmapFont: function(t) {
                    delete this._cache.bitmapFont[t]
                },
                removeJSON: function(t) {
                    delete this._cache.json[t]
                },
                removeXML: function(t) {
                    delete this._cache.xml[t]
                },
                removeVideo: function(t) {
                    delete this._cache.video[t]
                },
                removeShader: function(t) {
                    delete this._cache.shader[t]
                },
                removeRenderTexture: function(t) {
                    delete this._cache.renderTexture[t]
                },
                removeSpriteSheet: function(t) {
                    delete this._cache.spriteSheet[t]
                },
                removeTextureAtlas: function(t) {
                    delete this._cache.atlas[t]
                },
                clearGLTextures: function() {
                    for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
                },
                _resolveURL: function(t, e) {
                    return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
                },
                destroy: function() {
                    for (var t = 0; t < this._cacheMap.length; t++) {
                        var e, i = this._cacheMap[t];
                        for (e in i) "__default" !== e && "__missing" !== e && (i[e].destroy && i[e].destroy(), delete i[e])
                    }
                    this._urlMap = null, this._urlResolver = null, this._urlTemp = null
                }
            }, X.Cache.prototype.constructor = X.Cache, X.Loader = function(t) {
                this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                    requestedWith: !1,
                    json: "application/json",
                    xml: "application/xml"
                }, this.onLoadStart = new X.Signal, this.onLoadComplete = new X.Signal, this.onPackComplete = new X.Signal, this.onFileStart = new X.Signal, this.onFileComplete = new X.Signal, this.onFileError = new X.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
            }, X.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, X.Loader.TEXTURE_ATLAS_JSON_HASH = 1, X.Loader.TEXTURE_ATLAS_XML_STARLING = 2, X.Loader.PHYSICS_LIME_CORONA_JSON = 3, X.Loader.PHYSICS_PHASER_JSON = 4, X.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, X.Loader.prototype = {
                setPreloadSprite: function(t, e) {
                    e = e || 0, this.preloadSprite = {
                        sprite: t,
                        direction: e,
                        width: t.width,
                        height: t.height,
                        rect: null
                    }, this.preloadSprite.rect = 0 === e ? new X.Rectangle(0, 0, 1, t.height) : new X.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                },
                resize: function() {
                    this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
                },
                checkKeyExists: function(t, e) {
                    return -1 < this.getAssetIndex(t, e)
                },
                getAssetIndex: function(t, e) {
                    for (var i = -1, s = 0; s < this._fileList.length; s++) {
                        var n = this._fileList[s];
                        if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                    }
                    return i
                },
                getAsset: function(t, e) {
                    e = this.getAssetIndex(t, e);
                    return -1 < e && {
                        index: e,
                        file: this._fileList[e]
                    }
                },
                reset: function(t, e) {
                    void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
                },
                addToFileList: function(t, e, i, s, n, a) {
                    if (void 0 === n && (n = !1), void 0 === e || "" === e) return this;
                    if (null == i) {
                        if (!a) return this;
                        i = e + a
                    }
                    var o = {
                        type: t,
                        key: e,
                        path: this.path,
                        url: i,
                        syncPoint: 0 < this._withSyncPointDepth,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1
                    };
                    if (s)
                        for (var r in s) o[r] = s[r];
                    e = this.getAssetIndex(t, e);
                    return n && -1 < e ? (n = this._fileList[e]).loading || n.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[e] = o : -1 === e && (this._fileList.push(o), this._totalFileCount++), this
                },
                replaceInFileList: function(t, e, i, s) {
                    return this.addToFileList(t, e, i, s, !0)
                },
                pack: function(t, e, i, s) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return this;
                    var n = {
                        type: "packfile",
                        key: t,
                        url: e,
                        path: this.path,
                        syncPoint: !0,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1,
                        callbackContext: s
                    };
                    i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                    for (var a = 0; a < this._fileList.length + 1; a++) {
                        var o = this._fileList[a];
                        if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                            this._fileList.splice(a, 0, n), this._totalPackCount++;
                            break
                        }
                    }
                    return this
                },
                image: function(t, e, i) {
                    return this.addToFileList("image", t, e, void 0, i, ".png")
                },
                images: function(t, e) {
                    if (Array.isArray(e))
                        for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                    else
                        for (i = 0; i < t.length; i++) this.image(t[i]);
                    return this
                },
                text: function(t, e, i) {
                    return this.addToFileList("text", t, e, void 0, i, ".txt")
                },
                json: function(t, e, i) {
                    return this.addToFileList("json", t, e, void 0, i, ".json")
                },
                shader: function(t, e, i) {
                    return this.addToFileList("shader", t, e, void 0, i, ".frag")
                },
                xml: function(t, e, i) {
                    return this.addToFileList("xml", t, e, void 0, i, ".xml")
                },
                script: function(t, e, i, s) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                        syncPoint: !0,
                        callback: i,
                        callbackContext: s
                    }, !1, ".js")
                },
                binary: function(t, e, i, s) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                        callback: i,
                        callbackContext: s
                    }, !1, ".bin")
                },
                spritesheet: function(t, e, i, s, n, a, o) {
                    return void 0 === n && (n = -1), void 0 === a && (a = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                        frameWidth: i,
                        frameHeight: s,
                        frameMax: n,
                        margin: a,
                        spacing: o
                    }, !1, ".png")
                },
                audio: function(t, e, i) {
                    return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                        buffer: null,
                        autoDecode: i
                    }))
                },
                audioSprite: function(t, e, i, s, n) {
                    return this.game.sound.noAudio || (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s && ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s))), this
                },
                audiosprite: function(t, e, i, s, n) {
                    return this.audioSprite(t, e, i, s, n)
                },
                video: function(t, e, i, s) {
                    return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                        buffer: null,
                        asBlob: s,
                        loadEvent: i
                    })
                },
                tilemap: function(t, e, i, s) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = X.Tilemap.CSV), e || i || (e = s === X.Tilemap.CSV ? t + ".csv" : t + ".json"), i) {
                        switch (s) {
                            case X.Tilemap.CSV:
                                break;
                            case X.Tilemap.TILED_JSON:
                                "string" == typeof i && (i = JSON.parse(i))
                        }
                        this.cache.addTilemap(t, null, i, s)
                    } else this.addToFileList("tilemap", t, e, {
                        format: s
                    });
                    return this
                },
                physics: function(t, e, i, s) {
                    return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = X.Physics.LIME_CORONA_JSON), e || i || (e = t + ".json"), i ? ("string" == typeof i && (i = JSON.parse(i)), this.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {
                        format: s
                    }), this
                },
                bitmapFont: function(t, e, i, s, n, a) {
                    if (null != e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === a && (a = 0), i) this.addToFileList("bitmapfont", t, e, {
                        atlasURL: i,
                        xSpacing: n,
                        ySpacing: a
                    });
                    else if ("string" == typeof s) {
                        var o, r;
                        try {
                            o = JSON.parse(s)
                        } catch (t) {
                            r = this.parseXml(s)
                        }
                        if (!r && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                        this.addToFileList("bitmapfont", t, e, {
                            atlasURL: null,
                            atlasData: o || r,
                            atlasType: o ? "json" : "xml",
                            xSpacing: n,
                            ySpacing: a
                        })
                    }
                    return this
                },
                atlasJSONArray: function(t, e, i, s) {
                    return this.atlas(t, e, i, s, X.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                },
                atlasJSONHash: function(t, e, i, s) {
                    return this.atlas(t, e, i, s, X.Loader.TEXTURE_ATLAS_JSON_HASH)
                },
                atlasXML: function(t, e, i, s) {
                    return void 0 === i && (i = null), void 0 === s && (s = null), i || s || (i = t + ".xml"), this.atlas(t, e, i, s, X.Loader.TEXTURE_ATLAS_XML_STARLING)
                },
                atlas: function(t, e, i, s, n) {
                    if (null != e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = X.Loader.TEXTURE_ATLAS_JSON_ARRAY), i || s || (i = n === X.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), i) this.addToFileList("textureatlas", t, e, {
                        atlasURL: i,
                        format: n
                    });
                    else {
                        switch (n) {
                            case X.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                "string" == typeof s && (s = JSON.parse(s));
                                break;
                            case X.Loader.TEXTURE_ATLAS_XML_STARLING:
                                if ("string" == typeof s) {
                                    var a = this.parseXml(s);
                                    if (!a) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                    s = a
                                }
                        }
                        this.addToFileList("textureatlas", t, e, {
                            atlasURL: null,
                            atlasData: s,
                            format: n
                        })
                    }
                    return this
                },
                withSyncPoint: function(t, e) {
                    this._withSyncPointDepth++;
                    try {
                        t.call(e || this, this)
                    } finally {
                        this._withSyncPointDepth--
                    }
                    return this
                },
                addSyncPoint: function(t, e) {
                    e = this.getAsset(t, e);
                    return e && (e.file.syncPoint = !0), this
                },
                removeFile: function(t, e) {
                    e = this.getAsset(t, e);
                    e && (e.loaded || e.loading || this._fileList.splice(e.index, 1))
                },
                removeAll: function() {
                    this._fileList.length = 0, this._flightQueue.length = 0
                },
                start: function() {
                    this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
                },
                processLoadQueue: function() {
                    if (this.isLoading) {
                        for (var t = 0; t < this._flightQueue.length; t++)((e = this._flightQueue[t]).loaded || e.error) && (this._flightQueue.splice(t, 1), t--, e.loading = !1, e.requestUrl = null, e.requestObject = null, e.error && this.onFileError.dispatch(e.key, e), "packfile" !== e.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, e.key, !e.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === e.type && e.error && (this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)));
                        for (var e, i, s = !1, n = this.enableParallel ? X.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, t = this._processingHead; t < this._fileList.length; t++)
                            if ("packfile" === (e = this._fileList[t]).type && !e.error && e.loaded && t === this._processingHead && (this.processPack(e), this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)), e.loaded || e.error ? t === this._processingHead && (this._processingHead = t + 1) : !e.loading && this._flightQueue.length < n && ("packfile" !== e.type || e.data ? s || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(e), e.loading = !0, this.onFileStart.dispatch(this.progress, e.key, e.url), this.loadFile(e)) : (this._flightQueue.push(e), e.loading = !0, this.loadFile(e))), !e.loaded && e.syncPoint && (s = !0), this._flightQueue.length >= n || s && this._loadedPackCount === this._totalPackCount) break;
                        this.updateProgress(), this._processingHead >= this._fileList.length ? this.finishedLoading() : this._flightQueue.length || (i = this, setTimeout(function() {
                            i.finishedLoading(!0)
                        }, 2e3))
                    } else this.finishedLoading(!0)
                },
                finishedLoading: function(t) {
                    this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
                },
                asyncComplete: function(t, e) {
                    void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e), this.processLoadQueue()
                },
                processPack: function(t) {
                    var e = t.data[t.key];
                    if (e)
                        for (var i = 0; i < e.length; i++) {
                            var s = e[i];
                            switch (s.type) {
                                case "image":
                                    this.image(s.key, s.url, s.overwrite);
                                    break;
                                case "text":
                                    this.text(s.key, s.url, s.overwrite);
                                    break;
                                case "json":
                                    this.json(s.key, s.url, s.overwrite);
                                    break;
                                case "xml":
                                    this.xml(s.key, s.url, s.overwrite);
                                    break;
                                case "script":
                                    this.script(s.key, s.url, s.callback, t.callbackContext || this);
                                    break;
                                case "binary":
                                    this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                                    break;
                                case "spritesheet":
                                    this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                                    break;
                                case "video":
                                    this.video(s.key, s.urls);
                                    break;
                                case "audio":
                                    this.audio(s.key, s.urls, s.autoDecode);
                                    break;
                                case "audiosprite":
                                    this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                                    break;
                                case "tilemap":
                                    this.tilemap(s.key, s.url, s.data, X.Tilemap[s.format]);
                                    break;
                                case "physics":
                                    this.physics(s.key, s.url, s.data, X.Loader[s.format]);
                                    break;
                                case "bitmapFont":
                                    this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                                    break;
                                case "atlasJSONArray":
                                    this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlasJSONHash":
                                    this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlasXML":
                                    this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlas":
                                    this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, X.Loader[s.format]);
                                    break;
                                case "shader":
                                    this.shader(s.key, s.url, s.overwrite)
                            }
                        }
                },
                transformUrl: function(t, e) {
                    return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
                },
                loadFile: function(t) {
                    switch (t.type) {
                        case "packfile":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "image":
                        case "spritesheet":
                        case "textureatlas":
                        case "bitmapfont":
                            this.loadImageTag(t);
                            break;
                        case "audio":
                            t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                            break;
                        case "video":
                            t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                            break;
                        case "json":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                            break;
                        case "xml":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                            break;
                        case "tilemap":
                            t.format === X.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === X.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                            break;
                        case "text":
                        case "script":
                        case "shader":
                        case "physics":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "binary":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                    }
                },
                loadImageTag: function(t) {
                    var e = this;
                    t.data = new Image, e.crossOrigin = "Anonymous", t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                    }, t.data.onerror = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                    }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
                },
                loadVideoTag: function(t) {
                    var e = this;
                    t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                    var i = function() {
                        t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !0, X.GAMES[e.game.id].load.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                    }, t.data.addEventListener(t.loadEvent, i, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
                },
                loadAudioTag: function(t) {
                    var e, i = this;
                    this.game.sound.touchLocked ? (t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t)) : (t.data = new Audio, t.data.name = t.key, e = function() {
                        t.data.removeEventListener("canplaythrough", e, !1), t.data.onerror = null, i.fileComplete(t)
                    }, t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", e, !1), t.data.onerror = null, i.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", e, !1), t.data.load())
                },
                xhrLoad: function(e, t, i, s, n) {
                    var a, o;
                    this.useXDomainRequest && window.XDomainRequest ? this.xhrLoadWithXDR(e, t, i, s, n) : ((a = new XMLHttpRequest).open("GET", t, !0), a.responseType = i, !1 !== this.headers.requestedWith && a.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[e.type] && a.setRequestHeader("Accept", this.headers[e.type]), n = n || this.fileError, o = this, a.onload = function() {
                        try {
                            return (4 === a.readyState && 400 <= a.status && a.status <= 599 ? n : s).call(o, e, a)
                        } catch (t) {
                            o.hasLoaded ? window.console : o.asyncComplete(e, t.message || "Exception")
                        }
                    }, a.onerror = function() {
                        try {
                            return n.call(o, e, a)
                        } catch (t) {
                            o.hasLoaded ? window.console : o.asyncComplete(e, t.message || "Exception")
                        }
                    }, e.requestObject = a, e.requestUrl = t, a.send())
                },
                xhrLoadWithXDR: function(e, t, i, s, n) {
                    this._warnedAboutXDomainRequest || this.game.device.ie && !(10 <= this.game.device.ieVersion) || (this._warnedAboutXDomainRequest = !0);
                    var a = new window.XDomainRequest;
                    a.open("GET", t, !0), a.responseType = i, a.timeout = 3e3, n = n || this.fileError;
                    var o = this;
                    a.onerror = function() {
                        try {
                            return n.call(o, e, a)
                        } catch (t) {
                            o.asyncComplete(e, t.message || "Exception")
                        }
                    }, a.ontimeout = function() {
                        try {
                            return n.call(o, e, a)
                        } catch (t) {
                            o.asyncComplete(e, t.message || "Exception")
                        }
                    }, a.onprogress = function() {}, a.onload = function() {
                        try {
                            return (4 === a.readyState && 400 <= a.status && a.status <= 599 ? n : s).call(o, e, a)
                        } catch (t) {
                            o.asyncComplete(e, t.message || "Exception")
                        }
                    }, e.requestObject = a, e.requestUrl = t, setTimeout(function() {
                        a.send()
                    }, 0)
                },
                getVideoURL: function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var i, s = t[e];
                        if (s.uri) {
                            if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                        } else {
                            if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                            if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                        }
                    }
                    return null
                },
                getAudioURL: function(t) {
                    if (this.game.sound.noAudio) return null;
                    for (var e = 0; e < t.length; e++) {
                        var i, s = t[e];
                        if (s.uri) {
                            if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                        } else {
                            if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                            if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                        }
                    }
                    return null
                },
                fileError: function(t, e, i) {
                    var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                    !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
                },
                fileComplete: function(t, e) {
                    var i = !0;
                    switch (t.type) {
                        case "packfile":
                            var s = JSON.parse(e.responseText);
                            t.data = s || {};
                            break;
                        case "image":
                            this.cache.addImage(t.key, t.url, t.data);
                            break;
                        case "spritesheet":
                            this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                            break;
                        case "textureatlas":
                            if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                            else if (i = !1, t.format === X.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === X.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === X.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                            else {
                                if (t.format !== X.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                            }
                            break;
                        case "bitmapfont":
                            t.atlasURL ? (i = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                var i;
                                try {
                                    i = JSON.parse(e.responseText)
                                } catch (t) {}
                                i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                            })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                            break;
                        case "video":
                            if (t.asBlob) try {
                                t.data = e.response
                            } catch (e) {
                                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                            }
                            this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                            break;
                        case "audio":
                            this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                            break;
                        case "text":
                            t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                            break;
                        case "shader":
                            t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                            break;
                        case "physics":
                            s = JSON.parse(e.responseText);
                            this.cache.addPhysicsData(t.key, t.url, s, t.format);
                            break;
                        case "script":
                            t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                            break;
                        case "binary":
                            t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                    }
                    i && this.asyncComplete(t)
                },
                jsonLoadComplete: function(t, e) {
                    e = JSON.parse(e.responseText);
                    "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, e, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, e, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, e) : this.cache.addTextureAtlas(t.key, t.url, t.data, e, t.format), this.asyncComplete(t)
                },
                csvLoadComplete: function(t, e) {
                    e = e.responseText;
                    this.cache.addTilemap(t.key, t.url, e, t.format), this.asyncComplete(t)
                },
                xmlLoadComplete: function(t, e) {
                    var i = e.responseText,
                        i = this.parseXml(i);
                    i ? ("bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, i), this.asyncComplete(t)) : (e.responseType || e.contentType, this.asyncComplete(t, "invalid XML"))
                },
                parseXml: function(t) {
                    var e;
                    try {
                        window.DOMParser ? e = (new DOMParser).parseFromString(t, "text/xml") : ((e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t))
                    } catch (t) {
                        e = null
                    }
                    return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
                },
                updateProgress: function() {
                    this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
                },
                totalLoadedFiles: function() {
                    return this._loadedFileCount
                },
                totalQueuedFiles: function() {
                    return this._totalFileCount - this._loadedFileCount
                },
                totalLoadedPacks: function() {
                    return this._totalPackCount
                },
                totalQueuedPacks: function() {
                    return this._totalPackCount - this._loadedPackCount
                }
            }, Object.defineProperty(X.Loader.prototype, "progressFloat", {
                get: function() {
                    var t = this._loadedFileCount / this._totalFileCount * 100;
                    return X.Math.clamp(t || 0, 0, 100)
                }
            }), Object.defineProperty(X.Loader.prototype, "progress", {
                get: function() {
                    return Math.round(this.progressFloat)
                }
            }), X.Loader.prototype.constructor = X.Loader, X.LoaderParser = {
                bitmapFont: function(t, e, i, s) {
                    return this.xmlBitmapFont(t, e, i, s)
                },
                xmlBitmapFont: function(t, e, i, s) {
                    var n = {},
                        a = t.getElementsByTagName("info")[0],
                        o = t.getElementsByTagName("common")[0];
                    n.font = a.getAttribute("face"), n.size = parseInt(a.getAttribute("size"), 10), n.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) + s, n.chars = {};
                    for (var r = t.getElementsByTagName("char"), h = 0; h < r.length; h++) {
                        var l = parseInt(r[h].getAttribute("id"), 10);
                        n.chars[l] = {
                            x: parseInt(r[h].getAttribute("x"), 10),
                            y: parseInt(r[h].getAttribute("y"), 10),
                            width: parseInt(r[h].getAttribute("width"), 10),
                            height: parseInt(r[h].getAttribute("height"), 10),
                            xOffset: parseInt(r[h].getAttribute("xoffset"), 10),
                            yOffset: parseInt(r[h].getAttribute("yoffset"), 10),
                            xAdvance: parseInt(r[h].getAttribute("xadvance"), 10) + i,
                            kerning: {}
                        }
                    }
                    for (var c = t.getElementsByTagName("kerning"), h = 0; h < c.length; h++) {
                        var u = parseInt(c[h].getAttribute("first"), 10),
                            d = parseInt(c[h].getAttribute("second"), 10),
                            p = parseInt(c[h].getAttribute("amount"), 10);
                        n.chars[d].kerning[u] = p
                    }
                    return this.finalizeBitmapFont(e, n)
                },
                jsonBitmapFont: function(t, e, i, s) {
                    var n = {
                        font: t.font.info._face,
                        size: parseInt(t.font.info._size, 10),
                        lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                        chars: {}
                    };
                    return t.font.chars.char.forEach(function(t) {
                        var e = parseInt(t._id, 10);
                        n.chars[e] = {
                            x: parseInt(t._x, 10),
                            y: parseInt(t._y, 10),
                            width: parseInt(t._width, 10),
                            height: parseInt(t._height, 10),
                            xOffset: parseInt(t._xoffset, 10),
                            yOffset: parseInt(t._yoffset, 10),
                            xAdvance: parseInt(t._xadvance, 10) + i,
                            kerning: {}
                        }
                    }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                        n.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                    }), this.finalizeBitmapFont(e, n)
                },
                finalizeBitmapFont: function(e, i) {
                    return Object.keys(i.chars).forEach(function(t) {
                        t = i.chars[t];
                        t.texture = new PIXI.Texture(e, new X.Rectangle(t.x, t.y, t.width, t.height))
                    }), i
                }
            }, X.AudioSprite = function(t, e) {
                for (var i in this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}, this.config.spritemap) {
                    var s = this.config.spritemap[i],
                        n = this.game.add.sound(this.key);
                    n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
                }
                this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
            }, X.AudioSprite.prototype = {
                play: function(t, e) {
                    return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
                },
                stop: function(t) {
                    if (t) this.sounds[t].stop();
                    else
                        for (var e in this.sounds) this.sounds[e].stop()
                },
                get: function(t) {
                    return this.sounds[t]
                }
            }, X.AudioSprite.prototype.constructor = X.AudioSprite, X.Sound = function(t, e, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === n && (n = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = i * this.game.sound.volume, n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new X.Signal, this.onPlay = new X.Signal, this.onPause = new X.Signal, this.onResume = new X.Signal, this.onLoop = new X.Signal, this.onStop = new X.Signal, this.onMute = new X.Signal, this.onMarkerComplete = new X.Signal, this.onFadeComplete = new X.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
            }, X.Sound.prototype = {
                soundHasUnlocked: function(t) {
                    t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                },
                addMarker: function(t, e, i, s, n) {
                    null != i || (i = 1), null != s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                        name: t,
                        start: e,
                        stop: e + i,
                        volume: s,
                        duration: i,
                        durationMS: 1e3 * i,
                        loop: n
                    }
                },
                removeMarker: function(t) {
                    delete this.markers[t]
                },
                onEndedHandler: function() {
                    this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
                },
                update: function() {
                    this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
                },
                loopFull: function(t) {
                    return this.play(null, 0, t, !0)
                },
                play: function(t, e, i, s, n) {
                    if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                    if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) {
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                        this.isPlaying = !1
                    }
                    if ("" === t && 0 < Object.keys(this.markers).length) return this;
                    if ("" !== t) {
                        if (!this.markers[t]) return this;
                        this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                    } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                    return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
                },
                restart: function(t, e, i, s) {
                    t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
                },
                pause: function() {
                    this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
                },
                resume: function() {
                    var t, e;
                    this.paused && this._sound && (this.usingWebAudio ? (t = Math.max(0, this.position + this.pausedPosition / 1e3), this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this)), e = this.duration - this.pausedPosition / 1e3, void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)) : (this._sound.currentTime = this._tempPause, this._sound.play()), this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this))
                },
                stop: function() {
                    if (this.isPlaying && this._sound)
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    var t;
                    this.pendingPlayback = !1, this.isPlaying = !1, this.paused || (t = this.currentMarker, "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t))
                },
                fadeIn: function(t, e, i) {
                    void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
                },
                fadeOut: function(t) {
                    this.fadeTo(t, 0)
                },
                fadeTo: function(t, e) {
                    this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e && (this.fadeTween = this.game.add.tween(this).to({
                        volume: e
                    }, t, X.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)))
                },
                fadeComplete: function() {
                    this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
                },
                updateGlobalVolume: function(t) {
                    this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
                },
                destroy: function(t) {
                    void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                }
            }, X.Sound.prototype.constructor = X.Sound, Object.defineProperty(X.Sound.prototype, "isDecoding", {
                get: function() {
                    return this.game.cache.getSound(this.key).isDecoding
                }
            }), Object.defineProperty(X.Sound.prototype, "isDecoded", {
                get: function() {
                    return this.game.cache.isSoundDecoded(this.key)
                }
            }), Object.defineProperty(X.Sound.prototype, "mute", {
                get: function() {
                    return this._muted || this.game.sound.mute
                },
                set: function(t) {
                    (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
                }
            }), Object.defineProperty(X.Sound.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t))
                }
            }), X.SoundManager = function(t) {
                this.game = t, this.onSoundDecode = new X.Signal, this.onVolumeChange = new X.Signal, this.onMute = new X.Signal, this.onUnMute = new X.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new X.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
            }, X.SoundManager.prototype = {
                boot: function() {
                    if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                        if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                        if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                    }
                    if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                    else if (window.AudioContext) try {
                        this.context = new window.AudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    } else if (window.webkitAudioContext) try {
                        this.context = new window.webkitAudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    }
                    if (null === this.context) {
                        if (void 0 === window.Audio) return void(this.noAudio = !0);
                        this.usingAudioTag = !0
                    } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                    this.noAudio || !this.game.device.cocoonJS && (this.game.device.android || this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
                },
                setTouchLock: function() {
                    this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (8 < this.game.device.iOSVersion || 55 <= this.game.device.chromeVersion ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
                },
                unlock: function() {
                    return this.noAudio || !this.touchLocked || null !== this._unlockSource || (this.usingAudioTag ? (this.touchLocked = !1, this._unlockSource = null) : this.usingWebAudio && (t = this.context.createBuffer(1, 1, 22050), this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), "suspended" === this._unlockSource.context.state && this._unlockSource.context.resume())), !0;
                    var t
                },
                stopAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                },
                pauseAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                },
                resumeAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                },
                decode: function(e, i) {
                    i = i || null;
                    var t = this.game.cache.getSoundData(e);
                    if (t && !1 === this.game.cache.isSoundDecoded(e)) {
                        this.game.cache.updateSound(e, "isDecoding", !0);
                        var s = this;
                        try {
                            this.context.decodeAudioData(t, function(t) {
                                t && (s.game.cache.decodedSound(e, t), s.onSoundDecode.dispatch(e, i))
                            })
                        } catch (e) {}
                    }
                },
                setDecodedCallback: function(t, e, i) {
                    "string" == typeof t && (t = [t]), this._watchList.reset();
                    for (var s = 0; s < t.length; s++) t[s] instanceof X.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                    0 === this._watchList.total ? (this._watching = !1, e.call(i)) : (this._watching = !0, this._watchCallback = e, this._watchContext = i)
                },
                update: function() {
                    if (!this.noAudio) {
                        !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                        if (this._watching) {
                            for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                            0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                        }
                    }
                },
                add: function(t, e, i, s) {
                    void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === s && (s = this.connectToMaster);
                    s = new X.Sound(this.game, t, e, i, s);
                    return this._sounds.push(s), s
                },
                addSprite: function(t) {
                    return new X.AudioSprite(this.game, t)
                },
                remove: function(t) {
                    for (var e = this._sounds.length; e--;)
                        if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                    return !1
                },
                removeByKey: function(t) {
                    for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                    return i
                },
                play: function(t, e, i) {
                    if (!this.noAudio) {
                        i = this.add(t, e, i);
                        return i.play(), i
                    }
                },
                setMute: function() {
                    if (!this._muted) {
                        this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                        this.onMute.dispatch()
                    }
                },
                unsetMute: function() {
                    if (this._muted && !this._codeMuted) {
                        this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                        this.onUnMute.dispatch()
                    }
                },
                destroy: function() {
                    this.stopAll();
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                    this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
                }
            }, X.SoundManager.prototype.constructor = X.SoundManager, Object.defineProperty(X.SoundManager.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    (t = t || !1) ? this._muted || (this._codeMuted = !0, this.setMute()): this._muted && (this._codeMuted = !1, this.unsetMute())
                }
            }), Object.defineProperty(X.SoundManager.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    if (t < 0 ? t = 0 : 1 < t && (t = 1), this._volume !== t) {
                        if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                        else
                            for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                        this.onVolumeChange.dispatch(t)
                    }
                }
            }), X.ScaleManager = function(t, e, i) {
                this.game = t, this.dom = X.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new X.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new X.Signal, this.enterIncorrectOrientation = new X.Signal, this.leaveIncorrectOrientation = new X.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new X.Signal, this.onFullScreenChange = new X.Signal, this.onFullScreenError = new X.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new X.Point(1, 1), this.scaleFactorInversed = new X.Point(1, 1), this.margin = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                    x: 0,
                    y: 0
                }, this.bounds = new X.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                    right: "layout",
                    bottom: ""
                }, this.compatibility = {
                    supportsFullScreen: !1,
                    orientationFallback: null,
                    noMargins: !1,
                    scrollTo: null,
                    forceMinimumDocumentHeight: !1,
                    canExpandParent: !0,
                    clickTrampoline: ""
                }, this._scaleMode = X.ScaleManager.NO_SCALE, this._fullScreenScaleMode = X.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new X.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new X.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new X.Rectangle, this._userScaleFactor = new X.Point(1, 1), this._userScaleTrim = new X.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new X.Rectangle, this._tempBounds = new X.Rectangle, this._lastReportedCanvasSize = new X.Rectangle, this._lastReportedGameSize = new X.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, i)
            }, X.ScaleManager.EXACT_FIT = 0, X.ScaleManager.NO_SCALE = 1, X.ScaleManager.SHOW_ALL = 2, X.ScaleManager.RESIZE = 3, X.ScaleManager.USER_SCALE = 4, X.ScaleManager.prototype = {
                boot: function() {
                    var t = this.compatibility;
                    t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new X.Point(0, 1) : t.scrollTo = new X.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                    var e = this;
                    this._orientationChange = function(t) {
                        return e.orientationChange(t)
                    }, this._windowResize = function(t) {
                        return e.windowResize(t)
                    }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                        return e.fullScreenChange(t)
                    }, this._fullScreenError = function(t) {
                        return e.fullScreenError(t)
                    }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), X.FlexGrid && (this.grid = new X.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
                },
                parseConfig: function(t) {
                    void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
                },
                setupScale: function(t, e) {
                    var i = new X.Rectangle;
                    "" !== this.game.parent && ("string" == typeof this.game.parent ? n = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (n = this.game.parent)), n ? (this.parentNode = n, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), i.width = this._parentBounds.width, i.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, i.width = this.dom.visualBounds.width, i.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                    var s = 0,
                        n = 0,
                        s = "number" == typeof t ? t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, i.width * this.parentScaleFactor.x),
                        n = "number" == typeof e ? e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, i.height * this.parentScaleFactor.y);
                    s = Math.floor(s), n = Math.floor(n), this._gameSize.setTo(0, 0, s, n), this.updateDimensions(s, n, !1)
                },
                _gameResumed: function() {
                    this.queueUpdate(!0)
                },
                setGameSize: function(t, e) {
                    this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== X.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
                },
                setUserScale: function(t, e, i, s) {
                    this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), this.queueUpdate(!0)
                },
                setResizeCallback: function(t, e) {
                    this.onResize = t, this.onResizeContext = e
                },
                signalSizeChange: function() {
                    var t, e;
                    X.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) && X.Rectangle.sameDimensions(this.game, this._lastReportedGameSize) || (t = this.width, e = this.height, this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === X.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e)))
                },
                setMinMax: function(t, e, i, s) {
                    this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
                },
                preUpdate: function() {
                    var t, e, i, s;
                    this.game.time.time < this._lastUpdate + this._updateThrottle || (t = this._updateThrottle, this._updateThrottleReset = 400 <= t ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset), e = this._parentBounds.width, i = this._parentBounds.height, e = (s = this.getParentBounds(this._parentBounds)).width !== e || s.height !== i, i = this.updateOrientationState(), (e || i) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange()), s = 2 * this._updateThrottle, this._updateThrottle < t && (s = Math.min(t, this._updateThrottleReset)), this._updateThrottle = X.Math.clamp(s, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time)
                },
                pauseUpdate: function() {
                    this.preUpdate(), this._updateThrottle = this.trackParentInterval
                },
                updateDimensions: function(t, e, i) {
                    this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
                },
                updateScalingAndBounds: function() {
                    this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
                },
                forceOrientation: function(t, e) {
                    void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
                },
                classifyOrientation: function(t) {
                    return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
                },
                updateOrientationState: function() {
                    var t = this.screenOrientation,
                        e = this.incorrectOrientation;
                    this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                    var i = t !== this.screenOrientation,
                        s = e !== this.incorrectOrientation;
                    return s && (this.incorrectOrientation ? this.enterIncorrectOrientation : this.leaveIncorrectOrientation).dispatch(), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
                },
                orientationChange: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                windowResize: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                scrollTop: function() {
                    var t = this.compatibility.scrollTo;
                    t && window.scrollTo(t.x, t.y)
                },
                refresh: function() {
                    this.scrollTop(), this.queueUpdate(!0)
                },
                updateLayout: function() {
                    var t = this.currentScaleMode;
                    t !== X.ScaleManager.RESIZE ? (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === X.ScaleManager.EXACT_FIT ? this.setExactFit() : t === X.ScaleManager.SHOW_ALL ? (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent && (this.setShowAll(!0), this.resetCanvas()), this.setShowAll()) : t === X.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === X.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), this.compatibility.canExpandParent || t !== X.ScaleManager.SHOW_ALL && t !== X.ScaleManager.USER_SCALE || (t = this.getParentBounds(this._tempBounds), this.width = Math.min(this.width, t.width), this.height = Math.min(this.height, t.height)), this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()) : this.reflowGame()
                },
                getParentBounds: function(t) {
                    var e, i = t || new X.Rectangle,
                        s = this.boundingParent,
                        n = this.dom.visualBounds,
                        a = this.dom.layoutBounds;
                    return s ? (t = s.getBoundingClientRect(), s = (s.offsetParent || s).getBoundingClientRect(), i.setTo(t.left - s.left, t.top - s.top, t.width, t.height), (t = this.windowConstraints).right && (e = "layout" === t.right ? a : n, i.right = Math.min(i.right, e.width)), t.bottom && (e = "layout" === t.bottom ? a : n, i.bottom = Math.min(i.bottom, e.height))) : i.setTo(0, 0, n.width, n.height), i.setTo(Math.round(i.x), Math.round(i.y), Math.round(i.width), Math.round(i.height)), i
                },
                alignCanvas: function(t, e) {
                    var i, s, n, a, o = this.getParentBounds(this._tempBounds),
                        r = this.game.canvas,
                        h = this.margin;
                    t && (h.left = h.right = 0, i = r.getBoundingClientRect(), this.width < o.width && !this.incorrectOrientation && (s = i.left - o.x, n = o.width / 2 - this.width / 2, a = (n = Math.max(n, 0)) - s, h.left = Math.round(a)), r.style.marginLeft = h.left + "px", 0 !== h.left && (h.right = -(o.width - i.width - h.left), r.style.marginRight = h.right + "px")), e && (h.top = h.bottom = 0, i = r.getBoundingClientRect(), this.height < o.height && !this.incorrectOrientation && (s = i.top - o.y, n = o.height / 2 - this.height / 2, a = (n = Math.max(n, 0)) - s, h.top = Math.round(a)), r.style.marginTop = h.top + "px", 0 !== h.top && (h.bottom = -(o.height - i.height - h.top), r.style.marginBottom = h.bottom + "px")), h.x = h.left, h.y = h.top
                },
                reflowGame: function() {
                    this.resetCanvas("", "");
                    var t = this.getParentBounds(this._tempBounds);
                    this.updateDimensions(t.width, t.height, !0)
                },
                reflowCanvas: function() {
                    this.incorrectOrientation || (this.width = X.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = X.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
                },
                resetCanvas: function(t, e) {
                    void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                    var i = this.game.canvas;
                    this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
                },
                queueUpdate: function(t) {
                    t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
                },
                reset: function(t) {
                    t && this.grid && this.grid.reset()
                },
                setMaximum: function() {
                    this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
                },
                setShowAll: function(t) {
                    var e = this.getParentBounds(this._tempBounds),
                        i = e.width,
                        e = e.height,
                        i = t ? Math.max(e / this.game.height, i / this.game.width) : Math.min(e / this.game.height, i / this.game.width);
                    this.width = Math.round(this.game.width * i), this.height = Math.round(this.game.height * i)
                },
                setExactFit: function() {
                    var t = this.getParentBounds(this._tempBounds);
                    this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
                },
                createFullScreenTarget: function() {
                    var t = document.createElement("div");
                    return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
                },
                startFullScreen: function(t, e) {
                    if (this.isFullScreen) return !1;
                    if (this.compatibility.supportsFullScreen) {
                        if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                            var i = this.game.input;
                            if (i.activePointer && i.activePointer !== i.mousePointer && (e || !1 !== e)) return void i.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                        }
                        void 0 !== t && this.game.renderType === X.CANVAS && (this.game.stage.smoothed = t);
                        i = this.fullScreenTarget;
                        i || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), i = this._createdFullScreenTarget);
                        t = {
                            targetElement: i
                        };
                        return this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, t), this._createdFullScreenTarget && ((t = this.game.canvas).parentNode.insertBefore(i, t), i.appendChild(t)), this.game.device.fullscreenKeyboard ? i[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : i[this.game.device.requestFullscreen](), !0
                    }
                    var s = this;
                    setTimeout(function() {
                        s.fullScreenError()
                    }, 10)
                },
                stopFullScreen: function() {
                    return !(!this.isFullScreen || !this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), 0))
                },
                cleanupCreatedTarget: function() {
                    var t, e = this._createdFullScreenTarget;
                    e && e.parentNode && ((t = e.parentNode).insertBefore(this.game.canvas, e), t.removeChild(e)), this._createdFullScreenTarget = null
                },
                prepScreenMode: function(t) {
                    var e = !!this._createdFullScreenTarget,
                        i = this._createdFullScreenTarget || this.fullScreenTarget;
                    t ? !e && this.fullScreenScaleMode !== X.ScaleManager.EXACT_FIT || i === this.game.canvas || (this._fullScreenRestore = {
                        targetWidth: i.style.width,
                        targetHeight: i.style.height
                    }, i.style.width = "100%", i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth, i.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
                },
                fullScreenChange: function(t) {
                    this.event = t, this.isFullScreen ? this.prepScreenMode(!0) : (this.prepScreenMode(!1), this.cleanupCreatedTarget()), this.updateLayout(), this.queueUpdate(!0), this.onFullScreenChange.dispatch(this, this.width, this.height)
                },
                fullScreenError: function(t) {
                    this.event = t, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this)
                },
                scaleSprite: function(t, e, i, s) {
                    if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                    if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                    var n = t.height * e / t.width,
                        a = t.width * i / t.height,
                        i = i;
                    return (e < a ? s : !s) ? (t.width = Math.floor(e), t.height = Math.floor(n)) : (t.width = Math.floor(a), t.height = Math.floor(i)), t
                },
                destroy: function() {
                    this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
                }
            }, X.ScaleManager.prototype.constructor = X.ScaleManager, Object.defineProperty(X.ScaleManager.prototype, "boundingParent", {
                get: function() {
                    return !(this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget) && this.game.canvas && this.game.canvas.parentNode || null
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "scaleMode", {
                get: function() {
                    return this._scaleMode
                },
                set: function(t) {
                    return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "fullScreenScaleMode", {
                get: function() {
                    return this._fullScreenScaleMode
                },
                set: function(t) {
                    return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "currentScaleMode", {
                get: function() {
                    return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "pageAlignHorizontally", {
                get: function() {
                    return this._pageAlignHorizontally
                },
                set: function(t) {
                    t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "pageAlignVertically", {
                get: function() {
                    return this._pageAlignVertically
                },
                set: function(t) {
                    t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "isFullScreen", {
                get: function() {
                    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "isPortrait", {
                get: function() {
                    return "portrait" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "isLandscape", {
                get: function() {
                    return "landscape" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "isGamePortrait", {
                get: function() {
                    return this.height > this.width
                }
            }), Object.defineProperty(X.ScaleManager.prototype, "isGameLandscape", {
                get: function() {
                    return this.width > this.height
                }
            }), X.Utils.Debug = function(t) {
                this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
            }, X.Utils.Debug.prototype = {
                boot: function() {
                    this.game.renderType === X.CANVAS ? this.context = this.game.context : (this.bmd = new X.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
                },
                resize: function(t, e, i) {
                    this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
                },
                preUpdate: function() {
                    this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                },
                reset: function() {
                    this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
                },
                start: function(t, e, i, s) {
                    "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
                },
                stop: function() {
                    this.context.restore()
                },
                line: function() {
                    for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                    this.currentY += this.lineHeight
                },
                soundInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
                },
                cameraInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
                },
                timer: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                },
                pointer: function(t, e, i, s, n) {
                    null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
                },
                spriteInputInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                },
                key: function(t, e, i, s) {
                    this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                },
                inputInfo: function(t, e, i) {
                    this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
                },
                spriteBounds: function(t, e, i) {
                    t = t.getBounds();
                    t.x += this.game.camera.x, t.y += this.game.camera.y, this.rectangle(t, e, i)
                },
                ropeSegments: function(t, e, i) {
                    var s = this;
                    t.segments.forEach(function(t) {
                        s.rectangle(t, e, i)
                    }, this)
                },
                spriteInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
                },
                spriteCoords: function(t, e, i, s) {
                    this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                },
                lineInfo: function(t, e, i, s) {
                    this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                },
                pixel: function(t, e, i, s) {
                    s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
                },
                geom: function(t, e, i, s) {
                    void 0 === i && (i = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof X.Rectangle || 1 === s ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof X.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : t instanceof X.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof X.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
                },
                rectangle: function(t, e, i) {
                    void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                },
                text: function(t, e, i, s, n) {
                    s = s || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
                },
                quadTree: function(t, e) {
                    e = e || "rgba(255,0,0,0.3)", this.start();
                    var i = t.bounds;
                    if (0 === t.nodes.length) {
                        this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                        for (var s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                    } else
                        for (s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                    this.stop()
                },
                body: function(t, e, i) {
                    t.body && (this.start(), t.body.type === X.Physics.ARCADE ? X.Physics.Arcade.Body.render(this.context, t.body, e, i) : t.body.type === X.Physics.NINJA ? X.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === X.Physics.BOX2D && X.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
                },
                bodyInfo: function(t, e, i, s) {
                    t.body && (this.start(e, i, s, 210), t.body.type === X.Physics.ARCADE ? X.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === X.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
                },
                box2dWorld: function() {
                    this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
                },
                box2dBody: function(t, e) {
                    this.start(), X.Physics.Box2D.renderBody(this.context, t, e), this.stop()
                },
                displayList: function(t) {
                    if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID"), t.children && 0 < t.children.length)
                        for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
                },
                destroy: function() {
                    PIXI.CanvasPool.remove(this)
                }
            }, X.Utils.Debug.prototype.constructor = X.Utils.Debug, X.DOM = {
                getOffset: function(t, e) {
                    e = e || new X.Point;
                    var i = t.getBoundingClientRect(),
                        s = X.DOM.scrollY,
                        n = X.DOM.scrollX,
                        a = document.documentElement.clientTop,
                        t = document.documentElement.clientLeft;
                    return e.x = i.left + n - t, e.y = i.top + s - a, e
                },
                getBounds: function(t, e) {
                    return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
                },
                calibrate: function(t, e) {
                    e = +e || 0;
                    var i = {
                        width: 0,
                        height: 0,
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    };
                    return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
                },
                getAspectRatio: function(t) {
                    var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                        i = t.height;
                    return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
                },
                inLayoutViewport: function(t, e) {
                    e = this.getBounds(t, e);
                    return !!e && 0 <= e.bottom && 0 <= e.right && e.top <= this.layoutBounds.width && e.left <= this.layoutBounds.height
                },
                getScreenOrientation: function(t) {
                    var e = window.screen,
                        i = e.orientation || e.mozOrientation || e.msOrientation;
                    if (i && "string" == typeof i.type) return i.type;
                    if ("string" == typeof i) return i;
                    var s = "portrait-primary",
                        i = "landscape-primary";
                    if ("screen" === t) return e.height > e.width ? s : i;
                    if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : i;
                    if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : i;
                    if (window.matchMedia) {
                        if (window.matchMedia("(orientation: portrait)").matches) return s;
                        if (window.matchMedia("(orientation: landscape)").matches) return i
                    }
                    return this.visualBounds.height > this.visualBounds.width ? s : i
                },
                visualBounds: new X.Rectangle,
                layoutBounds: new X.Rectangle,
                documentBounds: new X.Rectangle
            }, X.Device.whenReady(function(t) {
                var e = window && "pageXOffset" in window ? function() {
                        return window.pageXOffset
                    } : function() {
                        return document.documentElement.scrollLeft
                    },
                    i = window && "pageYOffset" in window ? function() {
                        return window.pageYOffset
                    } : function() {
                        return document.documentElement.scrollTop
                    };
                Object.defineProperty(X.DOM, "scrollX", {
                    get: e
                }), Object.defineProperty(X.DOM, "scrollY", {
                    get: i
                }), Object.defineProperty(X.DOM.visualBounds, "x", {
                    get: e
                }), Object.defineProperty(X.DOM.visualBounds, "y", {
                    get: i
                }), Object.defineProperty(X.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(X.DOM.layoutBounds, "y", {
                    value: 0
                }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight ? (i = function() {
                    return Math.max(window.innerWidth, document.documentElement.clientWidth)
                }, t = function() {
                    return Math.max(window.innerHeight, document.documentElement.clientHeight)
                }, Object.defineProperty(X.DOM.visualBounds, "width", {
                    get: i
                }), Object.defineProperty(X.DOM.visualBounds, "height", {
                    get: t
                }), Object.defineProperty(X.DOM.layoutBounds, "width", {
                    get: i
                }), Object.defineProperty(X.DOM.layoutBounds, "height", {
                    get: t
                })) : (Object.defineProperty(X.DOM.visualBounds, "width", {
                    get: function() {
                        return window.innerWidth
                    }
                }), Object.defineProperty(X.DOM.visualBounds, "height", {
                    get: function() {
                        return window.innerHeight
                    }
                }), Object.defineProperty(X.DOM.layoutBounds, "width", {
                    get: function() {
                        var t = document.documentElement.clientWidth,
                            e = window.innerWidth;
                        return t < e ? e : t
                    }
                }), Object.defineProperty(X.DOM.layoutBounds, "height", {
                    get: function() {
                        var t = document.documentElement.clientHeight,
                            e = window.innerHeight;
                        return t < e ? e : t
                    }
                })), Object.defineProperty(X.DOM.documentBounds, "x", {
                    value: 0
                }), Object.defineProperty(X.DOM.documentBounds, "y", {
                    value: 0
                }), Object.defineProperty(X.DOM.documentBounds, "width", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                    }
                }), Object.defineProperty(X.DOM.documentBounds, "height", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                    }
                })
            }, null, !0), X.ArraySet = function(t) {
                this.position = 0, this.list = t || []
            }, X.ArraySet.prototype = {
                add: function(t) {
                    return this.exists(t) || this.list.push(t), t
                },
                getIndex: function(t) {
                    return this.list.indexOf(t)
                },
                getByKey: function(t, e) {
                    for (var i = this.list.length; i--;)
                        if (this.list[i][t] === e) return this.list[i];
                    return null
                },
                exists: function(t) {
                    return -1 < this.list.indexOf(t)
                },
                reset: function() {
                    this.list.length = 0
                },
                remove: function(t) {
                    var e = this.list.indexOf(t);
                    if (-1 < e) return this.list.splice(e, 1), t
                },
                setAll: function(t, e) {
                    for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
                },
                callAll: function(t) {
                    for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                },
                removeAll: function(t) {
                    void 0 === t && (t = !1);
                    for (var e, i = this.list.length; i--;) this.list[i] && (e = this.remove(this.list[i]), t && e.destroy());
                    this.position = 0, this.list = []
                }
            }, Object.defineProperty(X.ArraySet.prototype, "total", {
                get: function() {
                    return this.list.length
                }
            }), Object.defineProperty(X.ArraySet.prototype, "first", {
                get: function() {
                    return (this.position = 0) < this.list.length ? this.list[0] : null
                }
            }), Object.defineProperty(X.ArraySet.prototype, "next", {
                get: function() {
                    return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
                }
            }), X.ArraySet.prototype.constructor = X.ArraySet, X.ArrayUtils = {
                getRandomItem: function(t, e, i) {
                    if (null === t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    i = e + Math.floor(Math.random() * i);
                    return void 0 === t[i] ? null : t[i]
                },
                removeRandomItem: function(t, e, i) {
                    if (null == t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    i = e + Math.floor(Math.random() * i);
                    if (i < t.length) {
                        i = t.splice(i, 1);
                        return void 0 === i[0] ? null : i[0]
                    }
                    return null
                },
                shuffle: function(t) {
                    for (var e = t.length - 1; 0 < e; e--) {
                        var i = Math.floor(Math.random() * (e + 1)),
                            s = t[e];
                        t[e] = t[i], t[i] = s
                    }
                    return t
                },
                transposeMatrix: function(t) {
                    for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                        s[n] = new Array(e);
                        for (var a = e - 1; - 1 < a; a--) s[n][a] = t[a][n]
                    }
                    return s
                },
                rotateMatrix: function(t, e) {
                    if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = X.ArrayUtils.transposeMatrix(t)).reverse();
                    else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = X.ArrayUtils.transposeMatrix(t);
                    else if (180 === Math.abs(e) || "rotate180" === e) {
                        for (var i = 0; i < t.length; i++) t[i].reverse();
                        t = t.reverse()
                    }
                    return t
                },
                findClosest: function(t, e) {
                    if (!e.length) return NaN;
                    if (1 === e.length || t < e[0]) return e[0];
                    for (var i = 1; e[i] < t;) i++;
                    var s = e[i - 1],
                        n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                    return n - t <= t - s ? n : s
                },
                rotateRight: function(t) {
                    var e = t.pop();
                    return t.unshift(e), e
                },
                rotateLeft: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                rotate: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                numberArray: function(t, e) {
                    for (var i = [], s = t; s <= e; s++) i.push(s);
                    return i
                },
                numberArrayStep: function(t, e, i) {
                    null != t || (t = 0), null != e || (e = t, t = 0), void 0 === i && (i = 1);
                    for (var s = [], n = Math.max(X.Math.roundAwayFromZero((e - t) / (i || 1)), 0), a = 0; a < n; a++) s.push(t), t += i;
                    return s
                }
            }, X.LinkedList = function() {
                this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
            }, X.LinkedList.prototype = {
                add: function(t) {
                    return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, (this.next = t).prev = this) : ((this.last.next = t).prev = this.last, this.last = t), this.total++, t
                },
                reset: function() {
                    this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                },
                remove: function(t) {
                    if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                    t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), (t.next = t.prev = null) === this.first && (this.last = null), this.total--
                },
                callAll: function(t) {
                    if (this.first && this.last)
                        for (var e = this.first; e && e[t] && e[t].call(e), e = e.next, e !== this.last.next;);
                }
            }, X.LinkedList.prototype.constructor = X.LinkedList, X.Create = function(t) {
                this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                    0: "#000",
                    1: "#9D9D9D",
                    2: "#FFF",
                    3: "#BE2633",
                    4: "#E06F8B",
                    5: "#493C2B",
                    6: "#A46422",
                    7: "#EB8931",
                    8: "#F7E26B",
                    9: "#2F484E",
                    A: "#44891A",
                    B: "#A3CE27",
                    C: "#1B2632",
                    D: "#005784",
                    E: "#31A2F2",
                    F: "#B2DCEF"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#f5f4eb"
                }, {
                    0: "#000",
                    1: "#2234d1",
                    2: "#0c7e45",
                    3: "#44aacc",
                    4: "#8a3622",
                    5: "#5c2e78",
                    6: "#aa5c3d",
                    7: "#b5b5b5",
                    8: "#5e606e",
                    9: "#4c81fb",
                    A: "#6cd947",
                    B: "#7be2f9",
                    C: "#eb8a60",
                    D: "#e23d69",
                    E: "#ffd93f",
                    F: "#fff"
                }, {
                    0: "#000",
                    1: "#fff",
                    2: "#8b4131",
                    3: "#7bbdc5",
                    4: "#8b41ac",
                    5: "#6aac41",
                    6: "#3931a4",
                    7: "#d5de73",
                    8: "#945a20",
                    9: "#5a4100",
                    A: "#bd736a",
                    B: "#525252",
                    C: "#838383",
                    D: "#acee8b",
                    E: "#7b73de",
                    F: "#acacac"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#fff"
                }]
            }, X.Create.PALETTE_ARNE = 0, X.Create.PALETTE_JMP = 1, X.Create.PALETTE_CGA = 2, X.Create.PALETTE_C64 = 3, X.Create.PALETTE_JAPANESE_MACHINE = 4, X.Create.prototype = {
                texture: function(t, e, i, s, n) {
                    void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0);
                    var a = e[0].length * i,
                        o = e.length * s;
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(a, o), this.bmd.clear();
                    for (var r = 0; r < e.length; r++)
                        for (var h = e[r], l = 0; l < h.length; l++) {
                            var c = h[l];
                            "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[n][c], this.ctx.fillRect(l * i, r * s, i, s))
                        }
                    return this.bmd.generateTexture(t)
                },
                grid: function(t, e, i, s, n, a) {
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = a;
                    for (var o = 0; o < i; o += n) this.ctx.fillRect(0, o, e, 1);
                    for (var r = 0; r < e; r += s) this.ctx.fillRect(r, 0, 1, i);
                    return this.bmd.generateTexture(t)
                }
            }, X.Create.prototype.constructor = X.Create, X.FlexGrid = function(t, e, i) {
                this.game = t.game, this.manager = t, this.width = e, this.height = i, this.boundsCustom = new X.Rectangle(0, 0, e, i), this.boundsFluid = new X.Rectangle(0, 0, e, i), this.boundsFull = new X.Rectangle(0, 0, e, i), this.boundsNone = new X.Rectangle(0, 0, e, i), this.positionCustom = new X.Point(0, 0), this.positionFluid = new X.Point(0, 0), this.positionFull = new X.Point(0, 0), this.positionNone = new X.Point(0, 0), this.scaleCustom = new X.Point(1, 1), this.scaleFluid = new X.Point(1, 1), this.scaleFluidInversed = new X.Point(1, 1), this.scaleFull = new X.Point(1, 1), this.scaleNone = new X.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / i, this.ratioV = i / e, this.multiplier = 0, this.layers = []
            }, X.FlexGrid.prototype = {
                setSize: function(t, e) {
                    this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new X.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
                },
                createCustomLayer: function(t, e, i, s) {
                    void 0 === s && (s = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                    e = new X.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                    return s && this.game.world.add(e), this.layers.push(e), void 0 !== i && null !== typeof i && e.addMultiple(i), e
                },
                createFluidLayer: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = new X.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                    return e && this.game.world.add(i), this.layers.push(i), void 0 !== t && null !== typeof t && i.addMultiple(t), i
                },
                createFullLayer: function(t) {
                    var e = new X.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                createFixedLayer: function(t) {
                    var e = new X.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                reset: function() {
                    for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
                },
                onResize: function(t, e) {
                    this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
                },
                refresh: function() {
                    this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
                },
                fitSprite: function(t) {
                    this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
                },
                debug: function() {
                    this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
                }
            }, X.FlexGrid.prototype.constructor = X.FlexGrid, X.FlexLayer = function(t, e, i, s) {
                X.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = i, this.scale = s, this.topLeft = i.topLeft, this.topMiddle = new X.Point(i.halfWidth, 0), this.topRight = i.topRight, this.bottomLeft = i.bottomLeft, this.bottomMiddle = new X.Point(i.halfWidth, i.bottom), this.bottomRight = i.bottomRight
            }, X.FlexLayer.prototype = Object.create(X.Group.prototype), X.FlexLayer.prototype.constructor = X.FlexLayer, X.FlexLayer.prototype.resize = function() {}, X.FlexLayer.prototype.debug = function() {
                this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
            }, X.Color = {
                packPixel: function(t, e, i, s) {
                    return X.Device.LITTLE_ENDIAN ? (s << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | s) >>> 0
                },
                unpackPixel: function(t, e, i, s) {
                    return null != e || (e = X.Color.createColor()), null != i || (i = !1), null != s || (s = !1), X.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", i && X.Color.RGBtoHSL(e.r, e.g, e.b, e), s && X.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                },
                fromRGBA: function(t, e) {
                    return (e = e || X.Color.createColor()).r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                },
                toRGBA: function(t, e, i, s) {
                    return t << 24 | e << 16 | i << 8 | s
                },
                toABGR: function(t, e, i, s) {
                    return (s << 24 | i << 16 | e << 8 | t) >>> 0
                },
                RGBtoHSL: function(t, e, i, s) {
                    s = s || X.Color.createColor(t, e, i, 1), t /= 255, e /= 255, i /= 255;
                    var n, a = Math.min(t, e, i),
                        o = Math.max(t, e, i);
                    return s.h = 0, s.s = 0, s.l = (o + a) / 2, o !== a && (n = o - a, s.s = .5 < s.l ? n / (2 - o - a) : n / (o + a), o === t ? s.h = (e - i) / n + (e < i ? 6 : 0) : o === e ? s.h = (i - t) / n + 2 : o === i && (s.h = (t - e) / n + 4), s.h /= 6), s
                },
                HSLtoRGB: function(t, e, i, s) {
                    return s ? (s.r = i, s.g = i, s.b = i) : s = X.Color.createColor(i, i, i), 0 !== e && (e = 2 * i - (i = i < .5 ? i * (1 + e) : i + e - i * e), s.r = X.Color.hueToColor(e, i, t + 1 / 3), s.g = X.Color.hueToColor(e, i, t), s.b = X.Color.hueToColor(e, i, t - 1 / 3)), s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), X.Color.updateColor(s), s
                },
                RGBtoHSV: function(t, e, i, s) {
                    s = s || X.Color.createColor(t, e, i, 255), t /= 255, e /= 255, i /= 255;
                    var n = Math.min(t, e, i),
                        a = Math.max(t, e, i),
                        o = a - n;
                    return s.h = 0, s.s = 0 === a ? 0 : o / a, (s.v = a) !== n && (a === t ? s.h = (e - i) / o + (e < i ? 6 : 0) : a === e ? s.h = (i - t) / o + 2 : a === i && (s.h = (t - e) / o + 4), s.h /= 6), s
                },
                HSVtoRGB: function(t, e, i, s) {
                    void 0 === s && (s = X.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                    var n, a, o, r = Math.floor(6 * t),
                        t = 6 * t - r,
                        h = i * (1 - e),
                        l = i * (1 - t * e),
                        c = i * (1 - (1 - t) * e);
                    switch (r % 6) {
                        case 0:
                            n = i, a = c, o = h;
                            break;
                        case 1:
                            n = l, a = i, o = h;
                            break;
                        case 2:
                            n = h, a = i, o = c;
                            break;
                        case 3:
                            n = h, a = l, o = i;
                            break;
                        case 4:
                            n = c, a = h, o = i;
                            break;
                        case 5:
                            n = i, a = h, o = l
                    }
                    return s.r = Math.floor(255 * n), s.g = Math.floor(255 * a), s.b = Math.floor(255 * o), X.Color.updateColor(s), s
                },
                hueToColor: function(t, e, i) {
                    return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                },
                createColor: function(t, e, i, s, n, a, o, r) {
                    r = {
                        r: t || 0,
                        g: e || 0,
                        b: i || 0,
                        a: s || 1,
                        h: n || 0,
                        s: a || 0,
                        l: o || 0,
                        v: r || 0,
                        color: 0,
                        color32: 0,
                        rgba: ""
                    };
                    return X.Color.updateColor(r)
                },
                updateColor: function(t) {
                    return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = X.Color.getColor(t.r, t.g, t.b), t.color32 = X.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
                },
                getColor32: function(t, e, i, s) {
                    return t << 24 | e << 16 | i << 8 | s
                },
                getColor: function(t, e, i) {
                    return t << 16 | e << 8 | i
                },
                RGBtoString: function(t, e, i, s, n) {
                    return void 0 === s && (s = 255), void 0 === n && (n = "#"), "#" === n ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + X.Color.componentToHex(s) + X.Color.componentToHex(t) + X.Color.componentToHex(e) + X.Color.componentToHex(i)
                },
                hexToRGB: function(t) {
                    t = X.Color.hexToColor(t);
                    if (t) return X.Color.getColor32(t.a, t.r, t.g, t.b)
                },
                hexToColor: function(t, e) {
                    t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                        return e + e + i + i + s + s
                    });
                    var i, s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                    return s && (i = parseInt(s[1], 16), t = parseInt(s[2], 16), s = parseInt(s[3], 16), e ? (e.r = i, e.g = t, e.b = s) : e = X.Color.createColor(i, t, s)), e
                },
                webToColor: function(t, e) {
                    e = e || X.Color.createColor();
                    t = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                    return t && (e.r = parseInt(t[1], 10), e.g = parseInt(t[2], 10), e.b = parseInt(t[3], 10), e.a = void 0 !== t[4] ? parseFloat(t[4]) : 1, X.Color.updateColor(e)), e
                },
                valueToColor: function(t, e) {
                    if (e = e || X.Color.createColor(), "string" == typeof t) return 0 === t.indexOf("rgb") ? X.Color.webToColor(t, e) : (e.a = 1, X.Color.hexToColor(t, e));
                    if ("number" != typeof t) return e;
                    t = X.Color.getRGB(t);
                    return e.r = t.r, e.g = t.g, e.b = t.b, e.a = t.a / 255, e
                },
                componentToHex: function(t) {
                    t = t.toString(16);
                    return 1 === t.length ? "0" + t : t
                },
                HSVColorWheel: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = 1);
                    for (var i = [], s = 0; s <= 359; s++) i.push(X.Color.HSVtoRGB(s / 359, t, e));
                    return i
                },
                HSLColorWheel: function(t, e) {
                    void 0 === t && (t = .5), void 0 === e && (e = .5);
                    for (var i = [], s = 0; s <= 359; s++) i.push(X.Color.HSLtoRGB(s / 359, t, e));
                    return i
                },
                interpolateColor: function(t, e, i, s, n) {
                    void 0 === n && (n = 255);
                    var a = X.Color.getRGB(t),
                        o = X.Color.getRGB(e),
                        t = (o.red - a.red) * s / i + a.red,
                        e = (o.green - a.green) * s / i + a.green,
                        a = (o.blue - a.blue) * s / i + a.blue;
                    return X.Color.getColor32(n, t, e, a)
                },
                interpolateColorWithRGB: function(t, e, i, s, n, a) {
                    t = X.Color.getRGB(t), e = (e - t.red) * a / n + t.red, i = (i - t.green) * a / n + t.green, t = (s - t.blue) * a / n + t.blue;
                    return X.Color.getColor(e, i, t)
                },
                interpolateRGB: function(t, e, i, s, n, a, o, r) {
                    t = (s - t) * r / o + t, e = (n - e) * r / o + e, i = (a - i) * r / o + i;
                    return X.Color.getColor(t, e, i)
                },
                getRandomColor: function(t, e, i) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === i && (i = 255), 255 < e || e < t) return X.Color.getColor(255, 255, 255);
                    var s = t + Math.round(Math.random() * (e - t)),
                        n = t + Math.round(Math.random() * (e - t)),
                        t = t + Math.round(Math.random() * (e - t));
                    return X.Color.getColor32(i, s, n, t)
                },
                getRGB: function(t) {
                    return 16777215 < t ? {
                        alpha: t >>> 24,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: t >>> 24,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    } : {
                        alpha: 255,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: 255,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    }
                },
                getWebRGB: function(t) {
                    if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                    t = X.Color.getRGB(t);
                    return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")"
                },
                getAlpha: function(t) {
                    return t >>> 24
                },
                getAlphaFloat: function(t) {
                    return (t >>> 24) / 255
                },
                getRed: function(t) {
                    return t >> 16 & 255
                },
                getGreen: function(t) {
                    return t >> 8 & 255
                },
                getBlue: function(t) {
                    return 255 & t
                },
                blendNormal: function(t) {
                    return t
                },
                blendLighten: function(t, e) {
                    return t < e ? e : t
                },
                blendDarken: function(t, e) {
                    return t < e ? t : e
                },
                blendMultiply: function(t, e) {
                    return t * e / 255
                },
                blendAverage: function(t, e) {
                    return (t + e) / 2
                },
                blendAdd: function(t, e) {
                    return Math.min(255, t + e)
                },
                blendSubtract: function(t, e) {
                    return Math.max(0, t + e - 255)
                },
                blendDifference: function(t, e) {
                    return Math.abs(t - e)
                },
                blendNegation: function(t, e) {
                    return 255 - Math.abs(255 - t - e)
                },
                blendScreen: function(t, e) {
                    return 255 - ((255 - t) * (255 - e) >> 8)
                },
                blendExclusion: function(t, e) {
                    return t + e - 2 * t * e / 255
                },
                blendOverlay: function(t, e) {
                    return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
                },
                blendSoftLight: function(t, e) {
                    return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
                },
                blendHardLight: function(t, e) {
                    return X.Color.blendOverlay(e, t)
                },
                blendColorDodge: function(t, e) {
                    return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
                },
                blendColorBurn: function(t, e) {
                    return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
                },
                blendLinearDodge: function(t, e) {
                    return X.Color.blendAdd(t, e)
                },
                blendLinearBurn: function(t, e) {
                    return X.Color.blendSubtract(t, e)
                },
                blendLinearLight: function(t, e) {
                    return e < 128 ? X.Color.blendLinearBurn(t, 2 * e) : X.Color.blendLinearDodge(t, 2 * (e - 128))
                },
                blendVividLight: function(t, e) {
                    return e < 128 ? X.Color.blendColorBurn(t, 2 * e) : X.Color.blendColorDodge(t, 2 * (e - 128))
                },
                blendPinLight: function(t, e) {
                    return e < 128 ? X.Color.blendDarken(t, 2 * e) : X.Color.blendLighten(t, 2 * (e - 128))
                },
                blendHardMix: function(t, e) {
                    return X.Color.blendVividLight(t, e) < 128 ? 0 : 255
                },
                blendReflect: function(t, e) {
                    return 255 === e ? e : Math.min(255, t * t / (255 - e))
                },
                blendGlow: function(t, e) {
                    return X.Color.blendReflect(e, t)
                },
                blendPhoenix: function(t, e) {
                    return Math.min(t, e) - Math.max(t, e) + 255
                }
            }, X.Physics = function(t, e) {
                e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
            }, X.Physics.ARCADE = 0, X.Physics.P2JS = 1, X.Physics.NINJA = 2, X.Physics.BOX2D = 3, X.Physics.CHIPMUNK = 4, X.Physics.MATTERJS = 5, X.Physics.prototype = {
                parseConfig: function() {
                    this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !X.Physics.hasOwnProperty("Arcade") || (this.arcade = new X.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && X.Physics.hasOwnProperty("Ninja") && (this.ninja = new X.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && X.Physics.hasOwnProperty("P2") && (this.p2 = new X.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && X.Physics.hasOwnProperty("BOX2D") && (this.box2d = new X.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && X.Physics.hasOwnProperty("Matter") && (this.matter = new X.Physics.Matter(this.game, this.config))
                },
                startSystem: function(t) {
                    t === X.Physics.ARCADE ? this.arcade = new X.Physics.Arcade(this.game) : t === X.Physics.P2JS ? null === this.p2 ? this.p2 = new X.Physics.P2(this.game, this.config) : this.p2.reset() : t === X.Physics.NINJA ? this.ninja = new X.Physics.Ninja(this.game) : t === X.Physics.BOX2D ? null === this.box2d ? this.box2d = new X.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === X.Physics.MATTERJS && (null === this.matter ? this.matter = new X.Physics.Matter(this.game, this.config) : this.matter.reset())
                },
                enable: function(t, e, i) {
                    void 0 === e && (e = X.Physics.ARCADE), void 0 === i && (i = !1), e === X.Physics.ARCADE ? this.arcade.enable(t) : e === X.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === X.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === X.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === X.Physics.MATTERJS && this.matter && this.matter.enable(t)
                },
                preUpdate: function() {
                    this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
                },
                update: function() {
                    this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
                },
                setBoundsToWorld: function() {
                    this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
                },
                clear: function() {
                    this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
                },
                reset: function() {
                    this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
                },
                destroy: function() {
                    this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
                }
            }, X.Physics.prototype.constructor = X.Physics, X.Physics.Arcade = function(t) {
                this.game = t, this.gravity = new X.Point, this.bounds = new X.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = X.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new X.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
            }, X.Physics.Arcade.prototype.constructor = X.Physics.Arcade, X.Physics.Arcade.SORT_NONE = 0, X.Physics.Arcade.LEFT_RIGHT = 1, X.Physics.Arcade.RIGHT_LEFT = 2, X.Physics.Arcade.TOP_BOTTOM = 3, X.Physics.Arcade.BOTTOM_TOP = 4, X.Physics.Arcade.prototype = {
                setBounds: function(t, e, i, s) {
                    this.bounds.setTo(t, e, i, s)
                },
                setBoundsToWorld: function() {
                    this.bounds.copyFrom(this.game.world.bounds)
                },
                enable: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = 1;
                    if (Array.isArray(t))
                        for (i = t.length; i--;) t[i] instanceof X.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && 0 < t[i].children.length && this.enable(t[i], !0));
                    else t instanceof X.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, !0))
                },
                enableBody: function(t) {
                    t.hasOwnProperty("body") && null === t.body && (t.body = new X.Physics.Arcade.Body(t), t.parent && t.parent instanceof X.Group && t.parent.addToHash(t))
                },
                updateMotion: function(t) {
                    var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                    t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
                },
                computeVelocity: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : n && (0 < i - (n *= this.game.time.physicsElapsed) ? i -= n : i + n < 0 ? i += n : i = 0), a < i ? i = a : i < -a && (i = -a), i
                },
                overlap: function(t, e, i, s, n) {
                    if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < e.length; a++) this.collideHandler(t, e[a], i, s, n, !0);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (a = 0; a < t.length; a++) this.collideHandler(t[a], e, i, s, n, !0);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (a = 0; a < t.length; a++)
                            for (var o = 0; o < e.length; o++) this.collideHandler(t[a], e[o], i, s, n, !0);
                    else this.collideHandler(t, e, i, s, n, !0);
                    return 0 < this._total
                },
                collide: function(t, e, i, s, n) {
                    if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < e.length; a++) this.collideHandler(t, e[a], i, s, n, !1);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (a = 0; a < t.length; a++) this.collideHandler(t[a], e, i, s, n, !1);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (a = 0; a < t.length; a++)
                            for (var o = 0; o < e.length; o++) this.collideHandler(t[a], e[o], i, s, n, !1);
                    else this.collideHandler(t, e, i, s, n, !1);
                    return 0 < this._total
                },
                sortLeftRight: function(t, e) {
                    return t.body && e.body ? t.body.x - e.body.x : 0
                },
                sortRightLeft: function(t, e) {
                    return t.body && e.body ? e.body.x - t.body.x : 0
                },
                sortTopBottom: function(t, e) {
                    return t.body && e.body ? t.body.y - e.body.y : 0
                },
                sortBottomTop: function(t, e) {
                    return t.body && e.body ? e.body.y - t.body.y : 0
                },
                sort: function(t, e) {
                    null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === X.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === X.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === X.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === X.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
                },
                collideHandler: function(t, e, i, s, n, a) {
                    if (void 0 === e && t.physicsType === X.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, i, s, n, a);
                    t && e && t.exists && e.exists && (this.sortDirection !== X.Physics.Arcade.SORT_NONE && (t.physicsType === X.GROUP && this.sort(t), e.physicsType === X.GROUP && this.sort(e)), t.physicsType === X.SPRITE ? e.physicsType === X.SPRITE ? this.collideSpriteVsSprite(t, e, i, s, n, a) : e.physicsType === X.GROUP ? this.collideSpriteVsGroup(t, e, i, s, n, a) : e.physicsType === X.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, s, n, a) : t.physicsType === X.GROUP ? e.physicsType === X.SPRITE ? this.collideSpriteVsGroup(e, t, i, s, n, a) : e.physicsType === X.GROUP ? this.collideGroupVsGroup(t, e, i, s, n, a) : e.physicsType === X.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, n, a) : t.physicsType === X.TILEMAPLAYER && (e.physicsType === X.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, s, n, a) : e.physicsType === X.GROUP && this.collideGroupVsTilemapLayer(e, t, i, s, n, a)))
                },
                collideSpriteVsSprite: function(t, e, i, s, n, a) {
                    return !(!t.body || !e.body || (this.separate(t.body, e.body, s, n, a) && (i && i.call(n, t, e), this._total++), 0))
                },
                collideSpriteVsGroup: function(t, e, i, s, n, a) {
                    if (0 !== e.length && t.body)
                        if (this.skipQuadTree || t.body.skipQuadTree)
                            for (var o = {}, r = 0; r < e.hash.length; r++) {
                                var h = e.hash[r];
                                if (h && h.exists && h.body) {
                                    if (o = h.body.getBounds(o), this.sortDirection === X.Physics.Arcade.LEFT_RIGHT) {
                                        if (t.body.right < o.x) break;
                                        if (o.right < t.body.x) continue
                                    } else if (this.sortDirection === X.Physics.Arcade.RIGHT_LEFT) {
                                        if (t.body.x > o.right) break;
                                        if (o.x > t.body.right) continue
                                    } else if (this.sortDirection === X.Physics.Arcade.TOP_BOTTOM) {
                                        if (t.body.bottom < o.y) break;
                                        if (o.bottom < t.body.y) continue
                                    } else if (this.sortDirection === X.Physics.Arcade.BOTTOM_TOP) {
                                        if (t.body.y > o.bottom) break;
                                        if (o.y > t.body.bottom) continue
                                    }
                                    this.collideSpriteVsSprite(t, h, i, s, n, a)
                                }
                            } else {
                                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                                for (var l = this.quadTree.retrieve(t), r = 0; r < l.length; r++) this.separate(t.body, l[r], s, n, a) && (i && i.call(n, t, l[r].sprite), this._total++)
                            }
                },
                collideGroupVsSelf: function(t, e, i, s, n) {
                    if (0 !== t.length)
                        for (var a = 0; a < t.hash.length; a++) {
                            var o = {},
                                r = t.hash[a];
                            if (r && r.exists && r.body) {
                                o = r.body.getBounds(o);
                                for (var h = a + 1; h < t.hash.length; h++) {
                                    var l = {},
                                        c = t.hash[h];
                                    if (c && c.exists && c.body) {
                                        if (l = c.body.getBounds(l), this.sortDirection === X.Physics.Arcade.LEFT_RIGHT) {
                                            if (o.right < l.x) break;
                                            if (l.right < o.x) continue
                                        } else if (this.sortDirection === X.Physics.Arcade.RIGHT_LEFT) {
                                            if (o.x > l.right) continue;
                                            if (l.x > o.right) break
                                        } else if (this.sortDirection === X.Physics.Arcade.TOP_BOTTOM) {
                                            if (o.bottom < l.y) continue;
                                            if (l.bottom < o.y) break
                                        } else if (this.sortDirection === X.Physics.Arcade.BOTTOM_TOP) {
                                            if (o.y > l.bottom) continue;
                                            if (l.y > r.body.bottom) break
                                        }
                                        this.collideSpriteVsSprite(r, c, e, i, s, n)
                                    }
                                }
                            }
                        }
                },
                collideGroupVsGroup: function(t, e, i, s, n, a) {
                    if (0 !== t.length && 0 !== e.length)
                        for (var o = 0; o < t.children.length; o++) t.children[o].exists && (t.children[o].physicsType === X.GROUP ? this.collideGroupVsGroup(t.children[o], e, i, s, n, a) : this.collideSpriteVsGroup(t.children[o], e, i, s, n, a))
                },
                separate: function(t, e, i, s, n) {
                    if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                    if (i && !1 === i.call(s, t.sprite, e.sprite)) return !1;
                    if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n);
                    if (t.isCircle !== e.isCircle) {
                        var a = t.isCircle ? e : t,
                            o = t.isCircle ? t : e,
                            r = a.x,
                            i = a.y,
                            h = a.right,
                            s = a.bottom,
                            a = o.x + o.radius,
                            o = o.y + o.radius;
                        if ((o < i || s < o) && (a < r || h < a)) return this.separateCircle(t, e, n)
                    }
                    h = !1, a = !1;
                    this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (h = this.separateX(t, e, n), this.intersects(t, e) && (a = this.separateY(t, e, n))) : (a = this.separateY(t, e, n), this.intersects(t, e) && (h = this.separateX(t, e, n)));
                    a = h || a;
                    return a && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), a
                },
                intersects: function(t, e) {
                    return t !== e && (t.isCircle ? e.isCircle ? X.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom))
                },
                circleBodyIntersects: function(t, e) {
                    var i = X.Math.clamp(t.center.x, e.left, e.right),
                        e = X.Math.clamp(t.center.y, e.top, e.bottom);
                    return (t.center.x - i) * (t.center.x - i) + (t.center.y - e) * (t.center.y - e) <= t.radius * t.radius
                },
                separateCircle: function(t, e, i) {
                    this.getOverlapX(t, e), this.getOverlapY(t, e);
                    var s = e.center.x - t.center.x,
                        n = e.center.y - t.center.y,
                        a = Math.atan2(n, s),
                        o = 0;
                    if (t.isCircle !== e.isCircle ? (r = {
                            x: (e.isCircle ? t : e).position.x,
                            y: (e.isCircle ? t : e).position.y,
                            right: (e.isCircle ? t : e).right,
                            bottom: (e.isCircle ? t : e).bottom
                        }, (h = {
                            x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                            y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                            radius: (t.isCircle ? t : e).radius
                        }).y < r.y ? h.x < r.x ? o = X.Math.distance(h.x, h.y, r.x, r.y) - h.radius : r.right < h.x && (o = X.Math.distance(h.x, h.y, r.right, r.y) - h.radius) : r.bottom < h.y && (h.x < r.x ? o = X.Math.distance(h.x, h.y, r.x, r.bottom) - h.radius : r.right < h.x && (o = X.Math.distance(h.x, h.y, r.right, r.bottom) - h.radius)), o *= -1) : o = t.radius + e.radius - X.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y), i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== o && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== o;
                    var n = t.velocity.x * Math.cos(a) + t.velocity.y * Math.sin(a),
                        s = t.velocity.x * Math.sin(a) - t.velocity.y * Math.cos(a),
                        r = e.velocity.x * Math.cos(a) + e.velocity.y * Math.sin(a),
                        h = e.velocity.x * Math.sin(a) - e.velocity.y * Math.cos(a),
                        i = ((t.mass - e.mass) * n + 2 * e.mass * r) / (t.mass + e.mass),
                        r = (2 * t.mass * n + (e.mass - t.mass) * r) / (t.mass + e.mass);
                    return t.immovable || (t.velocity.x = (i * Math.cos(a) - s * Math.sin(a)) * t.bounce.x, t.velocity.y = (s * Math.cos(a) + i * Math.sin(a)) * t.bounce.y), e.immovable || (e.velocity.x = (r * Math.cos(a) - h * Math.sin(a)) * e.bounce.x, e.velocity.y = (h * Math.cos(a) + r * Math.sin(a)) * e.bounce.y), Math.abs(a) < Math.PI / 2 ? 0 < t.velocity.x && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : 0 < t.velocity.y && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(a) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : 0 < e.velocity.x && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : 0 < e.velocity.y && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - o * Math.cos(a), t.y += t.velocity.y * this.game.time.physicsElapsed - o * Math.sin(a)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + o * Math.cos(a), e.y += e.velocity.y * this.game.time.physicsElapsed + o * Math.sin(a)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
                },
                getOverlapX: function(t, e, i) {
                    var s = 0,
                        n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                    return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? n < (s = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (n < -(s = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s
                },
                getOverlapY: function(t, e, i) {
                    var s = 0,
                        n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                    return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? n < (s = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (n < -(s = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s
                },
                separateX: function(t, e, i) {
                    var s = this.getOverlapX(t, e, i);
                    if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
                    var n = t.velocity.x,
                        i = e.velocity.x;
                    return t.immovable || e.immovable ? t.immovable ? (e.x += s, e.velocity.x = n - i * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = i - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)) : (s *= .5, t.x -= s, e.x += s, s = Math.sqrt(i * i * e.mass / t.mass) * (0 < i ? 1 : -1), s -= n = .5 * (s + (i = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1))), i -= n, t.velocity.x = n + s * t.bounce.x, e.velocity.x = n + i * e.bounce.x), !0
                },
                separateY: function(t, e, i) {
                    var s = this.getOverlapY(t, e, i);
                    if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
                    var n = t.velocity.y,
                        i = e.velocity.y;
                    return t.immovable || e.immovable ? t.immovable ? (e.y += s, e.velocity.y = n - i * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = i - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)) : (s *= .5, t.y -= s, e.y += s, s = Math.sqrt(i * i * e.mass / t.mass) * (0 < i ? 1 : -1), s -= n = .5 * (s + (i = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1))), i -= n, t.velocity.y = n + s * t.bounce.y, e.velocity.y = n + i * e.bounce.y), !0
                },
                getObjectsUnderPointer: function(t, e, i, s) {
                    if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
                },
                getObjectsAtLocation: function(t, e, i, s, n, a) {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(i);
                    for (var i = new X.Rectangle(t, e, 1, 1), o = [], r = this.quadTree.retrieve(i), h = 0; h < r.length; h++) r[h].hitTest(t, e) && (s && s.call(n, a, r[h].sprite), o.push(r[h].sprite));
                    return o
                },
                moveToObject: function(t, e, i, s) {
                    void 0 === i && (i = 60), void 0 === s && (s = 0);
                    var n = Math.atan2(e.y - t.y, e.x - t.x);
                    return 0 < s && (i = this.distanceBetween(t, e) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * i, t.body.velocity.y = Math.sin(n) * i, n
                },
                moveToPointer: function(t, e, i, s) {
                    void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === s && (s = 0);
                    var n = this.angleToPointer(t, i);
                    return 0 < s && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * e, t.body.velocity.y = Math.sin(n) * e, n
                },
                moveToXY: function(t, e, i, s, n) {
                    void 0 === s && (s = 60), void 0 === n && (n = 0);
                    var a = Math.atan2(i - t.y, e - t.x);
                    return 0 < n && (s = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.x = Math.cos(a) * s, t.body.velocity.y = Math.sin(a) * s, a
                },
                velocityFromAngle: function(t, e, i) {
                    return void 0 === e && (e = 60), (i = i || new X.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
                },
                velocityFromRotation: function(t, e, i) {
                    return void 0 === e && (e = 60), (i = i || new X.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerationFromRotation: function(t, e, i) {
                    return void 0 === e && (e = 60), (i = i || new X.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerateToObject: function(t, e, i, s, n) {
                    void 0 === i && (i = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                    e = this.angleBetween(t, e);
                    return t.body.acceleration.setTo(Math.cos(e) * i, Math.sin(e) * i), t.body.maxVelocity.setTo(s, n), e
                },
                accelerateToPointer: function(t, e, i, s, n) {
                    void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                    e = this.angleToPointer(t, e);
                    return t.body.acceleration.setTo(Math.cos(e) * i, Math.sin(e) * i), t.body.maxVelocity.setTo(s, n), e
                },
                accelerateToXY: function(t, e, i, s, n, a) {
                    void 0 === s && (s = 60), void 0 === n && (n = 1e3), void 0 === a && (a = 1e3);
                    i = this.angleToXY(t, e, i);
                    return t.body.acceleration.setTo(Math.cos(i) * s, Math.sin(i) * s), t.body.maxVelocity.setTo(n, a), i
                },
                distanceBetween: function(t, e, i) {
                    void 0 === i && (i = !1);
                    var s = i ? t.world.x - e.world.x : t.x - e.x,
                        e = i ? t.world.y - e.world.y : t.y - e.y;
                    return Math.sqrt(s * s + e * e)
                },
                distanceToXY: function(t, e, i, s) {
                    void 0 === s && (s = !1);
                    e = s ? t.world.x - e : t.x - e, i = s ? t.world.y - i : t.y - i;
                    return Math.sqrt(e * e + i * i)
                },
                distanceToPointer: function(t, e, i) {
                    void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                    var s = i ? t.world.x - e.worldX : t.x - e.worldX,
                        e = i ? t.world.y - e.worldY : t.y - e.worldY;
                    return Math.sqrt(s * s + e * e)
                },
                angleBetween: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
                },
                angleBetweenCenters: function(t, e) {
                    var i = e.centerX - t.centerX,
                        t = e.centerY - t.centerY;
                    return Math.atan2(t, i)
                },
                angleToXY: function(t, e, i, s) {
                    return void 0 === s && (s = !1), s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
                },
                angleToPointer: function(t, e, i) {
                    return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
                },
                worldAngleToPointer: function(t, e) {
                    return this.angleToPointer(t, e, !0)
                }
            }, X.Physics.Arcade.Body = function(t) {
                this.sprite = t, this.game = t.game, this.type = X.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new X.Point, this.position = new X.Point(t.x, t.y), this.prev = new X.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new X.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new X.Point, this.newVelocity = new X.Point, this.deltaMax = new X.Point, this.acceleration = new X.Point, this.drag = new X.Point, this.allowGravity = !0, this.gravity = new X.Point, this.bounce = new X.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new X.Point(1e4, 1e4), this.friction = new X.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = X.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                    none: !1,
                    any: !0,
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.touching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.wasTouching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.blocked = {
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.tilePadding = new X.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new X.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
            }, X.Physics.Arcade.Body.prototype = {
                updateBounds: function() {
                    var t, e;
                    this.syncBounds ? ((e = this.sprite.getBounds()).ceilAll(), e.width === this.width && e.height === this.height || (this.width = e.width, this.height = e.height, this._reset = !0)) : (t = Math.abs(this.sprite.scale.x), e = Math.abs(this.sprite.scale.y), t === this._sx && e === this._sy || (this.width = this.sourceWidth * t, this.height = this.sourceHeight * e, this._sx = t, this._sy = e, this._reset = !0)), this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
                },
                preUpdate: function() {
                    this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
                },
                updateMovement: function() {
                    var t, e = 0,
                        i = 0 !== this.overlapX || 0 !== this.overlapY,
                        e = 0 < this.moveDuration ? (this.moveTimer += this.game.time.elapsedMS, this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), this.moveTarget.length / this.moveDistance);
                    return this.movementCallback && (t = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, e)), !(i || 1 <= e || void 0 !== t && !0 !== t) || (this.stopMovement(1 <= e || this.stopVelocityOnCollide && i), !1)
                },
                stopMovement: function(t) {
                    this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
                },
                postUpdate: function() {
                    this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = X.LEFT : 0 < this.deltaX() && (this.facing = X.RIGHT), this.deltaY() < 0 ? this.facing = X.UP : 0 < this.deltaY() && (this.facing = X.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : 0 < this._dx && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : 0 < this._dy && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
                },
                checkWorldBounds: function() {
                    var t, e, i, s, n = this.position,
                        a = this.game.physics.arcade.bounds,
                        o = this.game.physics.arcade.checkCollision,
                        r = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                        h = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                    return this.isCircle ? (t = this.center.x - this.radius, e = this.center.y - this.radius, i = this.center.x + this.radius, s = this.center.y + this.radius, t < a.x && o.left ? (n.x = a.x - this.halfWidth + this.radius, this.velocity.x *= r, this.blocked.left = !0) : i > a.right && o.right && (n.x = a.right - this.halfWidth - this.radius, this.velocity.x *= r, this.blocked.right = !0), e < a.y && o.up ? (n.y = a.y - this.halfHeight + this.radius, this.velocity.y *= h, this.blocked.up = !0) : s > a.bottom && o.down && (n.y = a.bottom - this.halfHeight - this.radius, this.velocity.y *= h, this.blocked.down = !0)) : (n.x < a.x && o.left ? (n.x = a.x, this.velocity.x *= r, this.blocked.left = !0) : this.right > a.right && o.right && (n.x = a.right - this.width, this.velocity.x *= r, this.blocked.right = !0), n.y < a.y && o.up ? (n.y = a.y, this.velocity.y *= h, this.blocked.up = !0) : this.bottom > a.bottom && o.down && (n.y = a.bottom - this.height, this.velocity.y *= h, this.blocked.down = !0)), this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
                },
                moveFrom: function(t, e, i) {
                    return void 0 === e && (e = this.speed), 0 !== e && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.set(Math.cos(s) * e, Math.sin(s) * e), this.isMoving = !0);
                    var s
                },
                moveTo: function(t, e, i) {
                    var s, t = e / (t / 1e3);
                    return 0 != t && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new X.Line, this.moveEnd = new X.Point), this.moveTarget.fromAngle(this.x, this.y, s, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * t, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * t) : this.velocity.set(Math.cos(s) * t, Math.sin(s) * t), this.isMoving = !0)
                },
                setSize: function(t, e, i, s) {
                    void 0 === i && (i = this.offset.x), void 0 === s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
                },
                setCircle: function(t, e, i) {
                    void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), 0 < t ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
                },
                reset: function(t, e) {
                    this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                },
                getBounds: function(t) {
                    return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
                },
                hitTest: function(t, e) {
                    return (this.isCircle ? X.Circle : X.Rectangle).contains(this, t, e)
                },
                onFloor: function() {
                    return this.blocked.down
                },
                onCeiling: function() {
                    return this.blocked.up
                },
                onWall: function() {
                    return this.blocked.left || this.blocked.right
                },
                deltaAbsX: function() {
                    return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
                },
                deltaAbsY: function() {
                    return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
                },
                deltaX: function() {
                    return this.position.x - this.prev.x
                },
                deltaY: function() {
                    return this.position.y - this.prev.y
                },
                deltaZ: function() {
                    return this.rotation - this.preRotation
                },
                destroy: function() {
                    this.sprite.parent && this.sprite.parent instanceof X.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
                }
            }, Object.defineProperty(X.Physics.Arcade.Body.prototype, "left", {
                get: function() {
                    return this.position.x
                }
            }), Object.defineProperty(X.Physics.Arcade.Body.prototype, "right", {
                get: function() {
                    return this.position.x + this.width
                }
            }), Object.defineProperty(X.Physics.Arcade.Body.prototype, "top", {
                get: function() {
                    return this.position.y
                }
            }), Object.defineProperty(X.Physics.Arcade.Body.prototype, "bottom", {
                get: function() {
                    return this.position.y + this.height
                }
            }), Object.defineProperty(X.Physics.Arcade.Body.prototype, "x", {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            }), Object.defineProperty(X.Physics.Arcade.Body.prototype, "y", {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            }), X.Physics.Arcade.Body.render = function(t, e, i, s) {
                void 0 === s && (s = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
            }, X.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
                t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
            }, X.Physics.Arcade.Body.prototype.constructor = X.Physics.Arcade.Body, X.Physics.Arcade.TilemapCollision = function() {}, X.Physics.Arcade.TilemapCollision.prototype = {
                TILE_BIAS: 16,
                collideSpriteVsTilemapLayer: function(t, e, i, s, n, a) {
                    if (t.body) {
                        var o = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                        if (0 !== o.length)
                            for (var r = 0; r < o.length; r++) s ? s.call(n, t, o[r]) && this.separateTile(r, t.body, o[r], e, a) && (this._total++, i && i.call(n, t, o[r])) : this.separateTile(r, t.body, o[r], e, a) && (this._total++, i && i.call(n, t, o[r]))
                    }
                },
                collideGroupVsTilemapLayer: function(t, e, i, s, n, a) {
                    if (0 !== t.length)
                        for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, a)
                },
                separateTile: function(t, e, i, s, n) {
                    if (!e.enable) return !1;
                    var a = s.fixedToCamera ? 0 : s.position.x,
                        o = s.fixedToCamera ? 0 : s.position.y;
                    if (!i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !1;
                    if (n) return !0;
                    if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                    if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                    if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                    var r = 0,
                        h = 0,
                        l = 0,
                        n = 1;
                    if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (n = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - a - i.right), Math.abs(e.right - a - i.left)), n = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < n) {
                        if ((i.faceLeft || i.faceRight) && 0 !== (r = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !0;
                        (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
                    } else {
                        if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !0;
                        (i.faceLeft || i.faceRight) && (r = this.tileCheckX(e, i, s))
                    }
                    return 0 !== r || 0 !== h
                },
                tileCheckX: function(t, e, i) {
                    var s = 0,
                        i = i.fixedToCamera ? 0 : i.position.x;
                    return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - i < e.right && (s = t.x - i - e.right) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaX() && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - i > e.left && (s = t.right - i - e.left) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)), s
                },
                tileCheckY: function(t, e, i) {
                    var s = 0,
                        i = i.fixedToCamera ? 0 : i.position.y;
                    return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - i < e.bottom && (s = t.y - i - e.bottom) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaY() && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - i > e.top && (s = t.bottom - i - e.top) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)), s
                },
                processTileSeparationX: function(t, e) {
                    e < 0 ? t.blocked.left = !0 : 0 < e && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
                },
                processTileSeparationY: function(t, e) {
                    e < 0 ? t.blocked.up = !0 : 0 < e && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
                }
            }, X.Utils.mixinPrototype(X.Physics.Arcade.prototype, X.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, X.Physics.P2 = function(t, e) {
                this.game = t, void 0 === e ? e = {
                    gravity: [0, 0],
                    broadphase: new p2.SAPBroadphase
                } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new X.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }, this.onBodyAdded = new X.Signal, this.onBodyRemoved = new X.Signal, this.onSpringAdded = new X.Signal, this.onSpringRemoved = new X.Signal, this.onConstraintAdded = new X.Signal, this.onConstraintRemoved = new X.Signal, this.onContactMaterialAdded = new X.Signal, this.onContactMaterialRemoved = new X.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new X.Signal, this.onEndContact = new X.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new X.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new X.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new X.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            }, X.Physics.P2.prototype = {
                removeBodyNextStep: function(t) {
                    this._toRemove.push(t)
                },
                preUpdate: function() {
                    for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                    this._toRemove.length = 0
                },
                enable: function(t, e, i) {
                    void 0 === e && (e = !1), void 0 === i && (i = !0);
                    var s = 1;
                    if (Array.isArray(t))
                        for (s = t.length; s--;) t[s] instanceof X.Group ? this.enable(t[s].children, e, i) : (this.enableBody(t[s], e), i && t[s].hasOwnProperty("children") && 0 < t[s].children.length && this.enable(t[s], e, !0));
                    else t instanceof X.Group ? this.enable(t.children, e, i) : (this.enableBody(t, e), i && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, e, !0))
                },
                enableBody: function(t, e) {
                    t.hasOwnProperty("body") && null === t.body && (t.body = new X.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5))
                },
                setImpactEvents: function(t) {
                    t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
                },
                setPostBroadphaseCallback: function(t, e) {
                    this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
                },
                postBroadphaseHandler: function(t) {
                    if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                        for (var e = t.pairs.length - 2; 0 <= e; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
                },
                impactHandler: function(t) {
                    var e, i;
                    t.bodyA.parent && t.bodyB.parent && (e = t.bodyA.parent, i = t.bodyB.parent, e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA))
                },
                beginContactHandler: function(t) {
                    t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
                },
                endContactHandler: function(t) {
                    t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
                },
                setBoundsToWorld: function(t, e, i, s, n) {
                    this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
                },
                setWorldMaterial: function(t, e, i, s, n) {
                    void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === s && (s = !0), void 0 === n && (n = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), s && this.walls.top && (this.walls.top.shapes[0].material = t), n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
                },
                updateBoundsCollisionGroup: function(t) {
                    void 0 === t && (t = !0);
                    var e = (t ? this.boundsCollisionGroup : this.everythingCollisionGroup).mask;
                    this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
                },
                setBounds: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === n && (n = this._boundsLeft), void 0 === a && (a = this._boundsRight), void 0 === o && (o = this._boundsTop), void 0 === r && (r = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(n, "left", t, e, 1.5707963267948966, h), this.setupWall(a, "right", t + i, e, -1.5707963267948966, h), this.setupWall(o, "top", t, e, -3.141592653589793, h), this.setupWall(r, "bottom", t, e + s, 0, h), this._boundsLeft = n, this._boundsRight = a, this._boundsTop = o, this._boundsBottom = r, this._boundsOwnGroup = h
                },
                setupWall: function(t, e, i, s, n, a) {
                    t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                        mass: 0,
                        position: [this.pxmi(i), this.pxmi(s)],
                        angle: n
                    }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), a && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
                },
                pause: function() {
                    this.paused = !0
                },
                resume: function() {
                    this.paused = !1
                },
                update: function() {
                    this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
                },
                reset: function() {
                    this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new X.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new X.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new X.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
                },
                clear: function() {
                    this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                    for (var t = this.world.constraints, e = t.length - 1; 0 <= e; e--) this.world.removeConstraint(t[e]);
                    for (var i = this.world.bodies, e = i.length - 1; 0 <= e; e--) this.world.removeBody(i[e]);
                    for (var s = this.world.springs, e = s.length - 1; 0 <= e; e--) this.world.removeSpring(s[e]);
                    for (var n = this.world.contactMaterials, e = n.length - 1; 0 <= e; e--) this.world.removeContactMaterial(n[e]);
                    this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                        left: null,
                        right: null,
                        top: null,
                        bottom: null
                    }
                },
                destroy: function() {
                    this.clear(), this.game = null
                },
                addBody: function(t) {
                    return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
                },
                removeBody: function(t) {
                    return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
                },
                addSpring: function(t) {
                    return t instanceof X.Physics.P2.Spring || t instanceof X.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
                },
                removeSpring: function(t) {
                    return t instanceof X.Physics.P2.Spring || t instanceof X.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
                },
                createDistanceConstraint: function(t, e, i, s, n, a) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new X.Physics.P2.DistanceConstraint(this, t, e, i, s, n, a))
                },
                createGearConstraint: function(t, e, i, s) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new X.Physics.P2.GearConstraint(this, t, e, i, s))
                },
                createRevoluteConstraint: function(t, e, i, s, n, a) {
                    if (t = this.getBody(t), i = this.getBody(i), t && i) return this.addConstraint(new X.Physics.P2.RevoluteConstraint(this, t, e, i, s, n, a))
                },
                createLockConstraint: function(t, e, i, s, n) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new X.Physics.P2.LockConstraint(this, t, e, i, s, n))
                },
                createPrismaticConstraint: function(t, e, i, s, n, a, o) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new X.Physics.P2.PrismaticConstraint(this, t, e, i, s, n, a, o))
                },
                addConstraint: function(t) {
                    return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
                },
                removeConstraint: function(t) {
                    return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
                },
                addContactMaterial: function(t) {
                    return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
                },
                removeContactMaterial: function(t) {
                    return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
                },
                getContactMaterial: function(t, e) {
                    return this.world.getContactMaterial(t, e)
                },
                setMaterial: function(t, e) {
                    for (var i = e.length; i--;) e[i].setMaterial(t)
                },
                createMaterial: function(t, e) {
                    t = t || "";
                    t = new X.Physics.P2.Material(t);
                    return this.materials.push(t), void 0 !== e && e.setMaterial(t), t
                },
                createContactMaterial: function(t, e, i) {
                    void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial());
                    i = new X.Physics.P2.ContactMaterial(t, e, i);
                    return this.addContactMaterial(i)
                },
                getBodies: function() {
                    for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                    return t
                },
                getBody: function(t) {
                    return t instanceof p2.Body ? t : t instanceof X.Physics.P2.Body ? t.data : t.body && t.body.type === X.Physics.P2JS ? t.body.data : null
                },
                getSprings: function() {
                    for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                    return t
                },
                getConstraints: function() {
                    for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                    return t
                },
                hitTest: function(t, e, i, s) {
                    void 0 === e && (e = this.world.bodies), void 0 === i && (i = 5), void 0 === s && (s = !1);
                    for (var t = [this.pxmi(t.x), this.pxmi(t.y)], n = [], a = e.length; a--;) e[a] instanceof X.Physics.P2.Body && (!s || e[a].data.type !== p2.Body.STATIC) ? n.push(e[a].data) : e[a] instanceof p2.Body && e[a].parent && (!s || e[a].type !== p2.Body.STATIC) ? n.push(e[a]) : e[a] instanceof X.Sprite && e[a].hasOwnProperty("body") && (!s || e[a].body.data.type !== p2.Body.STATIC) && n.push(e[a].body.data);
                    return this.world.hitTest(t, n, i)
                },
                toJSON: function() {
                    return this.world.toJSON()
                },
                createCollisionGroup: function(t) {
                    var e = Math.pow(2, this._collisionGroupID);
                    this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                    e = new X.Physics.P2.CollisionGroup(e);
                    return this.collisionGroups.push(e), t && this.setCollisionGroup(t, e), e
                },
                setCollisionGroup: function(t, e) {
                    if (t instanceof X.Group)
                        for (var i = 0; i < t.total; i++) t.children[i].body && t.children[i].body.type === X.Physics.P2JS && t.children[i].body.setCollisionGroup(e);
                    else t.body.setCollisionGroup(e)
                },
                createSpring: function(t, e, i, s, n, a, o, r, h) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new X.Physics.P2.Spring(this, t, e, i, s, n, a, o, r, h))
                },
                createRotationalSpring: function(t, e, i, s, n) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new X.Physics.P2.RotationalSpring(this, t, e, i, s, n))
                },
                createBody: function(t, e, i, s, n, a) {
                    void 0 === s && (s = !1);
                    i = new X.Physics.P2.Body(this.game, null, t, e, i);
                    return !(a && !i.addPolygon(n, a)) && (s && this.world.addBody(i.data), i)
                },
                createParticle: function(t, e, i, s, n, a) {
                    void 0 === s && (s = !1);
                    i = new X.Physics.P2.Body(this.game, null, t, e, i);
                    return !(a && !i.addPolygon(n, a)) && (s && this.world.addBody(i.data), i)
                },
                convertCollisionObjects: function(t, e, i) {
                    void 0 === i && (i = !0);
                    for (var s = [], n = 0, a = t.collision[e].length; n < a; n++) {
                        var o = t.collision[e][n],
                            o = this.createBody(o.x, o.y, 0, i, {}, o.polyline);
                        o && s.push(o)
                    }
                    return s
                },
                clearTilemapLayerBodies: function(t, e) {
                    e = t.getLayer(e);
                    for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                    t.layers[e].bodies.length = 0
                },
                convertTilemap: function(t, e, i, s) {
                    e = t.getLayer(e), void 0 === i && (i = !0), void 0 === s && (s = !0), this.clearTilemapLayerBodies(t, e);
                    for (var n = 0, a = 0, o = 0, r = 0, h = t.layers[e].height; r < h; r++)
                        for (var l = n = 0, c = t.layers[e].width; l < c; l++) {
                            var u, d, p = t.layers[e].data[r][l];
                            p && -1 < p.index && p.collides && (s ? (u = t.getTileRight(e, l, r), 0 === n && (a = p.x * p.width, o = p.y * p.height, n = p.width), u && u.collides ? n += p.width : ((d = this.createBody(a, o, 0, !1)).addRectangle(n, p.height, n / 2, p.height / 2, 0), i && this.addBody(d), t.layers[e].bodies.push(d), n = 0)) : ((d = this.createBody(p.x * p.width, p.y * p.height, 0, !1)).addRectangle(p.width, p.height, p.width / 2, p.height / 2, 0), i && this.addBody(d), t.layers[e].bodies.push(d)))
                        }
                    return t.layers[e].bodies
                },
                mpx: function(t) {
                    return 20 * t
                },
                pxm: function(t) {
                    return .05 * t
                },
                mpxi: function(t) {
                    return -20 * t
                },
                pxmi: function(t) {
                    return -.05 * t
                }
            }, Object.defineProperty(X.Physics.P2.prototype, "friction", {
                get: function() {
                    return this.world.defaultContactMaterial.friction
                },
                set: function(t) {
                    this.world.defaultContactMaterial.friction = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "restitution", {
                get: function() {
                    return this.world.defaultContactMaterial.restitution
                },
                set: function(t) {
                    this.world.defaultContactMaterial.restitution = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "contactMaterial", {
                get: function() {
                    return this.world.defaultContactMaterial
                },
                set: function(t) {
                    this.world.defaultContactMaterial = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "applySpringForces", {
                get: function() {
                    return this.world.applySpringForces
                },
                set: function(t) {
                    this.world.applySpringForces = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "applyDamping", {
                get: function() {
                    return this.world.applyDamping
                },
                set: function(t) {
                    this.world.applyDamping = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "applyGravity", {
                get: function() {
                    return this.world.applyGravity
                },
                set: function(t) {
                    this.world.applyGravity = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "solveConstraints", {
                get: function() {
                    return this.world.solveConstraints
                },
                set: function(t) {
                    this.world.solveConstraints = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "time", {
                get: function() {
                    return this.world.time
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "emitImpactEvent", {
                get: function() {
                    return this.world.emitImpactEvent
                },
                set: function(t) {
                    this.world.emitImpactEvent = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "sleepMode", {
                get: function() {
                    return this.world.sleepMode
                },
                set: function(t) {
                    this.world.sleepMode = t
                }
            }), Object.defineProperty(X.Physics.P2.prototype, "total", {
                get: function() {
                    return this.world.bodies.length
                }
            }), X.Physics.P2.FixtureList = function(t) {
                Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
            }, X.Physics.P2.FixtureList.prototype = {
                init: function() {
                    this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
                },
                setCategory: function(e, t) {
                    this.getFixtures(t).forEach(function(t) {
                        t.collisionGroup = e
                    })
                },
                setMask: function(e, t) {
                    this.getFixtures(t).forEach(function(t) {
                        t.collisionMask = e
                    })
                },
                setSensor: function(e, t) {
                    this.getFixtures(t).forEach(function(t) {
                        t.sensor = e
                    })
                },
                setMaterial: function(e, t) {
                    this.getFixtures(t).forEach(function(t) {
                        t.material = e
                    })
                },
                getFixtures: function(t) {
                    var e = [];
                    if (t) {
                        t instanceof Array || (t = [t]);
                        var i = this;
                        return t.forEach(function(t) {
                            i.namedFixtures[t] && e.push(i.namedFixtures[t])
                        }), this.flatten(e)
                    }
                    return this.allFixtures
                },
                getFixtureByKey: function(t) {
                    return this.namedFixtures[t]
                },
                getGroup: function(t) {
                    return this.groupedFixtures[t]
                },
                parse: function() {
                    var t, e, i = this.rawList,
                        s = [];
                    for (t in i) e = i[t], isNaN(+t) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), s.push(this.allFixtures = this.flatten(this.groupedFixtures))
                },
                flatten: function(t) {
                    var e = [],
                        i = arguments.callee;
                    return t.forEach(function(t) {
                        return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                    }), e
                }
            }, X.Physics.P2.PointProxy = function(t, e) {
                this.world = t, this.destination = e
            }, X.Physics.P2.PointProxy.prototype.constructor = X.Physics.P2.PointProxy, Object.defineProperty(X.Physics.P2.PointProxy.prototype, "x", {
                get: function() {
                    return this.world.mpx(this.destination[0])
                },
                set: function(t) {
                    this.destination[0] = this.world.pxm(t)
                }
            }), Object.defineProperty(X.Physics.P2.PointProxy.prototype, "y", {
                get: function() {
                    return this.world.mpx(this.destination[1])
                },
                set: function(t) {
                    this.destination[1] = this.world.pxm(t)
                }
            }), Object.defineProperty(X.Physics.P2.PointProxy.prototype, "mx", {
                get: function() {
                    return this.destination[0]
                },
                set: function(t) {
                    this.destination[0] = t
                }
            }), Object.defineProperty(X.Physics.P2.PointProxy.prototype, "my", {
                get: function() {
                    return this.destination[1]
                },
                set: function(t) {
                    this.destination[1] = t
                }
            }), X.Physics.P2.InversePointProxy = function(t, e) {
                this.world = t, this.destination = e
            }, X.Physics.P2.InversePointProxy.prototype.constructor = X.Physics.P2.InversePointProxy, Object.defineProperty(X.Physics.P2.InversePointProxy.prototype, "x", {
                get: function() {
                    return this.world.mpxi(this.destination[0])
                },
                set: function(t) {
                    this.destination[0] = this.world.pxmi(t)
                }
            }), Object.defineProperty(X.Physics.P2.InversePointProxy.prototype, "y", {
                get: function() {
                    return this.world.mpxi(this.destination[1])
                },
                set: function(t) {
                    this.destination[1] = this.world.pxmi(t)
                }
            }), Object.defineProperty(X.Physics.P2.InversePointProxy.prototype, "mx", {
                get: function() {
                    return this.destination[0]
                },
                set: function(t) {
                    this.destination[0] = -t
                }
            }), Object.defineProperty(X.Physics.P2.InversePointProxy.prototype, "my", {
                get: function() {
                    return this.destination[1]
                },
                set: function(t) {
                    this.destination[1] = -t
                }
            }), X.Physics.P2.Body = function(t, e, i, s, n) {
                e = e || null, i = i || 0, s = s || 0, void 0 === n && (n = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = X.Physics.P2JS, this.offset = new X.Point, this.data = new p2.Body({
                    position: [this.world.pxmi(i), this.world.pxmi(s)],
                    mass: n
                }), (this.data.parent = this).velocity = new X.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new X.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new X.Point, this.onBeginContact = new X.Signal, this.onEndContact = new X.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
            }, X.Physics.P2.Body.prototype = {
                createBodyCallback: function(t, e, i) {
                    var s = -1;
                    t.id ? s = t.id : t.body && (s = t.body.id), -1 < s && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
                },
                createGroupCallback: function(t, e, i) {
                    null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
                },
                getCollisionMask: function() {
                    var t = 0;
                    this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                    for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                    return t
                },
                updateCollisionMask: function(t) {
                    var e = this.getCollisionMask();
                    if (void 0 === t)
                        for (var i = this.data.shapes.length - 1; 0 <= i; i--) this.data.shapes[i].collisionMask = e;
                    else t.collisionMask = e
                },
                setCollisionGroup: function(t, e) {
                    var i = this.getCollisionMask();
                    if (void 0 === e)
                        for (var s = this.data.shapes.length - 1; 0 <= s; s--) this.data.shapes[s].collisionGroup = t.mask, this.data.shapes[s].collisionMask = i;
                    else e.collisionGroup = t.mask, e.collisionMask = i
                },
                clearCollision: function(t, e, i) {
                    if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                        for (var s = this.data.shapes.length - 1; 0 <= s; s--) t && (this.data.shapes[s].collisionGroup = null), e && (this.data.shapes[s].collisionMask = null);
                    else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                    t && (this.collidesWith.length = 0)
                },
                removeCollisionGroup: function(t, e, i) {
                    var s;
                    if (void 0 === e && (e = !0), Array.isArray(t))
                        for (var n = 0; n < t.length; n++) - 1 < (s = this.collidesWith.indexOf(t[n])) && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                    else -1 < (s = this.collidesWith.indexOf(t)) && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                    var a = this.getCollisionMask();
                    if (void 0 === i)
                        for (n = this.data.shapes.length - 1; 0 <= n; n--) this.data.shapes[n].collisionMask = a;
                    else i.collisionMask = a
                },
                collides: function(t, e, i, s) {
                    if (Array.isArray(t))
                        for (var n = 0; n < t.length; n++) - 1 === this.collidesWith.indexOf(t[n]) && (this.collidesWith.push(t[n]), e && this.createGroupCallback(t[n], e, i));
                    else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                    var a = this.getCollisionMask();
                    if (void 0 === s)
                        for (n = this.data.shapes.length - 1; 0 <= n; n--) this.data.shapes[n].collisionMask = a;
                    else s.collisionMask = a
                },
                adjustCenterOfMass: function() {
                    this.data.adjustCenterOfMass(), this.shapeChanged()
                },
                getVelocityAtPoint: function(t, e) {
                    return this.data.getVelocityAtPoint(t, e)
                },
                applyDamping: function(t) {
                    this.data.applyDamping(t)
                },
                applyImpulse: function(t, e, i) {
                    this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                applyImpulseLocal: function(t, e, i) {
                    this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                applyForce: function(t, e, i) {
                    this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                setZeroForce: function() {
                    this.data.setZeroForce()
                },
                setZeroRotation: function() {
                    this.data.angularVelocity = 0
                },
                setZeroVelocity: function() {
                    this.data.velocity[0] = 0, this.data.velocity[1] = 0
                },
                setZeroDamping: function() {
                    this.data.damping = 0, this.data.angularDamping = 0
                },
                toLocalFrame: function(t, e) {
                    return this.data.toLocalFrame(t, e)
                },
                toWorldFrame: function(t, e) {
                    return this.data.toWorldFrame(t, e)
                },
                rotateLeft: function(t) {
                    this.data.angularVelocity = this.world.pxm(-t)
                },
                rotateRight: function(t) {
                    this.data.angularVelocity = this.world.pxm(t)
                },
                moveForward: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle + Math.PI / 2;
                    this.data.velocity[0] = e * Math.cos(t), this.data.velocity[1] = e * Math.sin(t)
                },
                moveBackward: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle + Math.PI / 2;
                    this.data.velocity[0] = -e * Math.cos(t), this.data.velocity[1] = -e * Math.sin(t)
                },
                thrust: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle + Math.PI / 2;
                    this.data.force[0] += e * Math.cos(t), this.data.force[1] += e * Math.sin(t)
                },
                thrustLeft: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle;
                    this.data.force[0] += e * Math.cos(t), this.data.force[1] += e * Math.sin(t)
                },
                thrustRight: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle;
                    this.data.force[0] -= e * Math.cos(t), this.data.force[1] -= e * Math.sin(t)
                },
                reverse: function(t) {
                    var e = this.world.pxmi(-t),
                        t = this.data.angle + Math.PI / 2;
                    this.data.force[0] -= e * Math.cos(t), this.data.force[1] -= e * Math.sin(t)
                },
                moveLeft: function(t) {
                    this.data.velocity[0] = this.world.pxmi(-t)
                },
                moveRight: function(t) {
                    this.data.velocity[0] = this.world.pxmi(t)
                },
                moveUp: function(t) {
                    this.data.velocity[1] = this.world.pxmi(-t)
                },
                moveDown: function(t) {
                    this.data.velocity[1] = this.world.pxmi(t)
                },
                preUpdate: function() {
                    this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
                },
                postUpdate: function() {
                    this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
                },
                reset: function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), s && (this.mass = 1), this.x = t, this.y = e
                },
                addToWorld: function() {
                    if (this.game.physics.p2._toRemove)
                        for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                    this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
                },
                removeFromWorld: function() {
                    this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
                },
                destroy: function() {
                    this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
                },
                clearShapes: function() {
                    for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                    this.shapeChanged()
                },
                addShape: function(t, e, i, s) {
                    return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s), this.shapeChanged(), t
                },
                addCircle: function(t, e, i, s) {
                    t = new p2.Circle({
                        radius: this.world.pxm(t)
                    });
                    return this.addShape(t, e, i, s)
                },
                addRectangle: function(t, e, i, s, n) {
                    e = new p2.Box({
                        width: this.world.pxm(t),
                        height: this.world.pxm(e)
                    });
                    return this.addShape(e, i, s, n)
                },
                addPlane: function(t, e, i) {
                    var s = new p2.Plane;
                    return this.addShape(s, t, e, i)
                },
                addParticle: function(t, e, i) {
                    var s = new p2.Particle;
                    return this.addShape(s, t, e, i)
                },
                addLine: function(t, e, i, s) {
                    t = new p2.Line({
                        length: this.world.pxm(t)
                    });
                    return this.addShape(t, e, i, s)
                },
                addCapsule: function(t, e, i, s, n) {
                    e = new p2.Capsule({
                        length: this.world.pxm(t),
                        radius: this.world.pxm(e)
                    });
                    return this.addShape(e, i, s, n)
                },
                addPolygon: function(t, e) {
                    t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                    var i = [];
                    if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                    else if (Array.isArray(e[0])) i = e.slice();
                    else if ("number" == typeof e[0])
                        for (var s = 0, n = e.length; s < n; s += 2) i.push([e[s], e[s + 1]]);
                    var a = i.length - 1;
                    i[a][0] === i[0][0] && i[a][1] === i[0][1] && i.pop();
                    for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]), i[o][1] = this.world.pxmi(i[o][1]);
                    a = this.data.fromPolygon(i, t);
                    return this.shapeChanged(), a
                },
                removeShape: function(t) {
                    t = this.data.removeShape(t);
                    return this.shapeChanged(), t
                },
                setCircle: function(t, e, i, s) {
                    return this.clearShapes(), this.addCircle(t, e, i, s)
                },
                setRectangle: function(t, e, i, s, n) {
                    return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, s, n)
                },
                setRectangleFromSprite: function(t) {
                    return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
                },
                setMaterial: function(t, e) {
                    if (void 0 === e)
                        for (var i = this.data.shapes.length - 1; 0 <= i; i--) this.data.shapes[i].material = t;
                    else e.material = t
                },
                shapeChanged: function() {
                    this.debugBody && this.debugBody.draw()
                },
                addPhaserPolygon: function(t, e) {
                    for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                        var a = i[n],
                            o = this.addFixture(a);
                        s[a.filter.group] = s[a.filter.group] || [], s[a.filter.group] = s[a.filter.group].concat(o), a.fixtureKey && (s[a.fixtureKey] = o)
                    }
                    return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), s
                },
                addFixture: function(t) {
                    var e = [];
                    if (t.circle) {
                        (l = new p2.Circle({
                            radius: this.world.pxm(t.circle.radius)
                        })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor;
                        var i = p2.vec2.create();
                        i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l)
                    } else
                        for (var s = t.polygons, n = p2.vec2.create(), a = 0; a < s.length; a++) {
                            for (var o = s[a], r = [], h = 0; h < o.length; h += 2) r.push([this.world.pxmi(o[h]), this.world.pxmi(o[h + 1])]);
                            for (var l = new p2.Convex({
                                    vertices: r
                                }), c = 0; c !== l.vertices.length; c++) {
                                var u = l.vertices[c];
                                p2.vec2.sub(u, u, l.centerOfMass)
                            }
                            p2.vec2.scale(n, l.centerOfMass, 1), n[0] -= this.world.pxmi(this.sprite.width / 2), n[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, n), e.push(l)
                        }
                    return e
                },
                loadPolygon: function(t, e) {
                    var i;
                    i = null === t ? e : this.game.cache.getPhysicsData(t, e);
                    for (var s = p2.vec2.create(), n = 0; n < i.length; n++) {
                        for (var a = [], o = 0; o < i[n].shape.length; o += 2) a.push([this.world.pxmi(i[n].shape[o]), this.world.pxmi(i[n].shape[o + 1])]);
                        for (var r = new p2.Convex({
                                vertices: a
                            }), h = 0; h !== r.vertices.length; h++) {
                            var l = r.vertices[h];
                            p2.vec2.sub(l, l, r.centerOfMass)
                        }
                        p2.vec2.scale(s, r.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), r.updateTriangles(), r.updateCenterOfMass(), r.updateBoundingRadius(), this.data.addShape(r, s)
                    }
                    return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
                }
            }, X.Physics.P2.Body.prototype.constructor = X.Physics.P2.Body, X.Physics.P2.Body.DYNAMIC = 1, X.Physics.P2.Body.STATIC = 2, X.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(X.Physics.P2.Body.prototype, "static", {
                get: function() {
                    return this.data.type === X.Physics.P2.Body.STATIC
                },
                set: function(t) {
                    t && this.data.type !== X.Physics.P2.Body.STATIC ? (this.data.type = X.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== X.Physics.P2.Body.STATIC || (this.data.type = X.Physics.P2.Body.DYNAMIC, this.mass = 1)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "dynamic", {
                get: function() {
                    return this.data.type === X.Physics.P2.Body.DYNAMIC
                },
                set: function(t) {
                    t && this.data.type !== X.Physics.P2.Body.DYNAMIC ? (this.data.type = X.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== X.Physics.P2.Body.DYNAMIC || (this.data.type = X.Physics.P2.Body.STATIC, this.mass = 0)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "kinematic", {
                get: function() {
                    return this.data.type === X.Physics.P2.Body.KINEMATIC
                },
                set: function(t) {
                    t && this.data.type !== X.Physics.P2.Body.KINEMATIC ? (this.data.type = X.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== X.Physics.P2.Body.KINEMATIC || (this.data.type = X.Physics.P2.Body.STATIC, this.mass = 0)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "allowSleep", {
                get: function() {
                    return this.data.allowSleep
                },
                set: function(t) {
                    t !== this.data.allowSleep && (this.data.allowSleep = t)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "angle", {
                get: function() {
                    return X.Math.wrapAngle(X.Math.radToDeg(this.data.angle))
                },
                set: function(t) {
                    this.data.angle = X.Math.degToRad(X.Math.wrapAngle(t))
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "angularDamping", {
                get: function() {
                    return this.data.angularDamping
                },
                set: function(t) {
                    this.data.angularDamping = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "angularForce", {
                get: function() {
                    return this.data.angularForce
                },
                set: function(t) {
                    this.data.angularForce = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "angularVelocity", {
                get: function() {
                    return this.data.angularVelocity
                },
                set: function(t) {
                    this.data.angularVelocity = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "damping", {
                get: function() {
                    return this.data.damping
                },
                set: function(t) {
                    this.data.damping = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "fixedRotation", {
                get: function() {
                    return this.data.fixedRotation
                },
                set: function(t) {
                    t !== this.data.fixedRotation && (this.data.fixedRotation = t)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "inertia", {
                get: function() {
                    return this.data.inertia
                },
                set: function(t) {
                    this.data.inertia = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "mass", {
                get: function() {
                    return this.data.mass
                },
                set: function(t) {
                    t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "motionState", {
                get: function() {
                    return this.data.type
                },
                set: function(t) {
                    t !== this.data.type && (this.data.type = t)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "rotation", {
                get: function() {
                    return this.data.angle
                },
                set: function(t) {
                    this.data.angle = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "sleepSpeedLimit", {
                get: function() {
                    return this.data.sleepSpeedLimit
                },
                set: function(t) {
                    this.data.sleepSpeedLimit = t
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "x", {
                get: function() {
                    return this.world.mpxi(this.data.position[0])
                },
                set: function(t) {
                    this.data.position[0] = this.world.pxmi(t)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "y", {
                get: function() {
                    return this.world.mpxi(this.data.position[1])
                },
                set: function(t) {
                    this.data.position[1] = this.world.pxmi(t)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "id", {
                get: function() {
                    return this.data.id
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "debug", {
                get: function() {
                    return null !== this.debugBody
                },
                set: function(t) {
                    t && !this.debugBody ? this.debugBody = new X.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
                }
            }), Object.defineProperty(X.Physics.P2.Body.prototype, "collideWorldBounds", {
                get: function() {
                    return this._collideWorldBounds
                },
                set: function(t) {
                    t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
                }
            }), X.Physics.P2.BodyDebug = function(t, e, i) {
                X.Group.call(this, t);
                var s = {
                    pixelsPerLengthUnit: t.physics.p2.mpx(1),
                    debugPolygons: !1,
                    lineWidth: 1,
                    alpha: .5
                };
                this.settings = X.Utils.extend(s, i), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new X.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
            }, X.Physics.P2.BodyDebug.prototype = Object.create(X.Group.prototype), X.Physics.P2.BodyDebug.prototype.constructor = X.Physics.P2.BodyDebug, X.Utils.extend(X.Physics.P2.BodyDebug.prototype, {
                updateSpriteTransform: function() {
                    this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
                },
                draw: function() {
                    var t, e, i, s, n, a, o, r, h, l, c, u, d = this.body,
                        p = this.canvas;
                    if (p.clear(), i = parseInt(this.randomPastelHex(), 16), n = 16711680, a = this.lineWidth, d instanceof p2.Body && d.shapes.length)
                        for (var f = d.shapes.length, g = 0; g !== f;) {
                            if (o = (e = d.shapes[g]).position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(p, o[0] * this.ppu, o[1] * this.ppu, t, e.radius * this.ppu, i, a);
                            else if (e instanceof p2.Capsule) this.drawCapsule(p, o[0] * this.ppu, o[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, n, i, a);
                            else if (e instanceof p2.Plane) this.drawPlane(p, o[0] * this.ppu, -o[1] * this.ppu, i, n, 5 * a, 10 * a, 10 * a, 100 * this.ppu, t);
                            else if (e instanceof p2.Line) this.drawLine(p, e.length * this.ppu, n, a);
                            else if (e instanceof p2.Box) this.drawRectangle(p, o[0] * this.ppu, o[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, n, i, a);
                            else if (e instanceof p2.Convex) {
                                for (h = [], l = p2.vec2.create(), s = c = 0, u = e.vertices.length; 0 <= u ? c < u : u < c; s = 0 <= u ? ++c : --c) r = e.vertices[s], p2.vec2.rotate(l, r, t), h.push([(l[0] + o[0]) * this.ppu, -(l[1] + o[1]) * this.ppu]);
                                this.drawConvex(p, h, e.triangles, n, i, a, this.settings.debugPolygons, [o[0] * this.ppu, -o[1] * this.ppu])
                            }
                            g++
                        }
                },
                drawRectangle: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1), t.beginFill(r), t.drawRect(e - n / 2, i - a / 2, n, a)
                },
                drawCircle: function(t, e, i, s, n, a, o) {
                    void 0 === o && (o = 1), void 0 === a && (a = 16777215), t.lineStyle(o, 0, 1), t.beginFill(a, 1), t.drawCircle(e, i, 2 * -n), t.endFill(), t.moveTo(e, i), t.lineTo(e + n * Math.cos(-s), i + n * Math.sin(-s))
                },
                drawLine: function(t, e, i, s) {
                    void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(5 * s, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
                },
                drawConvex: function(t, e, i, s, n, a, o, r) {
                    var h, l, c, u, d, p, f, g;
                    if (void 0 === a && (a = 1), void 0 === s && (s = 0), o) {
                        for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) d = e[l % e.length], g = e[(l + 1) % e.length], u = d[0], f = d[1], d = g[0], g = g[1], t.lineStyle(a, h[l % h.length], 1), t.moveTo(u, -f), t.lineTo(d, -g), t.drawCircle(u, -f, 2 * a), l++;
                        return t.lineStyle(a, 0, 1), t.drawCircle(r[0], r[1], 2 * a)
                    }
                    for (t.lineStyle(a, s, 1), t.beginFill(n), l = 0; l !== e.length;) c = (p = e[l])[0], p = p[1], 0 === l ? t.moveTo(c, -p) : t.lineTo(c, -p), l++;
                    if (t.endFill(), 2 < e.length) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
                },
                drawPath: function(t, e, i, s, n) {
                    var a, o, r, h, l, c;
                    for (void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof s && t.beginFill(s), r = o = null, a = 0; a < e.length;) l = (h = e[a])[0], c = h[1], l === o && c === r || (0 === a ? t.moveTo(l, c) : (h = e[(a + 1) % e.length][0], 0 != (l - o) * (e[(a + 1) % e.length][1] - r) - (h - o) * (c - r) && t.lineTo(l, c)), o = l, r = c), a++;
                    "number" == typeof s && t.endFill(), 2 < e.length && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
                },
                drawPlane: function(t, e, i, s, n, a, o, r, h, l) {
                    void 0 === a && (a = 1), void 0 === s && (s = 16777215), t.lineStyle(a, n, 11), t.beginFill(s), t.moveTo(e, -i), s = e + Math.cos(l) * this.game.width, h = i + Math.sin(l) * this.game.height, t.lineTo(s, -h), t.moveTo(e, -i), s = e + Math.cos(l) * -this.game.width, h = i + Math.sin(l) * -this.game.height, t.lineTo(s, -h)
                },
                drawCapsule: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1);
                    var l = Math.cos(s),
                        s = Math.sin(s);
                    t.beginFill(r, 1), t.drawCircle(-n / 2 * l + e, -n / 2 * s + i, 2 * -a), t.drawCircle(n / 2 * l + e, n / 2 * s + i, 2 * -a), t.endFill(), t.lineStyle(h, o, 0), t.beginFill(r, 1), t.moveTo(-n / 2 * l + a * s + e, -n / 2 * s + a * l + i), t.lineTo(n / 2 * l + a * s + e, n / 2 * s + a * l + i), t.lineTo(n / 2 * l - a * s + e, n / 2 * s - a * l + i), t.lineTo(-n / 2 * l - a * s + e, -n / 2 * s - a * l + i), t.endFill(), t.lineStyle(h, o, 1), t.moveTo(-n / 2 * l + a * s + e, -n / 2 * s + a * l + i), t.lineTo(n / 2 * l + a * s + e, n / 2 * s + a * l + i), t.moveTo(-n / 2 * l - a * s + e, -n / 2 * s - a * l + i), t.lineTo(n / 2 * l - a * s + e, n / 2 * s - a * l + i)
                },
                randomPastelHex: function() {
                    var t = [255, 255, 255],
                        e = Math.floor(256 * Math.random()),
                        i = Math.floor(256 * Math.random()),
                        s = Math.floor(256 * Math.random());
                    return e = Math.floor((e + 3 * t[0]) / 4), i = Math.floor((i + 3 * t[1]) / 4), s = Math.floor((s + 3 * t[2]) / 4), this.rgbToHex(e, i, s)
                },
                rgbToHex: function(t, e, i) {
                    return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
                },
                componentToHex: function(t) {
                    t = t.toString(16);
                    return 2 === t.length ? t : t + "0"
                }
            }), X.Physics.P2.Spring = function(t, e, i, s, n, a, o, r, h, l) {
                this.game = t.game, void 0 === s && (s = 1), void 0 === n && (n = 100), void 0 === a && (a = 1);
                a = {
                    restLength: s = (this.world = t).pxm(s),
                    stiffness: n,
                    damping: a
                };
                null != o && (a.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]), null != r && (a.worldAnchorB = [t.pxm(r[0]), t.pxm(r[1])]), null != h && (a.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), null != l && (a.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, a), this.data.parent = this
            }, X.Physics.P2.Spring.prototype.constructor = X.Physics.P2.Spring, X.Physics.P2.RotationalSpring = function(t, e, i, s, n, a) {
                this.game = t.game, this.world = t, void 0 === s && (s = null), void 0 === n && (n = 100), void 0 === a && (a = 1);
                a = {
                    restAngle: s = s && t.pxm(s),
                    stiffness: n,
                    damping: a
                };
                this.data = new p2.RotationalSpring(e, i, a), this.data.parent = this
            }, X.Physics.P2.Spring.prototype.constructor = X.Physics.P2.Spring, X.Physics.P2.Material = function(t) {
                this.name = t, p2.Material.call(this)
            }, X.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), X.Physics.P2.Material.prototype.constructor = X.Physics.P2.Material, X.Physics.P2.ContactMaterial = function(t, e, i) {
                p2.ContactMaterial.call(this, t, e, i)
            }, X.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), X.Physics.P2.ContactMaterial.prototype.constructor = X.Physics.P2.ContactMaterial, X.Physics.P2.CollisionGroup = function(t) {
                this.mask = t
            }, X.Physics.P2.DistanceConstraint = function(t, e, i, s, n, a, o) {
                void 0 === s && (s = 100), void 0 === n && (n = [0, 0]), void 0 === a && (a = [0, 0]), void 0 === o && (o = Number.MAX_VALUE), this.game = t.game;
                o = {
                    distance: s = (this.world = t).pxm(s),
                    localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                    localAnchorB: a = [t.pxmi(a[0]), t.pxmi(a[1])],
                    maxForce: o
                };
                p2.DistanceConstraint.call(this, e, i, o)
            }, X.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), X.Physics.P2.DistanceConstraint.prototype.constructor = X.Physics.P2.DistanceConstraint, X.Physics.P2.GearConstraint = function(t, e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 1), this.game = t.game, this.world = t;
                n = {
                    angle: s,
                    ratio: n
                };
                p2.GearConstraint.call(this, e, i, n)
            }, X.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), X.Physics.P2.GearConstraint.prototype.constructor = X.Physics.P2.GearConstraint, X.Physics.P2.LockConstraint = function(t, e, i, s, n, a) {
                void 0 === s && (s = [0, 0]), void 0 === n && (n = 0), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game;
                a = {
                    localOffsetB: s = [(this.world = t).pxm(s[0]), t.pxm(s[1])],
                    localAngleB: n,
                    maxForce: a
                };
                p2.LockConstraint.call(this, e, i, a)
            }, X.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), X.Physics.P2.LockConstraint.prototype.constructor = X.Physics.P2.LockConstraint, X.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, a, o, r) {
                void 0 === s && (s = !0), void 0 === n && (n = [0, 0]), void 0 === a && (a = [0, 0]), void 0 === o && (o = [0, 0]), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game;
                s = {
                    localAnchorA: n = [(this.world = t).pxmi(n[0]), t.pxmi(n[1])],
                    localAnchorB: a = [t.pxmi(a[0]), t.pxmi(a[1])],
                    localAxisA: o,
                    maxForce: r,
                    disableRotationalLock: !s
                };
                p2.PrismaticConstraint.call(this, e, i, s)
            }, X.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), X.Physics.P2.PrismaticConstraint.prototype.constructor = X.Physics.P2.PrismaticConstraint, X.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, a, o) {
                void 0 === a && (a = Number.MAX_VALUE), void 0 === o && (o = null), this.game = t.game, i = [(this.world = t).pxmi(i[0]), t.pxmi(i[1])], n = [t.pxmi(n[0]), t.pxmi(n[1])];
                a = {
                    worldPivot: o = o && [t.pxmi(o[0]), t.pxmi(o[1])],
                    localPivotA: i,
                    localPivotB: n,
                    maxForce: a
                };
                p2.RevoluteConstraint.call(this, e, s, a)
            }, X.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), X.Physics.P2.RevoluteConstraint.prototype.constructor = X.Physics.P2.RevoluteConstraint, X.ImageCollection = function(t, e, i, s, n, a, o) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === a && (a = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | n, this.imageSpacing = 0 | a, this.properties = o || {}, this.images = [], this.total = 0
            }, X.ImageCollection.prototype = {
                containsImageIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                addImage: function(t, e) {
                    this.images.push({
                        gid: t,
                        image: e
                    }), this.total++
                }
            }, X.ImageCollection.prototype.constructor = X.ImageCollection, X.Tile = function(t, e, i, s, n, a) {
                this.layer = t, this.index = e, this.x = i, this.y = s, this.rotation = 0, this.flipped = !1, this.worldX = i * n, this.worldY = s * a, this.width = n, this.height = a, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(a / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
            }, X.Tile.prototype = {
                containsPoint: function(t, e) {
                    return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
                },
                intersects: function(t, e, i, s) {
                    return !(i <= this.worldX || s <= this.worldY || t >= this.worldX + this.width || e >= this.worldY + this.height)
                },
                setCollisionCallback: function(t, e) {
                    this.collisionCallback = t, this.collisionCallbackContext = e
                },
                destroy: function() {
                    this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
                },
                setCollision: function(t, e, i, s) {
                    this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s
                },
                resetCollision: function() {
                    this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
                },
                isInteresting: function(t, e) {
                    return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
                },
                copy: function(t) {
                    this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
                }
            }, X.Tile.prototype.constructor = X.Tile, Object.defineProperty(X.Tile.prototype, "collides", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
                }
            }), Object.defineProperty(X.Tile.prototype, "canCollide", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
                }
            }), Object.defineProperty(X.Tile.prototype, "left", {
                get: function() {
                    return this.worldX
                }
            }), Object.defineProperty(X.Tile.prototype, "right", {
                get: function() {
                    return this.worldX + this.width
                }
            }), Object.defineProperty(X.Tile.prototype, "top", {
                get: function() {
                    return this.worldY
                }
            }), Object.defineProperty(X.Tile.prototype, "bottom", {
                get: function() {
                    return this.worldY + this.height
                }
            }), X.Tilemap = function(t, e, i, s, n, a) {
                this.game = t, this.key = e;
                a = X.TilemapParser.parse(this.game, e, i, s, n, a);
                null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
            }, X.Tilemap.CSV = 0, X.Tilemap.TILED_JSON = 1, X.Tilemap.NORTH = 0, X.Tilemap.EAST = 1, X.Tilemap.SOUTH = 2, X.Tilemap.WEST = 3, X.Tilemap.prototype = {
                create: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = this.game.world), this.width = e, this.height = i, this.setTileSize(s, n), this.layers.length = 0, this.createBlankLayer(t, e, i, s, n, a)
                },
                setTileSize: function(t, e) {
                    this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
                },
                addTilesetImage: function(t, e, i, s, n, a, o) {
                    if (void 0 === t) return null;
                    void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === o && (o = 0), 0 === i && (i = 32), 0 === s && (s = 32);
                    var r = null;
                    if (null != e || (e = t), e instanceof X.BitmapData) r = e.canvas;
                    else {
                        if (!this.game.cache.checkImageKey(e)) return null;
                        r = this.game.cache.getImage(e)
                    }
                    e = this.getTilesetIndex(t);
                    if (null === e && this.format === X.Tilemap.TILED_JSON) return null;
                    if (this.tilesets[e]) return this.tilesets[e].setImage(r), this.tilesets[e];
                    var h = new X.Tileset(t, o, i, s, n, a, {});
                    h.setImage(r), this.tilesets.push(h);
                    for (var l = this.tilesets.length - 1, c = n, u = n, d = 0, p = 0, f = 0, g = o; g < o + h.total && (this.tiles[g] = [c, u, l], c += i + a, ++d !== h.total) && (++p !== h.columns || (c = n, u += s + a, p = 0, ++f !== h.rows)); g++);
                    return h
                },
                createFromObjects: function(t, e, i, s, n, a, o, r, h) {
                    if (void 0 === n && (n = !0), void 0 === a && (a = !1), void 0 === o && (o = this.game.world), void 0 === r && (r = X.Sprite), void 0 === h && (h = !0), this.objects[t])
                        for (var l = 0; l < this.objects[t].length; l++) {
                            var c = !1,
                                u = this.objects[t][l];
                            if ((void 0 !== u.gid && "number" == typeof e && u.gid === e || void 0 !== u.id && "number" == typeof e && u.id === e || void 0 !== u.name && "string" == typeof e && u.name === e) && (c = !0), c) {
                                var d, p = new r(this.game, parseFloat(u.x, 10), parseFloat(u.y, 10), i, s);
                                for (d in p.name = u.name, p.visible = u.visible, p.autoCull = a, p.exists = n, u.width && (p.width = u.width), u.height && (p.height = u.height), u.rotation && (p.angle = u.rotation), h && (p.y -= p.height), o.add(p), u.properties) o.set(p, d, u.properties[d], !1, !1, 0, !0)
                            }
                        }
                },
                createFromTiles: function(t, e, i, s, n, a) {
                    "number" == typeof t && (t = [t]), null == e ? e = [] : "number" == typeof e && (e = [e]), s = this.getLayer(s), void 0 === n && (n = this.game.world), void 0 === a && (a = {}), void 0 === a.customClass && (a.customClass = X.Sprite), void 0 === a.adjustY && (a.adjustY = !0);
                    var o = this.layers[s].width,
                        r = this.layers[s].height;
                    if (this.copy(0, 0, o, r, s), this._results.length < 2) return 0;
                    for (var h, l = 0, c = 1, u = this._results.length; c < u; c++)
                        if (-1 !== t.indexOf(this._results[c].index)) {
                            for (var d in h = new a.customClass(this.game, this._results[c].worldX, this._results[c].worldY, i), a) h[d] = a[d];
                            n.add(h), l++
                        }
                    if (1 === e.length)
                        for (c = 0; c < t.length; c++) this.replace(t[c], e[0], 0, 0, o, r, s);
                    else if (1 < e.length)
                        for (c = 0; c < t.length; c++) this.replace(t[c], e[c], 0, 0, o, r, s);
                    return l
                },
                createLayer: function(t, e, i, s) {
                    void 0 === e && (e = this.game.width), void 0 === i && (i = this.game.height), void 0 === s && (s = this.game.world);
                    var n = t;
                    if ("string" == typeof t && (n = this.getLayerIndex(t)), !(null === n || n > this.layers.length)) {
                        void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === i || i <= 0 ? i = Math.min(this.game.height, this.layers[n].heightInPixels) : i > this.game.height && (i = this.game.height), this.enableDebug;
                        i = s.add(new X.TilemapLayer(this.game, this, n, e, i));
                        return this.enableDebug, i
                    }
                },
                createBlankLayer: function(t, e, i, s, n, a) {
                    if (void 0 === a && (a = this.game.world), null === this.getLayerIndex(t)) {
                        for (var o, r = {
                                name: t,
                                x: 0,
                                y: 0,
                                width: e,
                                height: i,
                                widthInPixels: e * s,
                                heightInPixels: i * n,
                                alpha: 1,
                                visible: !0,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: [],
                                data: null
                            }, h = [], l = 0; l < i; l++) {
                            o = [];
                            for (var c = 0; c < e; c++) o.push(new X.Tile(r, -1, c, l, s, n));
                            h.push(o)
                        }
                        r.data = h, this.layers.push(r), this.currentLayer = this.layers.length - 1;
                        var u = r.widthInPixels,
                            d = r.heightInPixels;
                        return u > this.game.width && (u = this.game.width), d > this.game.height && (d = this.game.height), (h = new X.TilemapLayer(this.game, this, this.layers.length - 1, u, d)).name = t, a.add(h)
                    }
                },
                getIndex: function(t, e) {
                    for (var i = 0; i < t.length; i++)
                        if (t[i].name === e) return i;
                    return null
                },
                getLayerIndex: function(t) {
                    return this.getIndex(this.layers, t)
                },
                getTilesetIndex: function(t) {
                    return this.getIndex(this.tilesets, t)
                },
                getImageIndex: function(t) {
                    return this.getIndex(this.images, t)
                },
                setTileIndexCallback: function(t, e, i, s) {
                    if (s = this.getLayer(s), "number" == typeof t) this.layers[s].callbacks[t] = {
                        callback: e,
                        callbackContext: i
                    };
                    else
                        for (var n = 0, a = t.length; n < a; n++) this.layers[s].callbacks[t[n]] = {
                            callback: e,
                            callbackContext: i
                        }
                },
                setTileLocationCallback: function(t, e, i, s, n, a, o) {
                    if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2))
                        for (var r = 1; r < this._results.length; r++) this._results[r].setCollisionCallback(n, a)
                },
                setCollision: function(t, e, i, s) {
                    if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                    if (Array.isArray(t)) {
                        for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                        s && this.calculateFaces(i)
                    }
                },
                setCollisionBetween: function(t, e, i, s, n) {
                    if (void 0 === i && (i = !0), void 0 === n && (n = !0), s = this.getLayer(s), !(e < t)) {
                        for (var a = t; a <= e; a++) this.setCollisionByIndex(a, i, s, !1);
                        n && this.calculateFaces(s)
                    }
                },
                setCollisionByExclusion: function(t, e, i, s) {
                    void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i);
                    for (var n = 0, a = this.tiles.length; n < a; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                    s && this.calculateFaces(i)
                },
                setCollisionByIndex: function(t, e, i, s) {
                    var n;
                    void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e ? this.collideIndexes.push(t) : -1 < (n = this.collideIndexes.indexOf(t)) && this.collideIndexes.splice(n, 1);
                    for (var a = 0; a < this.layers[i].height; a++)
                        for (var o = 0; o < this.layers[i].width; o++) {
                            var r = this.layers[i].data[a][o];
                            r && r.index === t && (e ? r.setCollision(!0, !0, !0, !0) : r.resetCollision(), r.faceTop = e, r.faceBottom = e, r.faceLeft = e, r.faceRight = e)
                        }
                    return s && this.calculateFaces(i), i
                },
                getLayer: function(t) {
                    return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof X.TilemapLayer && (t = t.index), t
                },
                setPreventRecalculate: function(t) {
                    if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                        for (var e in this.preventingRecalculate = !1, this.needToRecalculate) this.calculateFaces(e);
                        this.needToRecalculate = !1
                    }
                },
                calculateFaces: function(t) {
                    if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                    else
                        for (var e, i, s, n, a = 0, o = this.layers[t].height; a < o; a++)
                            for (var r = 0, h = this.layers[t].width; r < h; r++) {
                                var l = this.layers[t].data[a][r];
                                l && (e = this.getTileAbove(t, r, a), i = this.getTileBelow(t, r, a), s = this.getTileLeft(t, r, a), n = this.getTileRight(t, r, a), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
                            }
                },
                getTileAbove: function(t, e, i) {
                    return 0 < i ? this.layers[t].data[i - 1][e] : null
                },
                getTileBelow: function(t, e, i) {
                    return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
                },
                getTileLeft: function(t, e, i) {
                    return 0 < e ? this.layers[t].data[i][e - 1] : null
                },
                getTileRight: function(t, e, i) {
                    return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
                },
                setLayer: function(t) {
                    t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
                },
                hasTile: function(t, e, i) {
                    return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && -1 < this.layers[i].data[e][t].index
                },
                removeTile: function(t, e, i) {
                    if (i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height && this.hasTile(t, e, i)) {
                        var s = this.layers[i].data[e][t];
                        return this.layers[i].data[e][t] = new X.Tile(this.layers[i], -1, t, e, this.tileWidth, this.tileHeight), this.layers[i].dirty = !0, this.calculateFaces(i), s
                    }
                },
                removeTileWorldXY: function(t, e, i, s, n) {
                    return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, n)
                },
                putTile: function(t, e, i, s) {
                    return null === t ? this.removeTile(e, i, s) : (s = this.getLayer(s), 0 <= e && e < this.layers[s].width && 0 <= i && i < this.layers[s].height ? (t instanceof X.Tile ? (n = t.index, this.hasTile(e, i, s) ? this.layers[s].data[i][e].copy(t) : this.layers[s].data[i][e] = new X.Tile(s, n, e, i, t.width, t.height)) : (n = t, this.hasTile(e, i, s) ? this.layers[s].data[i][e].index = n : this.layers[s].data[i][e] = new X.Tile(this.layers[s], n, e, i, this.tileWidth, this.tileHeight)), -1 < this.collideIndexes.indexOf(n) ? this.layers[s].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[i][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[i][e]) : null);
                    var n
                },
                putTileWorldXY: function(t, e, i, s, n, a) {
                    return a = this.getLayer(a), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, a)
                },
                searchTileIndex: function(t, e, i, s) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), s = this.getLayer(s);
                    var n = 0;
                    if (i) {
                        for (var a = this.layers[s].height - 1; 0 <= a; a--)
                            for (var o = this.layers[s].width - 1; 0 <= o; o--)
                                if (this.layers[s].data[a][o].index === t) {
                                    if (n === e) return this.layers[s].data[a][o];
                                    n++
                                }
                    } else
                        for (a = 0; a < this.layers[s].height; a++)
                            for (o = 0; o < this.layers[s].width; o++)
                                if (this.layers[s].data[a][o].index === t) {
                                    if (n === e) return this.layers[s].data[a][o];
                                    n++
                                } return null
                },
                getTile: function(t, e, i, s) {
                    return void 0 === s && (s = !1), i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height && (-1 !== this.layers[i].data[e][t].index || s) ? this.layers[i].data[e][t] : null
                },
                getTileWorldXY: function(t, e, i, s, n, a) {
                    return void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, n, a)
                },
                copy: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), this.layers[n]) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[n].width), void 0 === s && (s = this.layers[n].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), s > this.layers[n].height && (s = this.layers[n].height), this._results.length = 0, this._results.push({
                            x: t,
                            y: e,
                            width: i,
                            height: s,
                            layer: n
                        });
                        for (var a = e; a < e + s; a++)
                            for (var o = t; o < t + i; o++) this._results.push(this.layers[n].data[a][o]);
                        return this._results
                    }
                    this._results.length = 0
                },
                paste: function(t, e, i, s) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                        for (var n = t - i[1].x, a = e - i[1].y, o = 1; o < i.length; o++) this.layers[s].data[a + i[o].y][n + i[o].x].copy(i[o]);
                        this.layers[s].dirty = !0, this.calculateFaces(s)
                    }
                },
                swap: function(t, e, i, s, n, a, o) {
                    o = this.getLayer(o), this.copy(i, s, n, a, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
                },
                swapHandler: function(t) {
                    t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
                },
                forEach: function(t, e, i, s, n, a, o) {
                    o = this.getLayer(o), this.copy(i, s, n, a, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
                },
                replace: function(t, e, i, s, n, a, o) {
                    if (o = this.getLayer(o), this.copy(i, s, n, a, o), !(this._results.length < 2)) {
                        for (var r = 1; r < this._results.length; r++) this._results[r].index === t && (this._results[r].index = e);
                        this.paste(i, s, this._results, o)
                    }
                },
                random: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                        for (var a, o = [], r = 1; r < this._results.length; r++) this._results[r].index && (a = this._results[r].index, -1 === o.indexOf(a) && o.push(a));
                        for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(o);
                        this.paste(t, e, this._results, n)
                    }
                },
                shuffle: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                        for (var a = [], o = 1; o < this._results.length; o++) this._results[o].index && a.push(this._results[o].index);
                        X.ArrayUtils.shuffle(a);
                        for (var r = 1; r < this._results.length; r++) this._results[r].index = a[r - 1];
                        this.paste(t, e, this._results, n)
                    }
                },
                fill: function(t, e, i, s, n, a) {
                    if (a = this.getLayer(a), this.copy(e, i, s, n, a), !(this._results.length < 2)) {
                        for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                        this.paste(e, i, this._results, a)
                    }
                },
                removeAllLayers: function() {
                    this.layers.length = 0, this.currentLayer = 0
                },
                dump: function() {
                    for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                        for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", 1 < this.layers[this.currentLayer].data[i][s] ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                        t += "\n"
                    }
                    e[0] = t
                },
                destroy: function() {
                    this.removeAllLayers(), this.data = [], this.game = null
                }
            }, X.Tilemap.prototype.constructor = X.Tilemap, Object.defineProperty(X.Tilemap.prototype, "layer", {
                get: function() {
                    return this.layers[this.currentLayer]
                },
                set: function(t) {
                    t !== this.currentLayer && this.setLayer(t)
                }
            }), X.TilemapLayer = function(t, e, i, s, n) {
                s |= 0, n |= 0, X.Sprite.call(this, t, 0, 0), this.map = e, this.index = i, this.layer = e.layers[i], this.canvas = PIXI.CanvasPool.create(this, s, n), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = X.TILEMAPLAYER, this.physicsType = X.TILEMAPLAYER, this.renderSettings = {
                    enableScrollDelta: !1,
                    overdrawRatio: .2,
                    copyCanvas: null
                }, this.debug = !1, this.exists = !0, this.debugSettings = {
                    missingImageFill: "rgb(255,255,255)",
                    debuggedTileOverfill: "rgba(0,255,0,0.4)",
                    forceFullRedraw: !0,
                    debugAlpha: .5,
                    facingEdgeStroke: "rgba(0,255,0,1)",
                    collidingTileOverfill: "rgba(0,255,0,0.2)"
                }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                    scrollX: 0,
                    scrollY: 0,
                    renderWidth: 0,
                    renderHeight: 0,
                    tileWidth: e.tileWidth,
                    tileHeight: e.tileHeight,
                    cw: e.tileWidth,
                    ch: e.tileHeight,
                    tilesets: []
                }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = X.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
            }, X.TilemapLayer.prototype = Object.create(X.Sprite.prototype), X.TilemapLayer.prototype.constructor = X.TilemapLayer, X.TilemapLayer.prototype.preUpdateCore = X.Component.Core.preUpdate, X.TilemapLayer.sharedCopyCanvas = null, X.TilemapLayer.ensureSharedCopyCanvas = function() {
                return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
            }, X.TilemapLayer.prototype.preUpdate = function() {
                return this.preUpdateCore()
            }, X.TilemapLayer.prototype.postUpdate = function() {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
            }, X.TilemapLayer.prototype._renderCanvas = function(t) {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
            }, X.TilemapLayer.prototype._renderWebGL = function(t) {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
            }, X.TilemapLayer.prototype.destroy = function() {
                PIXI.CanvasPool.remove(this), X.Component.Destroy.prototype.destroy.call(this)
            }, X.TilemapLayer.prototype.resize = function(t, e) {
                this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
            }, X.TilemapLayer.prototype.resizeWorld = function() {
                this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
            }, X.TilemapLayer.prototype._fixX = function(t) {
                return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
            }, X.TilemapLayer.prototype._unfixX = function(t) {
                return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
            }, X.TilemapLayer.prototype._fixY = function(t) {
                return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
            }, X.TilemapLayer.prototype._unfixY = function(t) {
                return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
            }, X.TilemapLayer.prototype.getTileX = function(t) {
                return Math.floor(this._fixX(t) / this._mc.tileWidth)
            }, X.TilemapLayer.prototype.getTileY = function(t) {
                return Math.floor(this._fixY(t) / this._mc.tileHeight)
            }, X.TilemapLayer.prototype.getTileXY = function(t, e, i) {
                return i.x = this.getTileX(t), i.y = this.getTileY(e), i
            }, X.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
                e = e || this.rayStepRate, void 0 === i && (i = !1), void 0 === s && (s = !1);
                var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
                if (0 === n.length) return [];
                for (var a = t.coordinatesOnLine(e), o = [], r = 0; r < n.length; r++)
                    for (var h = 0; h < a.length; h++) {
                        var l = n[r],
                            c = a[h];
                        if (l.containsPoint(c[0], c[1])) {
                            o.push(l);
                            break
                        }
                    }
                return o
            }, X.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, a) {
                void 0 === n && (n = !1), void 0 === a && (a = !1);
                var o = !(n || a);
                t = this._fixX(t), e = this._fixY(e);
                for (var r = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - r, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
                for (var u = h; u < h + c; u++)
                    for (var d = r; d < r + l; d++) {
                        var p = this.layer.data[u];
                        p && p[d] && (o || p[d].isInteresting(n, a)) && this._results.push(p[d])
                    }
                return this._results.slice()
            }, X.TilemapLayer.prototype.resolveTileset = function(t) {
                var e = this._mc.tilesets;
                if (t < 2e3)
                    for (; e.length < t;) e.push(void 0);
                var i = this.map.tiles[t] && this.map.tiles[t][2];
                if (null !== i) {
                    i = this.map.tilesets[i];
                    if (i && i.containsTileIndex(t)) return e[t] = i
                }
                return e[t] = null
            }, X.TilemapLayer.prototype.resetTilesetCache = function() {
                for (var t = this._mc.tilesets; t.length;) t.pop()
            }, X.TilemapLayer.prototype.setScale = function(t, e) {
                t = t || 1, e = e || t;
                for (var i = 0; i < this.layer.data.length; i++)
                    for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
                        var a = s[n];
                        a.width = this.map.tileWidth * t, a.height = this.map.tileHeight * e, a.worldX = a.x * a.width, a.worldY = a.y * a.height
                    }
                this.scale.setTo(t, e)
            }, X.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
                var s = t.canvas,
                    n = s.width - Math.abs(e),
                    a = s.height - Math.abs(i),
                    o = 0,
                    r = 0,
                    h = e,
                    l = i;
                e < 0 && (o = -e, h = 0), i < 0 && (r = -i, l = 0);
                e = this.renderSettings.copyCanvas;
                e ? ((e.width < n || e.height < a) && (e.width = n, e.height = a), (i = e.getContext("2d")).clearRect(0, 0, n, a), i.drawImage(s, o, r, n, a, 0, 0, n, a), t.clearRect(h, l, n, a), t.drawImage(e, 0, 0, n, a, h, l, n, a)) : (t.save(), t.globalCompositeOperation = "copy", t.drawImage(s, o, r, n, a, h, l, n, a), t.restore())
            }, X.TilemapLayer.prototype.renderRegion = function(t, e, i, s, n, a) {
                var o = this.context,
                    r = this.layer.width,
                    h = this.layer.height,
                    l = this._mc.tileWidth,
                    c = this._mc.tileHeight,
                    u = this._mc.tilesets,
                    d = NaN;
                this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(r - 1, n)), s <= a && (s = Math.max(0, s), a = Math.min(h - 1, a)));
                for (var p = i * l - t, f = (i + (1 << 20) * r) % r, g = (s + (1 << 20) * h) % h, m = a - s, y = s * c - e; 0 <= m; g++, m--, y += c) {
                    h <= g && (g -= h);
                    for (var b = this.layer.data[g], v = f, _ = n - i, x = p; 0 <= _; v++, _--, x += l) {
                        r <= v && (v -= r);
                        var w, P, T = b[v];
                        !T || T.index < 0 || (void 0 === (P = u[w = T.index]) && (P = this.resolveTileset(w)), T.alpha === d || this.debug || (o.globalAlpha = T.alpha, d = T.alpha), P ? T.rotation || T.flipped ? (o.save(), o.translate(x + T.centerX, y + T.centerY), o.rotate(T.rotation), T.flipped && o.scale(-1, 1), P.draw(o, -T.centerX, -T.centerY, w), o.restore()) : P.draw(o, x, y, w) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(x, y, l, c)), T.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(x, y, l, c)))
                    }
                }
            }, X.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
                var i = this._mc.scrollX,
                    s = this._mc.scrollY,
                    n = this.canvas.width,
                    a = this.canvas.height,
                    o = this._mc.tileWidth,
                    r = this._mc.tileHeight,
                    h = 0,
                    l = -o,
                    c = 0,
                    u = -r;
                t < 0 ? (h = n + t, l = n - 1) : 0 < t && (l = t), e < 0 ? (c = a + e, u = a - 1) : 0 < e && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + s) / r), u = Math.floor((u + s) / r), h <= l && (this.context.clearRect(h * o - i, 0, (l - h + 1) * o, a), e = Math.floor((0 + s) / r), a = Math.floor((a - 1 + s) / r), this.renderRegion(i, s, h, e, l, a)), c <= u && (this.context.clearRect(0, c * r - s, n, (u - c + 1) * r), r = Math.floor((0 + i) / o), o = Math.floor((n - 1 + i) / o), this.renderRegion(i, s, r, c, o, u))
            }, X.TilemapLayer.prototype.renderFull = function() {
                var t = this._mc.scrollX,
                    e = this._mc.scrollY,
                    i = this.canvas.width,
                    s = this.canvas.height,
                    n = this._mc.tileWidth,
                    a = this._mc.tileHeight,
                    o = Math.floor(t / n),
                    r = Math.floor((i - 1 + t) / n),
                    n = Math.floor(e / a),
                    a = Math.floor((s - 1 + e) / a);
                this.context.clearRect(0, 0, i, s), this.renderRegion(t, e, o, n, r, a)
            }, X.TilemapLayer.prototype.render = function() {
                var t = !1;
                if (this.visible) {
                    (this.dirty || this.layer.dirty) && (t = !(this.layer.dirty = !1));
                    var e = this.canvas.width,
                        i = this.canvas.height,
                        s = 0 | this._scrollX,
                        n = 0 | this._scrollY,
                        a = this._mc,
                        o = a.scrollX - s,
                        r = a.scrollY - n;
                    if (t || 0 != o || 0 != r || a.renderWidth !== e || a.renderHeight !== i) return this.context.save(), a.scrollX = s, a.scrollY = n, a.renderWidth === e && a.renderHeight === i || (a.renderWidth = e, a.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(r) < Math.min(e, i) ? this.renderDeltaScroll(o, r) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
                }
            }, X.TilemapLayer.prototype.renderDebug = function() {
                var t, e, i, s = this._mc.scrollX,
                    n = this._mc.scrollY,
                    a = this.context,
                    o = this.canvas.width,
                    r = this.canvas.height,
                    h = this.layer.width,
                    l = this.layer.height,
                    c = this._mc.tileWidth,
                    u = this._mc.tileHeight,
                    d = Math.floor(s / c),
                    p = Math.floor((o - 1 + s) / c),
                    o = Math.floor(n / u),
                    r = Math.floor((r - 1 + n) / u),
                    f = d * c - s,
                    s = o * u - n,
                    g = (d + (1 << 20) * h) % h,
                    n = (o + (1 << 20) * l) % l;
                for (a.strokeStyle = this.debugSettings.facingEdgeStroke, e = n, i = r - o, t = s; 0 <= i; e++, i--, t += u) {
                    l <= e && (e -= l);
                    for (var m = this.layer.data[e], y = g, b = p - d, v = f; 0 <= b; y++, b--, v += c) {
                        h <= y && (y -= h);
                        var _ = m[y];
                        !_ || _.index < 0 || !_.collides || (this.debugSettings.collidingTileOverfill && (a.fillStyle = this.debugSettings.collidingTileOverfill, a.fillRect(v, t, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (a.beginPath(), _.faceTop && (a.moveTo(v, t), a.lineTo(v + this._mc.cw, t)), _.faceBottom && (a.moveTo(v, t + this._mc.ch), a.lineTo(v + this._mc.cw, t + this._mc.ch)), _.faceLeft && (a.moveTo(v, t), a.lineTo(v, t + this._mc.ch)), _.faceRight && (a.moveTo(v + this._mc.cw, t), a.lineTo(v + this._mc.cw, t + this._mc.ch)), a.closePath(), a.stroke()))
                    }
                }
            }, Object.defineProperty(X.TilemapLayer.prototype, "wrap", {
                get: function() {
                    return this._wrap
                },
                set: function(t) {
                    this._wrap = t, this.dirty = !0
                }
            }), Object.defineProperty(X.TilemapLayer.prototype, "scrollX", {
                get: function() {
                    return this._scrollX
                },
                set: function(t) {
                    this._scrollX = t
                }
            }), Object.defineProperty(X.TilemapLayer.prototype, "scrollY", {
                get: function() {
                    return this._scrollY
                },
                set: function(t) {
                    this._scrollY = t
                }
            }), Object.defineProperty(X.TilemapLayer.prototype, "collisionWidth", {
                get: function() {
                    return this._mc.cw
                },
                set: function(t) {
                    this._mc.cw = 0 | t, this.dirty = !0
                }
            }), Object.defineProperty(X.TilemapLayer.prototype, "collisionHeight", {
                get: function() {
                    return this._mc.ch
                },
                set: function(t) {
                    this._mc.ch = 0 | t, this.dirty = !0
                }
            }), X.TilemapParser = {
                INSERT_NULL: !1,
                parse: function(t, e, i, s, n, a) {
                    if (void 0 === i && (i = 32), void 0 === s && (s = 32), void 0 === n && (n = 10), void 0 === a && (a = 10), void 0 === e) return this.getEmptyData();
                    if (null === e) return this.getEmptyData(i, s, n, a);
                    t = t.cache.getTilemapData(e);
                    return t ? t.format === X.Tilemap.CSV ? this.parseCSV(e, t.data, i, s) : t.format && t.format !== X.Tilemap.TILED_JSON ? void 0 : this.parseTiledJSON(t.data) : void 0
                },
                parseCSV: function(t, e, i, s) {
                    for (var n = this.getEmptyData(), a = [], o = (e = e.trim()).split("\n"), e = o.length, r = 0, h = 0; h < o.length; h++) {
                        a[h] = [];
                        for (var l = o[h].split(","), c = 0; c < l.length; c++) a[h][c] = new X.Tile(n.layers[0], parseInt(l[c], 10), c, h, i, s);
                        0 === r && (r = l.length)
                    }
                    return n.format = X.Tilemap.CSV, n.name = t, n.width = r, n.height = e, n.tileWidth = i, n.tileHeight = s, n.widthInPixels = r * i, n.heightInPixels = e * s, n.layers[0].width = r, n.layers[0].height = e, n.layers[0].widthInPixels = n.widthInPixels, n.layers[0].heightInPixels = n.heightInPixels, n.layers[0].data = a, n
                },
                getEmptyData: function(t, e, i, s) {
                    return {
                        width: null != i ? i : 0,
                        height: null != s ? s : 0,
                        tileWidth: null != t ? t : 0,
                        tileHeight: null != e ? e : 0,
                        orientation: "orthogonal",
                        version: "1",
                        properties: {},
                        widthInPixels: 0,
                        heightInPixels: 0,
                        layers: [{
                            name: "layer",
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            widthInPixels: 0,
                            heightInPixels: 0,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: []
                        }],
                        images: [],
                        objects: {},
                        collision: {},
                        tilesets: [],
                        tiles: []
                    }
                },
                parseTiledJSON: function(t) {
                    function e(t, e) {
                        var i, s = {};
                        for (i in e) {
                            var n = e[i];
                            void 0 !== t[n] && (s[n] = t[n])
                        }
                        return s
                    }
                    if ("orthogonal" !== t.orientation) return null;
                    for (var i = {
                            width: t.width,
                            height: t.height,
                            tileWidth: t.tilewidth,
                            tileHeight: t.tileheight,
                            orientation: t.orientation,
                            format: X.Tilemap.TILED_JSON,
                            version: t.version,
                            properties: t.properties,
                            widthInPixels: t.width * t.tilewidth,
                            heightInPixels: t.height * t.tileheight
                        }, s = [], n = 0; n < t.layers.length; n++)
                        if ("tilelayer" === t.layers[n].type) {
                            var a = t.layers[n];
                            if (!a.compression && a.encoding && "base64" === a.encoding) {
                                for (var o = window.atob(a.data), r = o.length, h = new Array(r), l = 0; l < r; l += 4) h[l / 4] = (o.charCodeAt(l) | o.charCodeAt(l + 1) << 8 | o.charCodeAt(l + 2) << 16 | o.charCodeAt(l + 3) << 24) >>> 0;
                                a.data = h, delete a.encoding
                            } else if (a.compression) continue;
                            var c = {
                                name: a.name,
                                x: a.x,
                                y: a.y,
                                width: a.width,
                                height: a.height,
                                widthInPixels: a.width * t.tilewidth,
                                heightInPixels: a.height * t.tileheight,
                                alpha: a.opacity,
                                visible: a.visible,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: []
                            };
                            a.properties && (c.properties = a.properties);
                            for (var u, d, p, f = 0, g = [], m = [], y = 0, r = a.data.length; y < r; y++) {
                                if (d = !1, p = u = 0, 536870912 < (A = a.data[y])) switch (2147483648 < A && (A -= 2147483648, p += 4), 1073741824 < A && (A -= 1073741824, p += 2), 536870912 < A && (A -= 536870912, p += 1), p) {
                                    case 5:
                                        u = Math.PI / 2;
                                        break;
                                    case 6:
                                        u = Math.PI;
                                        break;
                                    case 3:
                                        u = 3 * Math.PI / 2;
                                        break;
                                    case 4:
                                        d = !(u = 0);
                                        break;
                                    case 7:
                                        u = Math.PI / 2, d = !0;
                                        break;
                                    case 2:
                                        u = Math.PI, d = !0;
                                        break;
                                    case 1:
                                        u = 3 * Math.PI / 2, d = !0
                                }
                                0 < A ? ((G = new X.Tile(c, A, f, m.length, t.tilewidth, t.tileheight)).rotation = u, G.flipped = d, 0 !== p && (G.flippedVal = p), g.push(G)) : X.TilemapParser.INSERT_NULL ? g.push(null) : g.push(new X.Tile(c, -1, f, m.length, t.tilewidth, t.tileheight)), ++f === a.width && (m.push(g), f = 0, g = [])
                            }
                            c.data = m, s.push(c)
                        }
                    i.layers = s;
                    for (var b, v = [], n = 0; n < t.layers.length; n++) "imagelayer" === t.layers[n].type && (C = {
                        name: (b = t.layers[n]).name,
                        image: b.image,
                        x: b.x,
                        y: b.y,
                        alpha: b.opacity,
                        visible: b.visible,
                        properties: {}
                    }, b.properties && (C.properties = b.properties), v.push(C));
                    i.images = v;
                    for (var _ = [], x = [], w = null, n = 0; n < t.tilesets.length; n++) {
                        if ((U = t.tilesets[n]).image) {
                            var P = new X.Tileset(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                            U.tileproperties && (P.tileProperties = U.tileproperties), P.updateTileData(U.imagewidth, U.imageheight), _.push(P)
                        } else {
                            var T, S = new X.ImageCollection(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                            for (T in U.tiles) {
                                var C = U.tiles[T].image,
                                    A = U.firstgid + parseInt(T, 10);
                                S.addImage(A, C)
                            }
                            x.push(S)
                        }
                        w && (w.lastgid = U.firstgid - 1), w = U
                    }
                    i.tilesets = _, i.imagecollections = x;
                    for (var E = {}, I = {}, n = 0; n < t.layers.length; n++)
                        if ("objectgroup" === t.layers[n].type) {
                            var B = t.layers[n];
                            E[B.name] = [], I[B.name] = [];
                            for (var M = 0, r = B.objects.length; M < r; M++)
                                if (B.objects[M].gid) {
                                    var k = {
                                        gid: B.objects[M].gid,
                                        name: B.objects[M].name,
                                        type: B.objects[M].hasOwnProperty("type") ? B.objects[M].type : "",
                                        x: B.objects[M].x,
                                        y: B.objects[M].y,
                                        visible: B.objects[M].visible,
                                        properties: B.objects[M].properties
                                    };
                                    B.objects[M].rotation && (k.rotation = B.objects[M].rotation), E[B.name].push(k)
                                } else if (B.objects[M].polyline) {
                                var k = {
                                    name: B.objects[M].name,
                                    type: B.objects[M].type,
                                    x: B.objects[M].x,
                                    y: B.objects[M].y,
                                    width: B.objects[M].width,
                                    height: B.objects[M].height,
                                    visible: B.objects[M].visible,
                                    properties: B.objects[M].properties
                                };
                                B.objects[M].rotation && (k.rotation = B.objects[M].rotation), k.polyline = [];
                                for (var O = 0; O < B.objects[M].polyline.length; O++) k.polyline.push([B.objects[M].polyline[O].x, B.objects[M].polyline[O].y]);
                                I[B.name].push(k), E[B.name].push(k)
                            } else if (B.objects[M].polygon) {
                                (k = e(B.objects[M], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                                for (O = 0; O < B.objects[M].polygon.length; O++) k.polygon.push([B.objects[M].polygon[O].x, B.objects[M].polygon[O].y]);
                                E[B.name].push(k)
                            } else B.objects[M].ellipse ? k = e(B.objects[M], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]) : (k = e(B.objects[M], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, E[B.name].push(k)
                        }
                    i.objects = E, i.collision = I, i.tiles = [];
                    for (n = 0; n < i.tilesets.length; n++)
                        for (var f = (U = i.tilesets[n]).tileMargin, D = U.tileMargin, L = 0, R = 0, F = 0, y = U.firstgid; y < U.firstgid + U.total && (i.tiles[y] = [f, D, n], f += U.tileWidth + U.tileSpacing, ++L !== U.total) && (++R !== U.columns || (f = U.tileMargin, D += U.tileHeight + U.tileSpacing, R = 0, ++F !== U.rows)); y++);
                    for (var G, N, U, n = 0; n < i.layers.length; n++) {
                        c = i.layers[n], U = null;
                        for (l = 0; l < c.data.length; l++) {
                            g = c.data[l];
                            for (var j = 0; j < g.length; j++) null === (G = g[j]) || G.index < 0 || (N = i.tiles[G.index][2], (U = i.tilesets[N]).tileProperties && U.tileProperties[G.index - U.firstgid] && (G.properties = X.Utils.mixin(U.tileProperties[G.index - U.firstgid], G.properties)))
                        }
                    }
                    return i
                }
            }, X.Tileset = function(t, e, i, s, n, a, o) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === a && (a = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | s, this.tileMargin = 0 | n, this.tileSpacing = 0 | a, this.properties = o || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
            }, X.Tileset.prototype = {
                draw: function(t, e, i, s) {
                    s = s - this.firstgid << 1;
                    0 <= s && 1 + s < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[s], this.drawCoords[1 + s], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
                },
                containsTileIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                setImage: function(t) {
                    this.image = t, this.updateTileData(t.width, t.height)
                },
                setSpacing: function(t, e) {
                    this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
                },
                updateTileData: function(t, e) {
                    e = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing), t = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing), e = Math.floor(e), t = Math.floor(t);
                    this.rows && this.rows !== e || this.columns && this.columns, this.rows = e, this.columns = t, this.total = e * t, this.drawCoords.length = 0;
                    for (var i = this.tileMargin, s = this.tileMargin, n = 0; n < this.rows; n++) {
                        for (var a = 0; a < this.columns; a++) this.drawCoords.push(i), this.drawCoords.push(s), i += this.tileWidth + this.tileSpacing;
                        i = this.tileMargin, s += this.tileHeight + this.tileSpacing
                    }
                }
            }, X.Tileset.prototype.constructor = X.Tileset, X.Particle = function(t, e, i, s, n) {
                X.Sprite.call(this, t, e, i, s, n), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
            }, X.Particle.prototype = Object.create(X.Sprite.prototype), X.Particle.prototype.constructor = X.Particle, X.Particle.prototype.update = function() {
                this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
            }, X.Particle.prototype.onEmit = function() {}, X.Particle.prototype.setAlphaData = function(t) {
                this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
            }, X.Particle.prototype.setScaleData = function(t) {
                this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
            }, X.Particle.prototype.reset = function(t, e, i) {
                return X.Component.Reset.prototype.reset.call(this, t, e, i), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
            }, X.Particles = function(t) {
                this.game = t, this.emitters = {}, this.ID = 0
            }, X.Particles.prototype = {
                add: function(t) {
                    return this.emitters[t.name] = t
                },
                remove: function(t) {
                    delete this.emitters[t.name]
                },
                update: function() {
                    for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
                }
            }, X.Particles.prototype.constructor = X.Particles, X.Particles.Arcade = {}, X.Particles.Arcade.Emitter = function(t, e, i, s) {
                this.maxParticles = s || 50, X.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = X.EMITTER, this.physicsType = X.GROUP, this.area = new X.Rectangle(e, i, 1, 1), this.minParticleSpeed = new X.Point(-100, -100), this.maxParticleSpeed = new X.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = X.Particle, this.particleDrag = new X.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new X.Point, this.on = !1, this.particleAnchor = new X.Point(.5, .5), this.blendMode = X.blendModes.NORMAL, this.emitX = e, this.emitY = i, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new X.Point(1, 1), this._maxParticleScale = new X.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
            }, X.Particles.Arcade.Emitter.prototype = Object.create(X.Group.prototype), X.Particles.Arcade.Emitter.prototype.constructor = X.Particles.Arcade.Emitter, X.Particles.Arcade.Emitter.prototype.update = function() {
                if (this.on && this.game.time.time >= this._timer)
                    if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                        if (0 < this._flowQuantity) {
                            for (var t = 0; t < this._flowQuantity; t++)
                                if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                    this.on = !1;
                                    break
                                }
                        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
                else this.emitParticle() && (this._counter++, 0 < this._quantity && this._counter >= this._quantity && (this.on = !1));
                for (t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
            }, X.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === s && (s = !1), void 0 === n && (n = !1);
                var a, o = 0,
                    r = t,
                    h = e;
                for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); o < i;) Array.isArray(t) && (r = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), a = new this.particleClass(this.game, 0, 0, r, h), this.game.physics.arcade.enable(a, !1), s ? (a.body.checkCollision.any = !0, a.body.checkCollision.none = !1) : a.body.checkCollision.none = !0, a.body.collideWorldBounds = n, a.body.skipQuadTree = !0, a.exists = !1, a.visible = !1, a.anchor.copyFrom(this.particleAnchor), this.add(a), o++;
                return this
            }, X.Particles.Arcade.Emitter.prototype.kill = function() {
                return this.on = !1, this.alive = !1, this.exists = !1, this
            }, X.Particles.Arcade.Emitter.prototype.revive = function() {
                return this.alive = !0, this.exists = !0, this
            }, X.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
                return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
            }, X.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, n) {
                return void 0 !== i && 0 !== i || (i = 1), void 0 === s && (s = -1), void 0 === n && (n = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = s, n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
            }, X.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
                if (void 0 === t && (t = !0), void 0 === e && (e = 0), null != i || (i = 250), void 0 === s && (s = 0), void 0 === n && (n = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n)
                    for (var a = 0; a < s; a++) this.emitParticle();
                else this.on = !0, this._quantity = s, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
                return this
            }, X.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
                void 0 === t && (t = null), void 0 === e && (e = null);
                var n = this.getFirstExists(!1);
                if (null === n) return !1;
                var a = this.game.rnd;
                void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && n.loadTexture(i);
                var o = this.emitX,
                    i = this.emitY;
                null !== t ? o = t : 1 < this.width && (o = a.between(this.left, this.right)), null !== e ? i = e : 1 < this.height && (i = a.between(this.top, this.bottom)), n.reset(o, i), n.angle = 0, n.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(n) : this.particleSendToBack && this.sendToBack(n), this.autoScale ? n.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? n.scale.set(a.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || n.scale.set(a.realInRange(this._minParticleScale.x, this._maxParticleScale.x), a.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === s && (Array.isArray(this._frames) ? n.frame = this.game.rnd.pick(this._frames) : n.frame = this._frames), this.autoAlpha ? n.setAlphaData(this.alphaData) : n.alpha = a.realInRange(this.minParticleAlpha, this.maxParticleAlpha), n.blendMode = this.blendMode;
                s = n.body;
                return s.updateBounds(), s.bounce.copyFrom(this.bounce), s.drag.copyFrom(this.particleDrag), s.velocity.x = a.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), s.velocity.y = a.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), s.angularVelocity = a.between(this.minRotation, this.maxRotation), s.gravity.y = this.gravity, s.angularDrag = this.angularDrag, n.onEmit(), !0
            }, X.Particles.Arcade.Emitter.prototype.destroy = function() {
                this.game.particles.remove(this), X.Group.prototype.destroy.call(this, !0, !1)
            }, X.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
                return this.area.width = t, this.area.height = e, this
            }, X.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
            }, X.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
            }, X.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
                return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
            }, X.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, i, s, n) {
                return void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === s && (s = X.Easing.Linear.None), void 0 === n && (n = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, 0 < i && t !== e && (t = {
                    v: t
                }, (s = this.game.make.tween(t).to({
                    v: e
                }, i, s)).yoyo(n), this.alphaData = s.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0), this
            }, X.Particles.Arcade.Emitter.prototype.setScale = function(t, e, i, s, n, a, o) {
                return void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === a && (a = X.Easing.Linear.None), void 0 === o && (o = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, i), this._maxParticleScale.set(e, s), this.autoScale = !1, 0 < n && (t !== e || i !== s) && (i = {
                    x: t,
                    y: i
                }, (a = this.game.make.tween(i).to({
                    x: e,
                    y: s
                }, n, a)).yoyo(o), this.scaleData = a.generateData(60), this.scaleData.reverse(), this.autoScale = !0), this
            }, X.Particles.Arcade.Emitter.prototype.at = function(t) {
                return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
            }, Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "width", {
                get: function() {
                    return this.area.width
                },
                set: function(t) {
                    this.area.width = t
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "height", {
                get: function() {
                    return this.area.height
                },
                set: function(t) {
                    this.area.height = t
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "x", {
                get: function() {
                    return this.emitX
                },
                set: function(t) {
                    this.emitX = t
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "y", {
                get: function() {
                    return this.emitY
                },
                set: function(t) {
                    this.emitY = t
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "left", {
                get: function() {
                    return Math.floor(this.x - this.area.width / 2)
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "right", {
                get: function() {
                    return Math.floor(this.x + this.area.width / 2)
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "top", {
                get: function() {
                    return Math.floor(this.y - this.area.height / 2)
                }
            }), Object.defineProperty(X.Particles.Arcade.Emitter.prototype, "bottom", {
                get: function() {
                    return Math.floor(this.y + this.area.height / 2)
                }
            }), X.Weapon = function(t, e) {
                X.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new X.Rectangle(0, 0, 1, 1), this.fireAngle = X.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new X.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = X.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = X.Weapon.KILL_WORLD_BOUNDS, this._data = {
                    customBody: !1,
                    width: 0,
                    height: 0,
                    offsetX: 0,
                    offsetY: 0
                }, this.bounds = new X.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new X.Signal, this.onKill = new X.Signal, this.onFireLimit = new X.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new X.Point, this._nextFire = 0, this._rotatedPoint = new X.Point
            }, X.Weapon.prototype = Object.create(X.Plugin.prototype), X.Weapon.prototype.constructor = X.Weapon, X.Weapon.KILL_NEVER = 0, X.Weapon.KILL_LIFESPAN = 1, X.Weapon.KILL_DISTANCE = 2, X.Weapon.KILL_WEAPON_BOUNDS = 3, X.Weapon.KILL_CAMERA_BOUNDS = 4, X.Weapon.KILL_WORLD_BOUNDS = 5, X.Weapon.KILL_STATIC_BOUNDS = 6, X.Weapon.prototype.createBullets = function(t, e, i, s) {
                return void 0 === t && (t = 1), void 0 === s && (s = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(X.Physics.ARCADE, s), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, i), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = i), this
            }, X.Weapon.prototype.forEach = function(t, e) {
                return this.bullets.forEachExists(t, e, arguments), this
            }, X.Weapon.prototype.pauseAll = function() {
                return this.bullets.setAll("body.enable", !1), this
            }, X.Weapon.prototype.resumeAll = function() {
                return this.bullets.setAll("body.enable", !0), this
            }, X.Weapon.prototype.killAll = function() {
                return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
            }, X.Weapon.prototype.resetShots = function(t) {
                return void(this.shots = 0) !== t && (this.fireLimit = t), this
            }, X.Weapon.prototype.destroy = function() {
                this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }, X.Weapon.prototype.update = function() {
                this._bulletKillType === X.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
            }, X.Weapon.prototype.trackSprite = function(t, e, i, s) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = s, this.trackOffset.set(e, i), this
            }, X.Weapon.prototype.trackPointer = function(t, e, i) {
                return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
            }, X.Weapon.prototype.fire = function(t, e, i) {
                if (this.game.time.now < this._nextFire || 0 < this.fireLimit && this.shots === this.fireLimit) return !1;
                var s = this.bulletSpeed;
                0 !== this.bulletSpeedVariance && (s += X.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? 1 < this.fireFrom.width ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), 1 < this.fireFrom.width ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : 1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (s += this.trackedSprite.body.speed)) : this.trackedPointer && (1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
                var n = 1 < this.fireFrom.width ? this.fireFrom.randomX : this.fireFrom.x,
                    a = 1 < this.fireFrom.height ? this.fireFrom.randomY : this.fireFrom.y,
                    o = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
                void 0 !== e && void 0 !== i && (o = this.game.math.radToDeg(Math.atan2(i - a, e - n))), 0 !== this.bulletAngleVariance && (o += X.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
                t = 0, i = 0;
                0 === o || 180 === o ? t = Math.cos(this.game.math.degToRad(o)) * s : i = (90 === o || 270 === o || (t = Math.cos(this.game.math.degToRad(o)) * s), Math.sin(this.game.math.degToRad(o)) * s);
                e = null;
                return this.autoExpandBulletsGroup ? (e = this.bullets.getFirstExists(!1, !0, n, a, this.bulletKey, this.bulletFrame)).data.bulletManager = this : e = this.bullets.getFirstExists(!1), e && (e.reset(n, a), e.data.fromX = n, e.data.fromY = a, e.data.killType = this.bulletKillType, e.data.killDistance = this.bulletKillDistance, e.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === X.Weapon.KILL_LIFESPAN && (e.lifespan = this.bulletLifespan), e.angle = o + this.bulletAngleOffset, "" !== this.bulletAnimation ? (null === e.animations.getAnimation(this.bulletAnimation) && (o = this.anims[this.bulletAnimation], e.animations.add(o.name, o.frames, o.frameRate, o.loop, o.useNumericIndex)), e.animations.play(this.bulletAnimation)) : this.bulletFrameCycle ? (e.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (e.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]), e.data.bodyDirty && (this._data.customBody && e.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), e.body.collideWorldBounds = this.bulletCollideWorldBounds, e.data.bodyDirty = !1), e.body.velocity.set(t, i), e.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance ? (i = this.fireRate, (i += X.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (i = 0), this._nextFire = this.game.time.now + i) : this._nextFire = this.game.time.now + this.fireRate, this.shots++, this.onFire.dispatch(e, this, s), 0 < this.fireLimit && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)), e
            }, X.Weapon.prototype.fireAtPointer = function(t) {
                return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
            }, X.Weapon.prototype.fireAtSprite = function(t) {
                return this.fire(null, t.world.x, t.world.y)
            }, X.Weapon.prototype.fireAtXY = function(t, e) {
                return this.fire(null, t, e)
            }, X.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
                return void 0 === i && (i = 0), void 0 === s && (s = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = s, this.bullets.callAll("body.setSize", "body", t, e, i, s), this.bullets.setAll("data.bodyDirty", !1), this
            }, X.Weapon.prototype.setBulletFrames = function(t, e, i, s) {
                return void 0 === i && (i = !0), void 0 === s && (s = !1), this.bulletFrames = X.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = i, this.bulletFrameRandom = s, this
            }, X.Weapon.prototype.addBulletAnimation = function(t, e, i, s, n) {
                return this.anims[t] = {
                    name: t,
                    frames: e,
                    frameRate: i,
                    loop: s,
                    useNumericIndex: n
                }, this.bullets.callAll("animations.add", "animations", t, e, i, s, n), this.bulletAnimation = t, this
            }, X.Weapon.prototype.debug = function(t, e, i) {
                void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
            }, Object.defineProperty(X.Weapon.prototype, "bulletClass", {
                get: function() {
                    return this._bulletClass
                },
                set: function(t) {
                    this._bulletClass = t, this.bullets.classType = this._bulletClass
                }
            }), Object.defineProperty(X.Weapon.prototype, "bulletKillType", {
                get: function() {
                    return this._bulletKillType
                },
                set: function(t) {
                    switch (t) {
                        case X.Weapon.KILL_STATIC_BOUNDS:
                        case X.Weapon.KILL_WEAPON_BOUNDS:
                            this.bulletBounds = this.bounds;
                            break;
                        case X.Weapon.KILL_CAMERA_BOUNDS:
                            this.bulletBounds = this.game.camera.view;
                            break;
                        case X.Weapon.KILL_WORLD_BOUNDS:
                            this.bulletBounds = this.game.world.bounds
                    }
                    this._bulletKillType = t
                }
            }), Object.defineProperty(X.Weapon.prototype, "bulletCollideWorldBounds", {
                get: function() {
                    return this._bulletCollideWorldBounds
                },
                set: function(t) {
                    this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
                }
            }), Object.defineProperty(X.Weapon.prototype, "x", {
                get: function() {
                    return this.fireFrom.x
                },
                set: function(t) {
                    this.fireFrom.x = t
                }
            }), Object.defineProperty(X.Weapon.prototype, "y", {
                get: function() {
                    return this.fireFrom.y
                },
                set: function(t) {
                    this.fireFrom.y = t
                }
            }), X.Bullet = function(t, e, i, s, n) {
                X.Sprite.call(this, t, e, i, s, n), this.anchor.set(.5), this.data = {
                    bulletManager: null,
                    fromX: 0,
                    fromY: 0,
                    bodyDirty: !0,
                    rotateToVelocity: !1,
                    killType: 0,
                    killDistance: 0
                }
            }, X.Bullet.prototype = Object.create(X.Sprite.prototype), X.Bullet.prototype.constructor = X.Bullet, X.Bullet.prototype.kill = function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
            }, X.Bullet.prototype.update = function() {
                this.exists && (this.data.killType > X.Weapon.KILL_LIFESPAN && (this.data.killType === X.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
            }, X.Video = function(t, e, i) {
                var s;
                void 0 === e && (e = null), void 0 === i && (i = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = X.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new X.Signal, this.onChangeSource = new X.Signal, this.onComplete = new X.Signal, this.onAccess = new X.Signal, this.onError = new X.Signal, this.onTimeout = new X.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e) ? ((s = this.game.cache.getVideo(e)).isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight) : i && this.createVideoFromURL(i, !1), this.video && !i ? this.baseTexture = new PIXI.BaseTexture(this.video) : this.baseTexture = new PIXI.BaseTexture(X.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new X.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, X.BitmapData && (this.snapshot = new X.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
            }, X.Video.prototype = {
                connectToMediaStream: function(t, e) {
                    return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
                },
                startMediaStream: function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                    null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                    try {
                        navigator.getUserMedia({
                            audio: t,
                            video: !0
                        }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                    } catch (t) {
                        this.getUserMediaError(t)
                    }
                    return this
                },
                getUserMediaTimeout: function() {
                    clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
                },
                getUserMediaError: function(t) {
                    clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
                },
                getUserMediaSuccess: function(t) {
                    clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                    var n = this;
                    this.video.onloadeddata = function() {
                        var s = 10;
                        ! function t() {
                            var e, i;
                            0 < s && (0 < n.video.videoWidth ? (e = n.video.videoWidth, i = n.video.videoHeight, isNaN(n.video.videoHeight) && (i = e / (4 / 3)), n.video.play(), n.isStreaming = !0, n.baseTexture.source = n.video, n.updateTexture(null, e, i), n.onAccess.dispatch(n)) : window.setTimeout(t, 500)), s--
                        }()
                    }
                },
                createVideoFromBlob: function(t) {
                    var e = this;
                    return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                        e.updateTexture(t)
                    }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
                },
                createVideoFromURL: function(t, e) {
                    return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
                },
                updateTexture: function(t, e, i) {
                    var s = !1;
                    null != e || (e = this.video.videoWidth, s = !0), null != i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
                },
                complete: function() {
                    this.onComplete.dispatch(this)
                },
                play: function(t, e) {
                    return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
                },
                playHandler: function() {
                    this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
                },
                stop: function() {
                    return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                        t.stop()
                    }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
                },
                add: function(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                    else t.loadTexture(this);
                    return this
                },
                addToWorld: function(t, e, i, s, n, a) {
                    n = n || 1, a = a || 1;
                    e = this.game.add.image(t, e, this);
                    return e.anchor.set(i, s), e.scale.set(n, a), e
                },
                render: function() {
                    !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
                },
                setMute: function() {
                    this._muted || (this._muted = !0, this.video.muted = !0)
                },
                unsetMute: function() {
                    this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
                },
                setPause: function() {
                    this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
                },
                setResume: function() {
                    !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
                },
                changeSource: function(t, e) {
                    return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), (this._autoplay = e) || (this.paused = !0), this
                },
                checkVideoProgress: function() {
                    4 === this.video.readyState ? this.updateTexture() : 0 < --this.retry && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))
                },
                setTouchLock: function() {
                    this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
                },
                unlock: function() {
                    var t;
                    return this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key && (t = this.game.cache.getVideo(this.key)) && !t.isBlob && (t.locked = !1), !0
                },
                grab: function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot
                },
                removeVideoElement: function() {
                    if (this.video) {
                        for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                        this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                    }
                },
                destroy: function() {
                    this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
                }
            }, Object.defineProperty(X.Video.prototype, "currentTime", {
                get: function() {
                    return this.video ? this.video.currentTime : 0
                },
                set: function(t) {
                    this.video.currentTime = t
                }
            }), Object.defineProperty(X.Video.prototype, "duration", {
                get: function() {
                    return this.video ? this.video.duration : 0
                }
            }), Object.defineProperty(X.Video.prototype, "progress", {
                get: function() {
                    return this.video ? this.video.currentTime / this.video.duration : 0
                }
            }), Object.defineProperty(X.Video.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    (t = t || null) ? this._muted || (this._codeMuted = !0, this.setMute()): this._muted && (this._codeMuted = !1, this.unsetMute())
                }
            }), Object.defineProperty(X.Video.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    t = t || null, this.touchLocked || (t ? this._paused || (this._codePaused = !0, this.setPause()) : this._paused && (this._codePaused = !1, this.setResume()))
                }
            }), Object.defineProperty(X.Video.prototype, "volume", {
                get: function() {
                    return this.video ? this.video.volume : 1
                },
                set: function(t) {
                    t < 0 ? t = 0 : 1 < t && (t = 1), this.video && (this.video.volume = t)
                }
            }), Object.defineProperty(X.Video.prototype, "playbackRate", {
                get: function() {
                    return this.video ? this.video.playbackRate : 1
                },
                set: function(t) {
                    this.video && (this.video.playbackRate = t)
                }
            }), Object.defineProperty(X.Video.prototype, "loop", {
                get: function() {
                    return !!this.video && this.video.loop
                },
                set: function(t) {
                    t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
                }
            }), Object.defineProperty(X.Video.prototype, "playing", {
                get: function() {
                    return !(this.video.paused && this.video.ended)
                }
            }), X.Video.prototype.constructor = X.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = X.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = X.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = X.POLYGON, PIXI.Graphics.RECT = X.RECTANGLE, PIXI.Graphics.CIRC = X.CIRCLE, PIXI.Graphics.ELIP = X.ELLIPSE, PIXI.Graphics.RREC = X.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, void 0 !== h && h.exports && (l = h.exports = X), l.Phaser = X
        }).call(this)
    }).call(l, t(59))
}, function(t, e) {
    function i() {
        throw new Error("setTimeout has not been defined")
    }

    function s() {
        throw new Error("clearTimeout has not been defined")
    }

    function n(e) {
        if (l === setTimeout) return setTimeout(e, 0);
        if ((l === i || !l) && setTimeout) return l = setTimeout, setTimeout(e, 0);
        try {
            return l(e, 0)
        } catch (t) {
            try {
                return l.call(null, e, 0)
            } catch (t) {
                return l.call(this, e, 0)
            }
        }
    }

    function a() {
        p && u && (p = !1, u.length ? d = u.concat(d) : f = -1, d.length && o())
    }

    function o() {
        if (!p) {
            var t = n(a);
            p = !0;
            for (var e = d.length; e;) {
                for (u = d, d = []; ++f < e;) u && u[f].run();
                f = -1, e = d.length
            }
            u = null, p = !1,
                function(e) {
                    if (c === clearTimeout) return clearTimeout(e);
                    if ((c === s || !c) && clearTimeout) return c = clearTimeout, clearTimeout(e);
                    try {
                        c(e)
                    } catch (t) {
                        try {
                            return c.call(null, e)
                        } catch (t) {
                            return c.call(this, e)
                        }
                    }
                }(t)
        }
    }

    function r(t, e) {
        this.fun = t, this.array = e
    }

    function h() {}
    var l, c, t = t.exports = {};
    ! function() {
        try {
            l = "function" == typeof setTimeout ? setTimeout : i
        } catch (t) {
            l = i
        }
        try {
            c = "function" == typeof clearTimeout ? clearTimeout : s
        } catch (t) {
            c = s
        }
    }();
    var u, d = [],
        p = !1,
        f = -1;
    t.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (1 < arguments.length)
            for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        d.push(new r(t, e)), 1 !== d.length || p || n(o)
    }, r.prototype.run = function() {
        this.fun.apply(null, this.array)
    }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", t.versions = {}, t.on = h, t.addListener = h, t.once = h, t.off = h, t.removeListener = h, t.removeAllListeners = h, t.emit = h, t.prependListener = h, t.prependOnceListener = h, t.listeners = function(t) {
        return []
    }, t.binding = function(t) {
        throw new Error("process.binding is not supported")
    }, t.cwd = function() {
        return "/"
    }, t.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }, t.umask = function() {
        return 0
    }
}, function(it, st, nt) {
    var at;
    ! function() {
        function s(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function n(e, i, t) {
            if (!e) throw Error();
            if (2 < arguments.length) {
                var s = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var t = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(t, s), e.apply(i, t)
                }
            }
            return function() {
                return e.apply(i, arguments)
            }
        }

        function f(t, e, i) {
            return (f = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? s : n).apply(null, arguments)
        }

        function e(t, e) {
            this.a = t, this.o = e || t, this.c = this.o.document
        }

        function r(t, e, i, s) {
            if (e = t.c.createElement(e), i)
                for (var n in i) i.hasOwnProperty(n) && ("style" == n ? e.style.cssText = i[n] : e.setAttribute(n, i[n]));
            return s && e.appendChild(t.c.createTextNode(s)), e
        }

        function h(t, e, i) {
            (t = (t = t.c.getElementsByTagName(e)[0]) || document.documentElement).insertBefore(i, t.lastChild)
        }

        function i(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function g(t, e, i) {
            e = e || [], i = i || [];
            for (var s = t.className.split(/\s+/), n = 0; n < e.length; n += 1) {
                for (var a = !1, o = 0; o < s.length; o += 1)
                    if (e[n] === s[o]) {
                        a = !0;
                        break
                    }
                a || s.push(e[n])
            }
            for (e = [], n = 0; n < s.length; n += 1) {
                for (a = !1, o = 0; o < i.length; o += 1)
                    if (s[n] === i[o]) {
                        a = !0;
                        break
                    }
                a || e.push(s[n])
            }
            t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function a(t, e) {
            for (var i = t.className.split(/\s+/), s = 0, n = i.length; s < n; s++)
                if (i[s] == e) return !0;
            return !1
        }

        function c(t, e, i) {
            function s() {
                o && n && (o(a), o = null)
            }
            e = r(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var n = !1,
                a = null,
                o = i || null;
            V ? (e.onload = function() {
                n = !0, s()
            }, e.onerror = function() {
                n = !0, a = Error("Stylesheet failed to load"), s()
            }) : setTimeout(function() {
                n = !0, s()
            }, 0), h(t, "head", e)
        }

        function u(t, e, i, s) {
            var n = t.c.getElementsByTagName("head")[0];
            if (n) {
                var a = r(t, "script", {
                        src: e
                    }),
                    o = !1;
                return a.onload = a.onreadystatechange = function() {
                    o || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (o = !0, i && i(null), a.onload = a.onreadystatechange = null, "HEAD" == a.parentNode.tagName && n.removeChild(a))
                }, n.appendChild(a), setTimeout(function() {
                    o || (o = !0, i && i(Error("Script load timeout")))
                }, s || 5e3), a
            }
            return null
        }

        function d() {
            this.a = 0, this.c = null
        }

        function p(t) {
            return t.a++,
                function() {
                    t.a--, o(t)
                }
        }

        function m(t, e) {
            t.c = e, o(t)
        }

        function o(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function l(t) {
            this.a = t || "-"
        }

        function y(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            e = (e || "n4").match(/^([nio])([1-9])$/i);
            e && (this.a = e[1], this.f = parseInt(e[2], 10))
        }

        function b(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var s = t[i].replace(/['"]/g, ""); - 1 != s.indexOf(" ") || /^\d/.test(s) ? e.push("'" + s + "'") : e.push(s)
            }
            return e.join(",")
        }

        function v(t) {
            return t.a + t.f
        }

        function _(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function x(t, e) {
            this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new l("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
        }

        function w(t) {
            var e, i, s;
            t.g && (e = a(t.f, t.a.c("wf", "active")), i = [], s = [t.a.c("wf", "loading")], e || i.push(t.a.c("wf", "inactive")), g(t.f, i, s)), P(t, "inactive")
        }

        function P(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, v(i)) : t.h[e]())
        }

        function T() {
            this.c = {}
        }

        function S(t, e) {
            this.c = t, this.f = e, this.a = r(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function C(t) {
            h(t.c, "body", t.a)
        }

        function A(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + b(t.c) + ";font-style:" + _(t) + ";font-weight:" + t.f + "00;"
        }

        function E(t, e, i, s, n, a) {
            this.g = t, this.j = e, this.a = s, this.c = i, this.f = n || 3e3, this.h = a || void 0
        }

        function I(t, e, i, s, n, a, o) {
            this.v = t, this.B = e, this.c = i, this.a = s, this.s = o || "BESbswy", this.f = {}, this.w = n || 3e3, this.u = a || null, this.m = this.j = this.h = this.g = null, this.g = new S(this.c, this.s), this.h = new S(this.c, this.s), this.j = new S(this.c, this.s), this.m = new S(this.c, this.s), t = A(t = new y(this.a.c + ",serif", v(this.a))), this.g.a.style.cssText = t, t = A(t = new y(this.a.c + ",sans-serif", v(this.a))), this.h.a.style.cssText = t, t = A(t = new y("serif", v(this.a))), this.j.a.style.cssText = t, t = A(t = new y("sans-serif", v(this.a))), this.m.a.style.cssText = t, C(this.g), C(this.h), C(this.j), C(this.m)
        }

        function B() {
            var t;
            return null === q && (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), q = !!t && (parseInt(t[1], 10) < 536 || 536 === parseInt(t[1], 10) && parseInt(t[2], 10) <= 11)), q
        }

        function M(t, e, i) {
            for (var s in Y)
                if (Y.hasOwnProperty(s) && e === t.f[Y[s]] && i === t.f[Y[s]]) return !0;
            return !1
        }

        function k(t) {
            var e, i = t.g.a.offsetWidth,
                s = t.h.a.offsetWidth;
            (e = i === t.f.serif && s === t.f["sans-serif"]) || (e = B() && M(t, i, s)), e ? H() - t.A >= t.w ? B() && M(t, i, s) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? O(t, t.v) : O(t, t.B) : setTimeout(f(function() {
                k(this)
            }, t), 50) : O(t, t.v)
        }

        function O(t, e) {
            setTimeout(f(function() {
                i(this.g.a), i(this.h.a), i(this.j.a), i(this.m.a), e(this.a)
            }, t), 0)
        }

        function D(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }

        function L(t) {
            0 == --t.f && t.j && (t.m ? ((t = t.a).g && g(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), P(t, "active")) : w(t.a))
        }

        function t(t) {
            this.j = t, this.a = new T, this.h = 0, this.f = this.g = !0
        }

        function R(s, t, e) {
            var i, n = [],
                a = e.timeout;
            (i = t).g && g(i.f, [i.a.c("wf", "loading")]), P(i, "loading");
            var n = function(t, e, i) {
                    var s, n, a = [];
                    for (s in e) !e.hasOwnProperty(s) || (n = t.c[s]) && a.push(n(e[s], i));
                    return a
                }(s.a, e, s.c),
                o = new D(s.c, t, a);
            for (s.h = n.length, t = 0, e = n.length; t < e; t++) n[t].load(function(t, e, i) {
                var l, c, u, d, p;
                l = o, c = t, u = e, d = i, p = 0 == --(i = s).h, (i.f || i.g) && setTimeout(function() {
                    var t = d || null,
                        e = u || {};
                    if (0 === c.length && p) w(l.a);
                    else {
                        l.f += c.length, p && (l.j = p);
                        for (var i = [], s = 0; s < c.length; s++) {
                            var n, a = c[s],
                                o = e[a.c],
                                r = l.a,
                                h = a;
                            r.g && g(r.f, [r.a.c("wf", h.c, v(h).toString(), "loading")]), P(r, "fontloading", h), (r = null) === z && (z = !!window.FontFace && (h = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent), n = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor), h ? 42 < parseInt(h[1], 10) : !n)), r = z ? new E(f(l.g, l), f(l.h, l), l.c, a, l.s, o) : new I(f(l.g, l), f(l.h, l), l.c, a, l.s, t, o), i.push(r)
                        }
                        for (s = 0; s < i.length; s++) i[s].start()
                    }
                }, 0)
            })
        }

        function F(t, e) {
            this.c = t, this.a = e
        }

        function G(t, e) {
            this.c = t, this.a = e
        }

        function N(t, e) {
            this.c = t || "https://fonts.googleapis.com/css", this.a = [], this.f = [], this.g = e || ""
        }

        function U(t) {
            this.f = t, this.a = [], this.c = {}
        }

        function j(t, e) {
            this.c = t, this.a = e
        }

        function X(t, e) {
            this.c = t, this.a = e
        }

        function W(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        var H = Date.now || function() {
                return +new Date
            },
            V = !!window.FontFace;
        l.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase());
            return e.join(this.a)
        }, E.prototype.start = function() {
            var n = this.c.o.document,
                a = this,
                o = H(),
                t = new Promise(function(i, s) {
                    ! function e() {
                        var t;
                        H() - o >= a.f ? s() : n.fonts.load(_(t = a.a) + " " + t.f + "00 300px " + b(t.c), a.h).then(function(t) {
                            1 <= t.length ? i() : setTimeout(e, 25)
                        }, function() {
                            s()
                        })
                    }()
                }),
                i = null,
                e = new Promise(function(t, e) {
                    i = setTimeout(e, a.f)
                });
            Promise.race([e, t]).then(function() {
                i && (clearTimeout(i), i = null), a.g(a.a)
            }, function() {
                a.j(a.a)
            })
        };
        var Y = {
                D: "serif",
                C: "sans-serif"
            },
            q = null;
        I.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = H(), k(this)
        };
        var z = null;
        D.prototype.g = function(t) {
            var e = this.a;
            e.g && g(e.f, [e.a.c("wf", t.c, v(t).toString(), "active")], [e.a.c("wf", t.c, v(t).toString(), "loading"), e.a.c("wf", t.c, v(t).toString(), "inactive")]), P(e, "fontactive", t), this.m = !0, L(this)
        }, D.prototype.h = function(t) {
            var e, i, s, n = this.a;
            n.g && (e = a(n.f, n.a.c("wf", t.c, v(t).toString(), "active")), i = [], s = [n.a.c("wf", t.c, v(t).toString(), "loading")], e || i.push(n.a.c("wf", t.c, v(t).toString(), "inactive")), g(n.f, i, s)), P(n, "fontinactive", t), L(this)
        }, t.prototype.load = function(t) {
            this.c = new e(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes, R(this, new x(this.c, t), t)
        }, F.prototype.load = function(o) {
            var r, e = this,
                h = e.a.projectId,
                t = e.a.version;
            h ? (r = e.c.o, u(this.c, (e.a.api || "https://fast.fonts.net/jsapi") + "/" + h + ".js" + (t ? "?v=" + t : ""), function(t) {
                t ? o([]) : (r["__MonotypeConfiguration__" + h] = function() {
                    return e.a
                }, function t() {
                    if (r["__mti_fntLst" + h]) {
                        var e, i = r["__mti_fntLst" + h](),
                            s = [];
                        if (i)
                            for (var n = 0; n < i.length; n++) {
                                var a = i[n].fontfamily;
                                null != i[n].fontStyle && null != i[n].fontWeight ? (e = i[n].fontStyle + i[n].fontWeight, s.push(new y(a, e))) : s.push(new y(a))
                            }
                        o(s)
                    } else setTimeout(function() {
                        t()
                    }, 50)
                }())
            }).id = "__MonotypeAPIScript__" + h) : o([])
        }, G.prototype.load = function(t) {
            for (var e = this.a.urls || [], i = this.a.families || [], s = this.a.testStrings || {}, n = new d, a = 0, o = e.length; a < o; a++) c(this.c, e[a], p(n));
            var r = [];
            for (a = 0, o = i.length; a < o; a++)
                if ((e = i[a].split(":"))[1])
                    for (var h = e[1].split(","), l = 0; l < h.length; l += 1) r.push(new y(e[0], h[l]));
                else r.push(new y(e[0]));
            m(n, function() {
                t(r, s)
            })
        };
        var K = {
                latin: "BESbswy",
                "latin-ext": "Ã§Ã¶Ã¼ÄÅ",
                cyrillic: "Ð¹ÑÐ",
                greek: "Î±Î²Î£",
                khmer: "ááá",
                Hanuman: "ááá"
            },
            J = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            Z = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            Q = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
            $ = {
                Arimo: !0,
                Cousine: !0,
                Tinos: !0
            };
        j.prototype.load = function(t) {
            var e = new d,
                i = this.c,
                s = new N(this.a.api, this.a.text),
                n = this.a.families;
            ! function(t, e) {
                for (var i = e.length, s = 0; s < i; s++) {
                    var n = e[s].split(":");
                    3 == n.length && t.f.push(n.pop());
                    var a = "";
                    2 == n.length && "" != n[1] && (a = ":"), t.a.push(n.join(a))
                }
            }(s, n);
            var a = new U(n);
            (function(t) {
                for (var e = t.f.length, i = 0; i < e; i++) {
                    var s = t.f[i].split(":"),
                        n = s[0].replace(/\+/g, " "),
                        a = ["n4"];
                    if (2 <= s.length) {
                        var o, r, h = s[1],
                            l = [];
                        if (h)
                            for (var c = (h = h.split(",")).length, u = 0; u < c; u++)(r = !(r = h[u]).match(/^[\w-]+$/) || null == (o = Q.exec(r.toLowerCase())) ? "" : [r = null == (r = o[2]) || "" == r ? "n" : Z[r], o = null == (o = o[1]) || "" == o ? "4" : J[o] || (isNaN(o) ? "4" : o.substr(0, 1))].join("")) && l.push(r);
                        0 < l.length && (a = l), 3 == s.length && (l = [], 0 < (s = (s = s[2]) ? s.split(",") : l).length && (s = K[s[0]]) && (t.c[n] = s))
                    }
                    for (t.c[n] || (s = K[n]) && (t.c[n] = s), s = 0; s < a.length; s += 1) t.a.push(new y(n, a[s]))
                }
            })(a), c(i, function(t) {
                if (0 == t.a.length) throw Error("No fonts to load!");
                if (-1 != t.c.indexOf("kit=")) return t.c;
                for (var e = t.a.length, i = [], s = 0; s < e; s++) i.push(t.a[s].replace(/ /g, "+"));
                return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
            }(s), p(e)), m(e, function() {
                t(a.a, a.c, $)
            })
        }, X.prototype.load = function(o) {
            var t = this.a.id,
                r = this.c.o;
            t ? u(this.c, (this.a.api || "https://use.typekit.net") + "/" + t + ".js", function(t) {
                if (t) o([]);
                else if (r.Typekit && r.Typekit.config && r.Typekit.config.fn) {
                    t = r.Typekit.config.fn;
                    for (var e = [], i = 0; i < t.length; i += 2)
                        for (var s = t[i], n = t[i + 1], a = 0; a < n.length; a++) e.push(new y(s, n[a]));
                    try {
                        r.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    o(e)
                }
            }, 2e3) : o([])
        }, W.prototype.load = function(h) {
            var t = this.f.id,
                e = this.c.o,
                l = this;
            t ? (e.__webfontfontdeckmodule__ || (e.__webfontfontdeckmodule__ = {}), e.__webfontfontdeckmodule__[t] = function(t, e) {
                for (var i, s, n, a = 0, o = e.fonts.length; a < o; ++a) {
                    var r = e.fonts[a];
                    l.a.push(new y(r.name, (i = "font-weight:" + r.weight + ";font-style:" + r.style, r = n = s = void 0, s = 4, n = "n", r = null, i && ((r = i.match(/(normal|oblique|italic)/i)) && r[1] && (n = r[1].substr(0, 1).toLowerCase()), (r = i.match(/([1-9]00|normal|bold)/i)) && r[1] && (/bold/i.test(r[1]) ? s = 7 : /[1-9]00/.test(r[1]) && (s = parseInt(r[1].substr(0, 1), 10)))), n + s)))
                }
                h(l.a)
            }, u(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ((e = this.c).o.location.hostname || e.a.location.hostname) + "/" + t + ".js", function(t) {
                t && h([])
            })) : h([])
        };
        var tt = new t(window);
        tt.a.c.custom = function(t, e) {
            return new G(e, t)
        }, tt.a.c.fontdeck = function(t, e) {
            return new W(e, t)
        }, tt.a.c.monotype = function(t, e) {
            return new F(e, t)
        }, tt.a.c.typekit = function(t, e) {
            return new X(e, t)
        }, tt.a.c.google = function(t, e) {
            return new j(e, t)
        };
        var et = {
            load: f(tt.load, tt)
        };
        void 0 !== (at = function() {
            return et
        }.call(st, nt, st, it)) && (it.exports = at)
    }()
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(62),
        r = i(1),
        h = i(3),
        l = i(16),
        c = i(50),
        u = i(4),
        n = (a = Phaser.State, n(d, a), d.prototype.init = function() {
            var t = this;
            this.game.canvas.oncontextmenu = function(t) {
                t.preventDefault()
            }, this.game.input.maxPointers = 3, this.game.input.addPointer(), this.game.input.addPointer(), this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE, window.addEventListener("resize", function() {
                return d.mobileResizeCallback(t.game.scale)
            }), this.game.scale.onSizeChange.add(function() {
                r.Constants.LANDSCAPE_LOCKED && !u.default.isDesktop ? t.game.width > t.game.height ? t.handleCorrect() : t.handleIncorrect() : r.Constants.PORTRAIT_LOCKED && !u.default.isDesktop && (t.game.width < t.game.height ? t.handleCorrect() : t.handleIncorrect()), t.game.state.getCurrentState().resize()
            }, this), d.mobileResizeCallback(this.game.scale), document.addEventListener("pause", function() {
                t.game.sound.mute = !0
            }), document.addEventListener("resume", function() {
                t.game.sound.mute = !1
            }), this.stage.disableVisibilityChange = !1, this.game.onPause.add(function() {
                t.game.sound.mute = !0
            }), this.game.onResume.add(function() {
                t.game.sound.mute = !1
            })
        }, d.mobileResizeCallback = function(t) {
            var e = window.innerWidth,
                i = window.innerHeight;
            0 === i && (i = 1), 0 === e && (e = 1), d.setScaling(t.game);
            var s = 1066 * r.Constants.GAME_SCALE,
                n = 640 * r.Constants.GAME_SCALE,
                a = 1;
            a /= i < e ? i / n : i / s, r.Constants.WIDTH = 1066, r.Constants.HEIGHT = 640, r.Constants.CALCULATED_WIDTH = Math.ceil(e * a), r.Constants.CALCULATED_HEIGHT = Math.ceil(i * a), t.setGameSize(r.Constants.CALCULATED_WIDTH, r.Constants.CALCULATED_HEIGHT), t.setUserScale(1 / a, 1 / a), r.Constants.LANDSCAPE_LOCKED && !t.game.device.desktop && (t.game.width > t.game.height ? (document.getElementById("orientation").style.display = "none", document.getElementById("content").style.display = "block") : (document.getElementById("orientation").style.display = "block", document.getElementById("content").style.display = "none"))
        }, d.setScaling = function(t) {
            window.innerWidth > window.innerHeight ? window.innerWidth : window.innerHeight;
            t.device.pixelRatio, r.Constants.GAME_SCALE = 1
        }, d.prototype.preload = function() {
            var e = this;
            this.game.load.cacheBuster = 1580213608260;
            var i = "x" + r.Constants.GAME_SCALE + "/";
            r.Images.preloadList.forEach(function(t) {
                e.game.load.image(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/images/" + i + t + ".png")
            }), r.JSONData.preloadList.forEach(function(t) {
                e.game.load.json(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/data/" + t + ".json")
            }), r.Atlases.preloadList.forEach(function(t) {
                e.game.load.atlas(t, "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/" + i + t + ".png", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/atlases/" + i + t + ".json")
            }), r.Sounds.preloadList.forEach(function(t) {
                e.game.device.iOS ? e.game.load.audio(t, ["https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sounds/" + t + ".m4a"]) : e.game.load.audio(t, ["https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sounds/" + t + ".ogg", "https://cdn.jsdelivr.net/gh/Stypical/lacklack@0959ed15fc96078cbb053e4e3c259a62b3e9e296/basketball-stars/assets/sounds/" + t + ".mp3"])
            })
        }, d.prototype.create = function() {
            o.default.hide(), l.default.Current === l.default.YEP10 ? this.game.state.start(h.default.Name) : this.game.state.start(c.default.Name)
        }, d.prototype.handleCorrect = function() {
            document.getElementById("orientation").style.display = "none", document.getElementById("content").style.display = "block"
        }, d.prototype.handleIncorrect = function() {
            document.getElementById("orientation").style.display = "block", document.getElementById("content").style.display = "none"
        }, d.Name = "boot", d);

    function d() {
        var t = a.call(this) || this;
        return t.name = d.Name, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.show = function() {
        var t = document.getElementById("loader");
        t && (t.style.display = "block")
    }, n.hide = function() {
        var t = document.getElementById("loader");
        t && (t.style.display = "none")
    }, n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.MenuMusic = "24_TrackSnd", n.GameMusic = "24_TrackSnd", n.Click = "20_ButtonSnd", n.button = "20_ButtonSnd", n.b_bounce = "16_B_Bounce", n.m_countdown = "19_M_Countdown", n.m_whistle = "2_M_Whistle", n.shield = "13_P_Shield", n.m_win = "1_M_Win", n.m_lost = "12_M_Lost", n.m_buzzer = "9_M_Buzzer", n.p_swoosh = "5_P_Swoosh", n.p_floorStand = "14_P_FloorStand", n.p_floorRun = "15_P_FloorRun", n.p_dash = "17_P_Dash", n.p_superDash = "18_P_SuperDash", n.p_energy = "6_P_Energy", n.p_megaStart = "11_P_MegaStart", n.m_tribune = "3_M_Tribune", n.p_stunned = "7_P_Stunned", n.b_steel = "8_B_Steel", n.b_basket = "23_B_Basket", n.b_ring = "10_B_Ring", n.b_net = "21_B_NET", n.b_brick = "22_B_Brick", n.p_teleport = "4_P_Teleport", n.preloadList = [], n.list = [n.MenuMusic, n.b_bounce, n.Click, n.m_countdown, n.m_whistle, n.shield, n.m_win, n.m_lost, n.m_buzzer, n.p_swoosh, n.p_floorStand, n.p_floorRun, n.p_dash, n.p_superDash, n.p_energy, n.p_megaStart, n.p_stunned, n.m_tribune, n.b_steel, n.b_basket, n.b_ring, n.b_net, n.b_brick, n.p_teleport], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.Players = "Players", n.DBPers = "sk", n.DBPers_Texture = "texture", n.DBPers2 = "sk2", n.DBPers_Texture2 = "texture2", n.DBHelp = "sk3", n.DBHelp_Texture = "texture3", n.preloadList = [], n.list = [n.DBPers2, n.DBPers_Texture2, n.DBPers, n.DBPers_Texture, n.DBHelp, n.DBHelp_Texture, n.Players], n);

    function n() {}
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.start = function() {
        this.view.start(), this.physics.start()
    }, n.prototype.init = function(t) {
        this.game = t
    }, n.prototype.add = function(t) {
        this.objects.push(t), t.update && (this.updatedLen = this.updated.push(t)), t.restart && this.restarted.push(t), t.body && this.physics.add(t), t.graphic && this.view.add(t)
    }, n.prototype.slow = function(t) {
        switch (t) {
            case 1:
                this.timeScale = .05;
                break;
            case 2:
                this.timeScale = .4;
                break;
            case 3:
                this.timeScale = 0;
                break;
            default:
                this.timeScale = 1
        }
    }, n.prototype.update = function(t) {
        var e = t * this.timeScale;
        this.physics.update(e);
        for (var i = 0; i < this.updatedLen; i++) this.updated[i].update(e)
    }, n.prototype.restart = function(t) {
        void 0 === t && (t = 0), this.timeScale = 1;
        for (var e = this.restarted.length, i = 0; i < e; i++) this.restarted[i].restart(t)
    }, n.prototype.release = function() {
        this.timeScale = 1;
        for (var t = this.objects.length, e = 0; e < t; e++) this.objects[e].release();
        this.objects.splice(0, t), this.restarted.splice(0, this.restarted.length), this.updated.splice(0, this.updatedLen), this.updatedLen = 0, this.view.release(), this.physics.release(), this.view = null, this.physics = null
    }, n);

    function n() {
        this.isScored = !1, this.updated = [], this.restarted = [], this.objects = [], this.game = null, this.timeScale = 1
    }
    e.GameCore = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(38),
        r = i(19),
        h = i(14),
        l = i(4),
        c = i(67),
        u = i(39),
        d = i(0),
        p = i(13),
        f = i(68),
        n = (a = o.GameView, n(g, a), g.prototype.start = function() {
            this.addChild(this.gameObjects), this.addChild(this.gui), this.addChild(this.gamePadLayer), this.addChild(this.matchPreloader), this.startMatch()
        }, g.prototype.add = function(t) {
            var e, i;
            t.objType === r.ObjectsType.BALL ? this.ball.addChild(t.graphic) : t.objType === r.ObjectsType.SHADOW ? this.shadows.addChild(t.graphic) : t.objType === r.ObjectsType.PLAYER ? (i = 1, (e = t).isHuman || e.energyBar.parent.removeChild(e.energyBar), l.default.isDesktop ? e.isHuman && (this.players.addChildAt(e.energyBar, 0), i = 0) : e.isHuman && (e.energyBar.bg.destroy(), e.energyBar.hint.destroy(), e.energyBar.x = 0, e.energyBar.y = 0, h.default.instance.btnZ.label.parent.addChild(e.energyBar)), 0 < this.players.length ? this.players.addChildAt(t.graphic, this.players.length - i) : this.players.addChild(t.graphic)) : t.objType === r.ObjectsType.BASKET ? (this.back.addChild(t.graphic), this.frontObjects.addChild(t.frontEar)) : t.objType === r.ObjectsType.ARENA ? (t.graphic.x = -299, this.matchPreloader.x = -299, this.back.addChild(t.graphic)) : t.objType === r.ObjectsType.EFFECTS ? this.effects.addChild(t.graphic) : t.objType === r.ObjectsType.INFO && (p.MainGameCore.instance.messageInfo = t, this.frontObjects.addChild(t.graphic))
        }, g.prototype.startMatch = function() {
            this.infoPanel = new c.InfoPanelGUI, this.gui.addChild(this.infoPanel), this.timer = new u.TimerObject, this.gui.addChild(this.timer)
        }, g.prototype.shake = function(t) {
            1 === t ? this.shakeContainer(this.gameObjects, 10) : 7 !== t && 8 !== t || this.shakeContainer(this.gameObjects, 25)
        }, g.prototype.resize = function() {
            a.prototype.resize.call(this);
            var t = this.game.width / l.default.GAME_W;
            this.gameObjects.x = this.game.width / 2 - l.default.DISPLAY_W2 * t, this.gui.x = this.game.width / 2 - l.default.DISPLAY_W2 * t, this.gamePadLayer.x = this.game.width / 2 - l.default.DISPLAY_W2 * t
        }, g.prototype.release = function() {
            this.gameObjects = null, this.gamePadLayer = null, this.back = null, this.shadows = null, this.players = null, this.ball = null, this.effects = null, this.frontObjects = null, this.gui = null, this.infoPanel = null, this.timer = null, a.prototype.release.call(this)
        }, g);

    function g(t) {
        t = a.call(this, t) || this;
        return t.gameObjects = new d.Group(t.game), t.gameObjects.interactive = !1, t.back = new d.Group(t.game, t.gameObjects, "back_container"), t.shadows = new d.Group(t.game, t.gameObjects), t.players = new d.Group(t.game, t.gameObjects), t.effects = new d.Group(t.game, t.gameObjects), t.ball = new d.Group(t.game, t.gameObjects), t.frontObjects = new d.Group(t.game, t.gameObjects), t.gui = new d.Group(t.game), t.gamePadLayer = new d.Group(t.game), t.matchPreloader = new f.MatchPreloader, h.default.instance.init(t.gamePadLayer, t.game), t
    }
    e.MainGameView = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(10),
        h = i(1),
        l = i(4),
        n = (a = Phaser.Group, n(c, a), c.prototype.start = function(t, e, i) {
            this.emblem1.loadTexture(h.Atlases.Interface, "Emblems00" + (t[0] - 1 < 10 ? "0" : "") + (t[0] - 1)), this.emblem2.loadTexture(h.Atlases.Interface, "Emblems00" + (t[1] - 1 < 10 ? "0" : "") + (t[1] - 1)), this.score1.text = e.toString(), this.score2.text = i.toString()
        }, c.prototype.updateScore = function(t, e) {
            this.score1.text = t.toString(), this.score2.text = e.toString()
        }, c);

    function c() {
        var t = a.call(this, o.default.game) || this;
        t.emblem1 = null, t.emblem2 = null, t.score1 = null, t.score2 = null, t.x = l.default.GAME_W2, t.y = 60;
        var e = t.game.add.sprite(0, -6, h.Atlases.Gameplay, "infoPanel0000");
        e.anchor.set(.5), t.addChild(e), t.emblem1 = t.game.add.image(-101, -18, h.Atlases.Gameplay, "bg0000"), t.emblem2 = t.game.add.image(103, -18, h.Atlases.Gameplay, "bg0000"), t.emblem1.anchor.set(.5), t.emblem2.anchor.set(.5), t.emblem1.scale.set(.25), t.emblem2.scale.set(.25);
        e = {
            font: "46px CfCrackBold",
            fill: "#FF9900"
        };
        return t.score1 = new r.default(t.game, -10, 5, "", e), t.score1.anchor.set(1, 1), t.score1.stroke = "#000000", t.score1.strokeThickness = 2, t.addChild(t.score1), t.score2 = new r.default(t.game, 14, 5, "", e), t.score2.anchor.set(0, 1), t.score2.stroke = "#000000", t.score2.strokeThickness = 2, t.addChild(t.score2), t.addChild(t.emblem1), t.addChild(t.emblem2), t
    }
    e.InfoPanelGUI = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(0),
        r = i(3),
        n = (a = o.Graphics, n(h, a), h.prototype.setCallBacks = function(t, e, i) {
            null === this.callBackOnShow && (this.callBackOnShow = t, this.callBackOnHide = e, this.contextForAll = i)
        }, h.prototype.setTime = function(t) {
            this.time = t
        }, h.prototype.show = function() {
            this.alpha = 0;
            var t = r.default.game.add.tween(this);
            t.onComplete.add(this.callBackOnShow, this.contextForAll), t.to({
                alpha: 1
            }, this.time, o.Easing.Linear.None, !1, this.time).start()
        }, h.prototype.hide = function() {
            this.alpha = 1;
            var t = r.default.game.add.tween(this);
            t.onComplete.add(this.callBackOnHide, this.contextForAll), t.to({
                alpha: 0
            }, this.time).start()
        }, h);

    function h() {
        var t = a.call(this, r.default.game) || this;
        return t.beginFill(0), t.drawRect(0, 0, 1398, 480), t.endFill(), t.alpha = 0, t.callBackOnShow = null, t.callBackOnHide = null, t.contextForAll = null, t
    }
    e.MatchPreloader = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (Object.defineProperty(n.prototype, "matchMode", {
        get: function() {
            return this._matchMode
        },
        set: function(t) {
            this._matchMode = t
        },
        enumerable: !0,
        configurable: !0
    }), n.prototype.resetData = function() {
        this.teams = [], this.players = [
            [],
            []
        ]
    }, n.prototype.resetPartly = function() {
        this.matchMode = 0, this.pb = [
            [],
            []
        ], this.skills = [
            [],
            []
        ], this.forms = [0, 1], this.matchScore = [0, 0]
    }, n.prototype.resetAll = function() {
        this.resetData(), this.resetPartly()
    }, n.prototype.baseInit = function() {
        this.matchMode = 0, this.teams = [this.firstTeam, 2], this.players = [
            [0],
            [0]
        ]
    }, n.prototype.resetScore = function() {
        this.matchScore = [0, 0]
    }, n.prototype.startQuickMatch = function() {
        this.resetAll();
        var t = 1 + 16 * Math.random() >> 0,
            e = 1 + 16 * Math.random() >> 0;
        t === e && (16 === e ? e-- : e++), this.teams = [t, e], this.players[0][0] = Math.random() <= .5 ? 0 : 1, this.players[1][0] = Math.random() <= .5 ? 0 : 1, this.pb = [
            ["P0"],
            ["B0"]
        ], this.skills = [
            [0],
            [2]
        ]
    }, n.prototype.startTraining = function() {
        this.resetAll(), this.teams[0] = 1 + 16 * Math.random() >> 0, this.teams[1] = this.teams[0], this.players[0] = [Math.random() <= .5 ? 0 : 1], this.players[1] = [], this.pb = [
            ["P0"]
        ], this.skills = [
            [0]
        ], this.rndForms()
    }, n.prototype.startRandomMatch = function() {
        0 === this.matchMode ? (this.pb = [
            ["P0"],
            ["B0"]
        ], this.skills = [
            [0],
            [3]
        ]) : (this.fill2ndPlayers(), this.pb = [
            ["P0", "B2"],
            ["B1", "B2"]
        ], this.skills = [
            [0, 3],
            [3, 3]
        ]), this.rndForms()
    }, n.prototype.startPlayers2Match = function() {
        var t, e;
        0 === this.matchMode ? (t = this.players[0][0], e = this.players[1][0], this.players = [
            [t],
            [e]
        ], this.pb = [
            ["P1"],
            ["P2"]
        ], this.skills = [
            [0],
            [0]
        ]) : 1 === this.matchMode ? (this.fill2ndPlayers(), this.pb = [
            ["P1", "B2"],
            ["P2", "B2"]
        ], this.skills = [
            [0, 4],
            [0, 4]
        ]) : (this.fill2ndPlayers(), this.pb = [
            ["P1", "P2"],
            ["B1", "B2"]
        ], this.skills = [
            [0, 0],
            [4, 4]
        ]), this.rndForms()
    }, n.prototype.fill2ndPlayers = function() {
        2 === this.players[0].length ? this.players[0][1] = 0 === this.players[0][0] ? 1 : 0 : this.players[0].push(0 === this.players[0][0] ? 1 : 0), 2 === this.players[1].length ? this.players[1][1] = 0 === this.players[1][0] ? 1 : 0 : this.players[1].push(0 === this.players[1][0] ? 1 : 0)
    }, n.prototype.startTournamentMatch = function(t) {
        this.resetAll(), this.matchMode = t.mode, this.teams = [t.team, t.opponent], this.players[0][0] = t.player, this.players[1][0] = Math.random() <= .5 ? 0 : 1;
        var e = 4 * t.difficulty + t.state + 1;
        t.isThirdPlaceMatch() && e--, 0 === this.matchMode ? (this.pb = [
            ["P0"],
            ["B0"]
        ], this.skills = [
            [0],
            [e]
        ]) : (this.players[0][1] = 0 == this.players[0][0] ? 1 : 0, this.players[1][1] = 0 == this.players[1][0] ? 1 : 0, this.pb = [
            ["P0", "B2"],
            ["B1", "B2"]
        ], this.skills = [
            [0, 4],
            [e, e]
        ]), this.rndForms()
    }, n.prototype.finishMatch = function(t) {
        2 === t || 3 === t ? this.baseInit() : (this.cutPlayers(0), this.cutPlayers(1)), this.resetPartly()
    }, n.prototype.cutPlayers = function(t) {
        2 === this.players[t].length && this.players[t].pop()
    }, n.prototype.rndForms = function() {
        this.forms = [0, 1]
    }, n.prototype.whoWins = function() {
        return this.matchScore[0] > this.matchScore[1] ? -1 : this.matchScore[0] < this.matchScore[1] ? 1 : 0
    }, n);

    function n(t) {
        this.restarted = !1, this.firstTeam = t ? 1 : 17, this.baseInit(), this.resetPartly()
    }
    e.MatchData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (Object.defineProperty(n.prototype, "state", {
        get: function() {
            return this.obj.state
        },
        set: function(t) {
            this.obj.state = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "difficulty", {
        get: function() {
            return this.obj.difficulty
        },
        set: function(t) {
            this.obj.difficulty = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "mode", {
        get: function() {
            return this.obj.mode
        },
        set: function(t) {
            this.obj.mode = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "scores", {
        get: function() {
            return this.obj.scores
        },
        set: function(t) {
            this.obj.scores = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "team", {
        get: function() {
            return this.obj.team
        },
        set: function(t) {
            this.obj.team = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "player", {
        get: function() {
            return this.obj.player
        },
        set: function(t) {
            this.obj.player = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "teamRound", {
        get: function() {
            return this.obj.teamRound
        },
        set: function(t) {
            this.obj.teamRound = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "posOfTeam", {
        get: function() {
            return this.obj.posOfTeam
        },
        set: function(t) {
            this.obj.posOfTeam = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "opponent", {
        get: function() {
            return this.obj.opponent
        },
        set: function(t) {
            this.obj.opponent = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "rounds", {
        get: function() {
            return this.obj.rounds
        },
        set: function(t) {
            this.obj.rounds = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "results", {
        get: function() {
            return this.obj.results
        },
        set: function(t) {
            this.obj.results = t
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(n.prototype, "points", {
        get: function() {
            return this.obj.points
        },
        set: function(t) {
            this.obj.points = t
        },
        enumerable: !0,
        configurable: !0
    }), n.prototype.resetAll = function() {
        this.state = -1, this.mode = 0, this.scores = 0, this.team = 0, this.difficulty = 0, this.player = 0, this.teamRound = 0, this.posOfTeam = [0, 1], this.opponent = 0, this.rounds = [], this.results = [], this.points = 0
    }, n.prototype.createNewTournament = function(t) {
        this.resetAll(), this.team = t.teams[0], this.player = t.players[0][0], this.mode = t.matchMode, this.rounds = [];
        for (var e = [], i = 0; i < 16; i++) e[i] = i + 1;
        if (this.swapTeams(e, 0), this.swapTeams(e, 8), 16 < this.team)
            for (var s = Math.random() <= .5 ? 8 : 16, n = 0; n < 16; n++)
                if (e[n] === s) {
                    e[n] = 17;
                    break
                }
        for (var a = 0; a < e.length / 2; a++) this.rounds[a] = [e[2 * a], e[2 * a + 1]], e[2 * a] !== this.team && e[2 * a + 1] !== this.team || (this.teamRound = a);
        this.results = [], this.state = 0, this.scores = 0, this.defineOpponent()
    }, n.prototype.swapTeams = function(t, e) {
        for (var i = e + 8, s = e; s < i; s++) {
            var n = e + 8 * Math.random() >> 0,
                a = t[s];
            t[s] = t[n], t[n] = a
        }
    }, n.prototype.defineOpponent = function() {
        this.posOfTeam = this.rounds[this.teamRound][0] === this.team ? [0, 1] : [1, 0], this.opponent = this.rounds[this.teamRound][this.posOfTeam[1]]
    }, n.prototype.generateResults = function(t, e, i, s) {
        void 0 === s && (s = null);
        for (var n = !0, a = 0; a < e - t; a++) {
            var o = a + t,
                r = e + (a / 2 >> 0);
            this.rounds.length === r && this.rounds.push([]);
            var h = a % 2,
                l = void 0,
                c = void 0;
            o === this.teamRound ? (this.rounds[o][0] === this.team ? this.results[o] = [s[0], s[1]] : this.rounds[o][1] === this.team && (this.results[o] = [s[1], s[0]]), s[0] > s[1] ? (l = this.posOfTeam[0], c = this.posOfTeam[1], n = !0, this.teamRound = r) : (l = this.posOfTeam[1], c = this.posOfTeam[0], (n = i) && (this.teamRound = r + 1))) : (c = Math.random() <= .5 ? (l = 0, 1) : (l = 1, 0), this.generateMatchScore(l, c, o)), this.rounds[r][h] = this.rounds[o][l], i && (this.rounds.length === r + 1 && this.rounds.push([]), this.rounds[r + 1][h] = this.rounds[o][c])
        }
        return n
    }, n.prototype.generateMatchScore = function(t, e, i) {
        var s = [0, 0],
            n = 30 + 20 * Math.random() >> 0,
            a = n - (1 + 10 * Math.random() >> 0);
        s[t] = n, s[e] = a, this.results[i] = s
    }, n.prototype.getFinalistsArray = function() {
        var t = [],
            e = this.getPlace();
        return t.push(this.rounds[16][0], this.rounds[17][0], this.rounds[16][1]), 3 < e && t.push(this.team), t.push(e), t
    }, n.prototype.getPlace = function() {
        var t = 5;
        return this.team === this.rounds[16][0] ? t = 1 : this.team === this.rounds[17][0] ? t = 2 : this.team === this.rounds[16][1] ? t = 3 : this.team === this.rounds[17][1] && (t = 4), t
    }, n.prototype.isSecondPlace = function() {
        return !!this.rounds[17] && this.team === this.rounds[17][0]
    }, n.prototype.isThirdPlaceMatch = function() {
        return 3 === this.state && (this.team === this.rounds[15][0] || this.team === this.rounds[15][1])
    }, n.prototype.setValues = function(t) {
        for (var e in t) this.obj.hasOwnProperty(e) && (this.obj[e] = t[e])
    }, n.prototype.getValues = function() {
        var t, e = {};
        for (t in this.obj) this.obj.hasOwnProperty(t) && (e[t] = this.obj[t]);
        return e
    }, n);

    function n() {
        this.obj = {}, this.resetAll()
    }
    e.TournamentData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (o.calcScores = function(t, e, i, s) {
        var n = 50 < t[0] ? 50 : t[0],
            a = n - t[1],
            t = o.winKoef;
        a < 0 && (a = 0, t = s ? o.winKoef : o.lostKoef);
        a = o.stateKoef * e + t + o.pointKoef * n + o.diffKoef * a;
        return 1 == i && (a *= o.hardKoef), a
    }, o.stateKoef = 1e3, o.winKoef = 1e3, o.lostKoef = 500, o.pointKoef = 100, o.diffKoef = 30, o.hardKoef = 1.5, o);

    function o() {}
    e.ScoresCalculator = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(41),
        r = i(4),
        h = i(73),
        n = (a = o.BaseDataManager, n(l, a), l.prototype.getValuesForRead = function() {
            return this.baseData.getValuesForRead()
        }, l.prototype.updateData = function(t, e) {
            void 0 === e && (e = 0), 1 === this.values[t] || t < 11 && !(e >= this.limits[t]) || this.setAchievement(t)
        }, l.prototype.setAchievement = function(t) {
            this.values[t] = 1, this.saveData()
        }, l);

    function l(t, e, i) {
        var s = a.call(this) || this;
        return s.baseData = new h.AchievsData, s.limits = r.default.LIMITS_FOR_ACHIEVS, s.init(t, e, i), s
    }
    e.AchievsDataManager = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(42),
        n = (a = i.BaseData, n(o, a), o.prototype.checkAchievement = function(t) {
            0 === this.values[t] && (this.values[t] = 1)
        }, o.prototype.getValuesForRead = function() {
            return this.values
        }, o);

    function o() {
        var t = a.call(this) || this;
        return t.names = ["points3", "dunks", "fromBlock", "buzzer", "blocks", "steals", "scores", "pointsM", "pointsMH", "pointsT", "pointsTH", "idNet", "forum", "GC1", "SC1", "BC1", "GC2", "SC2", "BC2", "GC1H", "GC2H"], t.count = 21, t.createEmpty(), t
    }
    e.AchievsData = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(41),
        r = i(75),
        n = (a = o.BaseDataManager, n(h, a), h.prototype.updateData = function(t, e) {
            void 0 === e && (e = 0), 6 === t ? this.incScore() : (0 === t ? this.incScore(3) : t < 4 && this.incScore(), this.values[t]++, this.achievsMgr.updateData(t, this.values[t])), this.saveData()
        }, h.prototype.updateScore = function(t, e) {
            e = this.scoresNo + e;
            t > this.values[e] && (this.values[e] = t, this.saveData())
        }, h.prototype.getTotalScores = function() {
            return this.values[this.scoresNo] + this.values[this.scoresNo + 1]
        }, h.prototype.incScore = function(t) {
            void 0 === t && (t = 2), this.values[6] += t, this.achievsMgr.updateData(6, this.values[6])
        }, h);

    function h(t, e, i, s) {
        var n = a.call(this) || this;
        return n.baseData = new r.StatsData, n.achievsMgr = s, n.init(t, e, i), n.scoresNo = n.values.length - 2, n
    }
    e.StatsDataManager = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(42),
        n = (a = i.BaseData, n(o, a), o);

    function o() {
        var t = a.call(this) || this;
        return t.names = ["points3", "dunks", "fromBlock", "buzzer", "blocks", "steals", "scores", "scores1", "scores2"], t.count = 9, t.createEmpty(), t
    }
    e.StatsData = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = nape.space.Space,
        r = i(28),
        h = i(23),
        l = i(29),
        n = (a = r.GamePhysics, n(c, a), c.prototype.update = function(t) {
            c.space.step(.9 * t), this.updateGraphics()
        }, c.prototype.updateGraphics = function() {
            for (var t = c.space.liveBodies.iterator(); t.hasNext();) {
                var e = t.next(),
                    i = e.userData;
                i.graphic && ((i = i.graphic).x = e.position.x, i.y = e.position.y, i.rotation = e.rotation % (2 * Math.PI))
            }
        }, c.prototype.add = function(t) {
            t.body && (t.body.space = c.space)
        }, c.prototype.release = function() {
            for (; !c.space.bodies.empty();) h.NapeUtil.disposeBody(c.space.bodies.at(0));
            a.prototype.release.call(this), c.space.clear(), c.space = null
        }, c);

    function c() {
        var t = a.call(this) || this;
        return c.space = new o(l.ObjectsData.GRAVITY), c.space.worldLinearDrag = 0, t
    }
    e.Physics2 = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = nape.geom.Vec2,
        r = nape.phys.Body,
        h = nape.phys.BodyType,
        l = nape.shape.Polygon,
        c = i(2),
        u = i(1),
        d = i(3),
        n = (a = c.GameObject, n(p, a), p.prototype.create = function() {
            this.createBody(), this.createGraphic()
        }, p.prototype.createBody = function() {
            this.body = new r(h.STATIC, o.get(0, 0));
            var t = new l(l.rect(-50, 420, 900, 60), c.Materials.FlOOR, c.Filters.ARENA);
            t.cbTypes.add(c.CbTypes.cbGround), this.body.shapes.add(t);
            t = new l(l.rect(0, -800, 5, 1300), c.Materials.FlOOR, c.Filters.BORDER);
            t.cbTypes.add(c.CbTypes.cbBorders), this.body.shapes.add(t);
            t = new l(l.rect(795, -800, 5, 1300), c.Materials.FlOOR, c.Filters.BORDER);
            t.cbTypes.add(c.CbTypes.cbBorders), this.body.shapes.add(t);
            t = new l(l.rect(-80, -800, 40, 1300), c.Materials.FlOOR, c.Filters.ARENA);
            t.cbTypes.add(c.CbTypes.cbBorders), this.body.shapes.add(t);
            t = new l(l.rect(840, -800, 5, 1300), c.Materials.FlOOR, c.Filters.ARENA);
            t.cbTypes.add(c.CbTypes.cbBorders), this.body.shapes.add(t)
        }, p.prototype.createGraphic = function() {
            var t = new Phaser.Group(d.default.game),
                e = new Phaser.Image(d.default.game, 0, 0, u.Atlases.Gameplay, "0bg_gameplay0000");
            t.addChild(e), this.graphic = t
        }, p.rndPart = function() {
            return 1 + 6 * Math.random() >> 0
        }, p.prototype.setLogo = function(t) {}, p);

    function p() {
        var t = a.call(this) || this;
        return t.objType = c.ObjectsType.ARENA, t.create(), t.add(), t
    }
    e.ArenaObject = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, c = i(2),
        o = i(0),
        u = nape.geom.Vec2,
        r = nape.phys.Body,
        h = nape.phys.BodyType,
        d = nape.constraint.PivotJoint,
        p = nape.constraint.DistanceJoint,
        l = nape.shape.Polygon,
        f = i(22),
        g = i(3),
        m = i(1),
        n = (a = c.GameObject, n(y, a), y.prototype.showEar = function() {
            this.frontEar.alpha = 1, g.default.game.add.tween(this.frontEar).from({
                alpha: 0
            }, 500).start()
        }, y.prototype.hideEar = function() {
            g.default.game.add.tween(this.frontEar).to({
                alpha: 0
            }, 500).start()
        }, y.prototype.createGlass = function() {
            this.body = new r(h.STATIC, u.weak(this.center, this.height)), this.glass = new l(l.rect(this.glassPos, c.ObjectsData.GLASS_Y, c.ObjectsData.GLASS_WIDTH, c.ObjectsData.GLASS_HEIGHT), c.Materials.GLASS, c.Filters.BASKET), this.glass.cbTypes.add(c.CbTypes.cbBasket), this.body.shapes.add(this.glass), this.body.userData.side = this.side
        }, y.prototype.createRing = function() {
            this.leftPart = c.NapeUtil.createCircleBody(h.STATIC, c.Filters.BASKET, !1, this.partRadius, this.leftPoint, this.height, 0, c.CbTypes.cbRing, c.Materials.BASKET), this.leftPart.space = this.theSpace, this.rightPart = c.NapeUtil.createCircleBody(h.STATIC, c.Filters.BASKET, !1, this.partRadius, this.rightPoint, this.height, 0, c.CbTypes.cbRing, c.Materials.BASKET), this.rightPart.space = this.theSpace, this.centerPart = c.NapeUtil.createCircleBody(h.STATIC, c.Filters.BASKET, !0, this.partRadius, this.center, this.height, 0, c.CbTypes.cbRing, c.Materials.BASKET), this.centerPart.space = this.theSpace, this.upperSensor = new l(l.rect(-c.ObjectsData.SENSOR_HALF, c.ObjectsData.SENSOR_UP, c.ObjectsData.SENSOR_WIDTH, c.ObjectsData.SENSOR_HEIGHT), null, c.Filters.BASKET), this.upperSensor.sensorEnabled = !0, this.upperSensor.cbTypes.add(c.CbTypes.cbUpperSensor), this.body.shapes.add(this.upperSensor), this.downSensor = new l(l.rect(-c.ObjectsData.SENSOR_HALF, c.ObjectsData.SENSOR_DOWN, c.ObjectsData.SENSOR_WIDTH, c.ObjectsData.SENSOR_HEIGHT), null, c.Filters.BASKET), this.downSensor.sensorEnabled = !0, this.downSensor.cbTypes.add(c.CbTypes.cbDownSensor), this.body.shapes.add(this.downSensor)
        }, y.prototype.createNet = function() {
            var t = this.leftPoint + 2,
                e = this.rightPoint - 2,
                i = this.height + 3,
                s = new u(t, i),
                n = new u(this.center, i),
                a = new u(e, i),
                o = new u(t, i + 14),
                r = new u(this.center, i + 12),
                h = new u(e, i + 14),
                l = new u(t, i + 32),
                t = new u(this.center, i + 30),
                i = new u(e, i + 32);
            this.body1 = this.createBody(s.x, (s.y + o.y) / 2, c.Filters.NET_COLLIDE), this.body2 = this.createBody(o.x, (o.y + l.y) / 2, c.Filters.NET_COLLIDE), this.body3 = this.createBody(a.x, (a.y + h.y) / 2, c.Filters.NET_COLLIDE), this.body4 = this.createBody(h.x, (h.y + i.y) / 2, c.Filters.NET_COLLIDE), this.body5 = this.createBody(n.x, (n.y + r.y) / 2, c.Filters.NET_NOT_COLLIDE), this.body6 = this.createBody(r.x, (r.y + t.y) / 2, c.Filters.NET_NOT_COLLIDE), this.body7 = this.createBody(l.x, l.y + 4, c.Filters.NET_NOT_COLLIDE), this.body8 = this.createBody(i.x, i.y + 4, c.Filters.NET_NOT_COLLIDE), this.body9 = this.createBody(t.x, t.y + 4, c.Filters.NET_NOT_COLLIDE), this.pivotJoint1 = new d(this.body1, this.leftPart, this.body1.worldPointToLocal(s), this.leftPart.worldPointToLocal(s)), this.pivotJoint2 = new d(this.body1, this.body2, this.body1.worldPointToLocal(o), this.body2.worldPointToLocal(o)), this.addPivotJoint(this.pivotJoint1), this.addPivotJoint(this.pivotJoint2), this.pivotJoint3 = new d(this.body3, this.rightPart, this.body3.worldPointToLocal(a), this.rightPart.worldPointToLocal(a)), this.pivotJoint4 = new d(this.body3, this.body4, this.body3.worldPointToLocal(h), this.body4.worldPointToLocal(h)), this.addPivotJoint(this.pivotJoint3), this.addPivotJoint(this.pivotJoint4), this.pivotJoint5 = new d(this.body5, this.centerPart, this.body5.worldPointToLocal(n), this.centerPart.worldPointToLocal(n)), this.pivotJoint6 = new d(this.body5, this.body6, this.body5.worldPointToLocal(r), this.body6.worldPointToLocal(r)), this.addPivotJoint(this.pivotJoint5), this.addPivotJoint(this.pivotJoint6), this.pivotJoint7 = new d(this.body2, this.body7, this.body2.worldPointToLocal(l), this.body7.worldPointToLocal(l)), this.addPivotJoint(this.pivotJoint7), this.pivotJoint8 = new d(this.body4, this.body8, this.body4.worldPointToLocal(i), this.body8.worldPointToLocal(i)), this.addPivotJoint(this.pivotJoint8), this.pivotJoint9 = new d(this.body6, this.body9, this.body6.worldPointToLocal(t), this.body9.worldPointToLocal(t)), this.addPivotJoint(this.pivotJoint9), this.distJoint1 = new p(this.body1, this.body5, this.body1.worldPointToLocal(o), this.body5.worldPointToLocal(r), 14, 14), this.distJoint2 = new p(this.body3, this.body5, this.body3.worldPointToLocal(h), this.body5.worldPointToLocal(r), 14, 14), this.addDistanceJoint(this.distJoint1), this.addDistanceJoint(this.distJoint2), this.distJoint3 = new p(this.body2, this.body6, this.body2.worldPointToLocal(l), this.body6.worldPointToLocal(t), 13, 13), this.distJoint4 = new p(this.body6, this.body4, this.body6.worldPointToLocal(t), this.body4.worldPointToLocal(i), 13, 13), this.addDistanceJoint(this.distJoint3), this.addDistanceJoint(this.distJoint4)
        }, y.prototype.createBody = function(t, e, i) {
            e = new r(h.DYNAMIC, new u(t, e)), i = new l(l.box(2, 14), c.Materials.NET, i);
            return e.shapes.add(i), e.space = this.theSpace, e
        }, y.prototype.addPivotJoint = function(t) {
            t.ignore = !0, t.space = this.theSpace
        }, y.prototype.addDistanceJoint = function(t) {
            t.stiff = !1, t.frequency = 4, t.ignore = !0, t.space = this.theSpace
        }, y.prototype.dampNet = function(t) {
            this.updateBodyDampening(this.body1, t), this.updateBodyDampening(this.body2, t), this.updateBodyDampening(this.body3, t), this.updateBodyDampening(this.body4, t), this.updateBodyDampening(this.body5, t), this.updateBodyDampening(this.body6, t), this.updateBodyDampening(this.body7, t), this.updateBodyDampening(this.body8, t), this.updateBodyDampening(this.body9, t)
        }, y.prototype.updateBodyDampening = function(t, e) {
            t.velocity.muleq(Math.pow(.2, e)), t.angularVel *= Math.pow(.2, e)
        }, y.prototype.createGraphic = function() {
            this.graphic = new Phaser.Group(g.default.game);
            var t = new o.Image(g.default.game, 0, 0, m.Atlases.Gameplay, "BasketGraphic0000");
            t.anchor.set(.64, .75), this.graphic.addChild(t);
            t = -1 === this.side ? 1 : -1;
            this.graphic.scale.set(t, 1), this.netSpritegraphics = new o.Graphics(g.default.game), this.netSpritegraphics.x = -this.center, this.netSpritegraphics.y = -this.height, this.updateGraphics(), this.frontEar = new o.Sprite(g.default.game, 0, 0, m.Atlases.Gameplay, "FrontEar0000"), this.frontEar.x = this.center, this.frontEar.y = this.height, this.frontEar.anchor.set(.5), this.frontEar.scale.set(t, 1), this.frontEar.addChildAt(this.netSpritegraphics, 0)
        }, y.prototype.updateGraphics = function() {
            this.netSpritegraphics.clear(), this.netSpritegraphics.beginFill(16777215), this.netSpritegraphics.lineStyle(2, 16777215);
            var t = this.pivotJoint1.body1.localPointToWorld(this.pivotJoint1.anchor1),
                e = this.pivotJoint2.body1.localPointToWorld(this.pivotJoint2.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint2.body1.localPointToWorld(this.pivotJoint2.anchor1), e = this.pivotJoint7.body1.localPointToWorld(this.pivotJoint7.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint3.body1.localPointToWorld(this.pivotJoint3.anchor1), e = this.pivotJoint4.body1.localPointToWorld(this.pivotJoint4.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint4.body1.localPointToWorld(this.pivotJoint4.anchor1), e = this.pivotJoint8.body1.localPointToWorld(this.pivotJoint8.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint5.body1.localPointToWorld(this.pivotJoint5.anchor1), e = this.pivotJoint6.body1.localPointToWorld(this.pivotJoint6.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint6.body1.localPointToWorld(this.pivotJoint6.anchor1), e = this.pivotJoint9.body1.localPointToWorld(this.pivotJoint9.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.distJoint1.body1.localPointToWorld(this.distJoint1.anchor1), e = this.distJoint1.body2.localPointToWorld(this.distJoint1.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.distJoint2.body1.localPointToWorld(this.distJoint2.anchor1), e = this.distJoint2.body2.localPointToWorld(this.distJoint2.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.distJoint3.body1.localPointToWorld(this.distJoint3.anchor1), e = this.distJoint3.body2.localPointToWorld(this.distJoint3.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.distJoint4.body1.localPointToWorld(this.distJoint4.anchor1), e = this.distJoint4.body2.localPointToWorld(this.distJoint4.anchor1);
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint7.body2.localPointToWorld(this.pivotJoint7.anchor2), e = this.pivotJoint7.body2.localPointToWorld(new u(0, 5));
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint9.body2.localPointToWorld(this.pivotJoint9.anchor2), e = this.pivotJoint9.body2.localPointToWorld(new u(0, 5));
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y);
            t = this.pivotJoint8.body2.localPointToWorld(this.pivotJoint8.anchor2), e = this.pivotJoint8.body2.localPointToWorld(new u(0, 5));
            this.netSpritegraphics.moveTo(t.x, t.y), this.netSpritegraphics.lineTo(e.x, e.y), this.netSpritegraphics.endFill()
        }, y.prototype.update = function(t) {
            void 0 === t && (t = 0), this.dampNet(t), this.updateGraphics()
        }, y.prototype.release = function() {
            this.glass = null, this.leftPart = null, this.rightPart = null, this.centerPart = null, this.body1 = null, this.body2 = null, this.body3 = null, this.body4 = null, this.body5 = null, this.body6 = null, this.body7 = null, this.body8 = null, this.body9 = null, this.pivotJoint1.space = null, this.pivotJoint1 = null, this.pivotJoint2.space = null, this.pivotJoint2 = null, this.pivotJoint3.space = null, this.pivotJoint3 = null, this.pivotJoint4.space = null, this.pivotJoint4 = null, this.pivotJoint5.space = null, this.pivotJoint5 = null, this.pivotJoint6.space = null, this.pivotJoint6 = null, this.pivotJoint7.space = null, this.pivotJoint7 = null, this.pivotJoint8.space = null, this.pivotJoint8 = null, this.pivotJoint9.space = null, this.pivotJoint9 = null, this.distJoint1.space = null, this.distJoint1 = null, this.distJoint2.space = null, this.distJoint2 = null, this.distJoint3.space = null, this.distJoint3 = null, this.distJoint4.space = null, this.distJoint4 = null, this.upperSensor = null, this.downSensor = null, this.theSpace = null, this.frontEar.removeChild(this.netSpritegraphics), this.netSpritegraphics = null, this.frontEar = null, a.prototype.release.call(this)
        }, y);

    function y(t) {
        var e = a.call(this) || this;
        return e.objType = c.ObjectsType.BASKET, e.side = t, e.radius = c.ObjectsData.BASKET_RADIUS, e.height = c.ObjectsData.BASKET_HEIGHT, e.partRadius = c.ObjectsData.BASKET_PART_RADIUS, -1 === t ? (e.center = c.ObjectsData.BASKET_CENTER, e.glassPos = -e.center) : (e.center = c.ObjectsData.BASKET_CENTER2, e.glassPos = c.ObjectsData.BASKET_CENTER - c.ObjectsData.GLASS_WIDTH), e.leftPoint = e.center - e.radius, e.rightPoint = e.center + e.radius, e.theSpace = f.NapePhysics.space, e.createGlass(), e.createRing(), e.createNet(), e.createGraphic(), a.prototype.add.call(e), e
    }
    e.BasketObject = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.callbacks.CbType,
        s = (n.cbBall = new s, n.cbPlayer = new s, n.cbPlayersHands = new s, n.cbPlayersBlock = new s, n.cbGround = new s, n.cbBorders = new s, n.cbBasket = new s, n.cbRing = new s, n.cbUpperSensor = new s, n.cbDownSensor = new s, n.cbMiddle = new s, n.cbNet = new s, n.cbPowerUp = new s, n.cbShield = new s, n.cbAlleyOop = new s, n);

    function n() {}
    e.CbTypes = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.dynamics.InteractionFilter,
        s = (n.BALL = new s(17, 4368), n.NET_COLLIDE = new s(17, 4368), n.NET_NOT_COLLIDE = new s(17, 4352), n.BASKET = new s(16, 4353), n.RAY = new s(16, 4352), n.ARENA = new s(4369, 4369), n.BORDER = new s(4369, 4352), n.PLAYER = new s(273, 4096, 4096), n.PLAYER_BLOCK = new s(273, 4369), n);

    function n() {}
    e.Filters = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.phys.Material,
        s = (n.FlOOR = new s(.4, 1, 1, .9, 3), n.BALL = new s(1, .6, .6, .7, 1), n.NET = new s(.1, 1, 1, 1), n.GLASS = new s(.5, 1, 1, 1), n.BASKET = new s(.35, 2, 2, 1), n.PLAYER = new s(0, 1, 1, 100, 0), n);

    function n() {}
    e.Materials = s
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var c, u = i(2),
        d = i(46),
        p = i(4),
        a = i(20),
        f = i(13),
        g = nape.geom.Vec2,
        o = nape.shape.Polygon,
        r = nape.phys.Body,
        h = nape.phys.BodyType,
        m = i(86),
        y = i(87),
        b = i(40),
        l = i(3),
        v = i(15),
        _ = i(5),
        x = i(1),
        w = i(14),
        P = i(24),
        n = (c = u.GameObject, n(T, c), T.prototype.createGraphic = function(t, e, i, s) {
            this.armature = s, this.armature.display.y = 35, this.armature.display.scale.set(.73), e = 0 === e ? 1 : 0, this.skinID = 2 * t - e - 1, u.PlayersData.switchPlayer(s, this.skinID, 2 * t - 2 + i), this.armature.display.addDBEventListener(dragonBones.EventObject.COMPLETE, this.onAnimationComplete, this), this.armature.display.addDBEventListener(dragonBones.EventObject.FRAME_EVENT, this.onFrameEvent, this), this.graphic = new Phaser.Group(l.default.game), this.graphic.addChild(this.armature.display), this.graphic.scale.x = -this.SIDE
        }, T.prototype.createBody = function() {
            this.body = new r(h.DYNAMIC, g.get(0, 0)), this.legs = new o(o.box(20, 70), u.Materials.PLAYER.copy(), u.Filters.PLAYER), this.legs.cbTypes.add(u.CbTypes.cbPlayer), this.body.shapes.add(this.legs);
            var t = new o(o.box(30, 80));
            t.sensorEnabled = !0, t.cbTypes.add(u.CbTypes.cbPlayersHands), this.body.shapes.add(t), this.block = new o(o.rect(-5, 0, 10, -70), u.Materials.BASKET, u.Filters.BASKET), this.block.cbTypes.add(u.CbTypes.cbPlayersBlock), this.blockBody = new o(o.box(20, 70), u.Materials.PLAYER, u.Filters.PLAYER_BLOCK), this.body.align(), this.baseMass = 3 * this.body.gravMass, this.blockMass = 2 * this.baseMass, this.body.gravMass = this.baseMass, this.body.allowRotation = !1, this.body.userData.graphic = this.graphic, (this.body.userData.owner = this).body.userData.direction = this.SIDE
        }, T.prototype.restart = function(t) {
            void 0 === t && (t = 0), this.resetVars(), this.removeBlock(), this.withBall = !1, 0 === t && (this.opponents = 1 === this.SIDE ? this.gamecore.playersLeft : this.gamecore.playersRight, this.mark = this.ball.body, 3 === this.superID && (this.teamMate = this.gamecore.getTeamMate(this.playerNo), this.dashOpponents = [])), this.unBlock(), this.controller.restart(t);
            var e = 0;
            0 === this.playerNo && (e = t === this.SIDE ? 1 : 0), this.body.position.set(this.indents[e]), this.body.velocity.setxy(0, 0), this.updateGraphic(), this.shadow.update(), this.graphic.scale.x = -this.SIDE, this.playState("idle"), this.dashDelay.activate()
        }, T.prototype.resetVars = function() {
            this.isRestart = !0, this.isUnderEmotion = !1, this.isGrounded = !0, this.canTakeInHands = !0, this.canDoAction = !0, this.needBlock = !1, this.isBlockedOrPump = !1, this.readyForDash = !1, this.canAct = !0, this.deltaDig = 0, this.isSuperShot = !1
        }, T.prototype.ballInHands = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.SIDE === t ? (this.playerNo === e && this.takeBallInHands(), this.controller.ballInOwnHands(e), this.mark = null, this.needBlock = !1) : (this.controller.ballInOpponentsHands(e), this.mark = this.opponents[e].body, this.needBlock = !0)
        }, T.prototype.ballShooting = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.SIDE === t ? (this.controller.ballOwnShoot(e), this.needBlock = !1) : (this.controller.ballOpponentShoot(e), this.needBlock = !0), this.mark = this.ball.body
        }, T.prototype.ballOthers = function() {
            this.controller.ballOthers(), this.mark = this.ball.body, this.needBlock = !1, this.removeBlock()
        }, T.prototype.jump = function(t) {
            t && this.isGrounded && "jump" !== this.state && (this.withBall ? this.makeJump("A") : this.makeJump())
        }, T.prototype.isUnderGlass = function() {
            var t = this.body.position.x;
            return -1 === this.SIDE ? 600 < t && t < 700 : 100 < t && t < 200
        }, T.prototype.makeJump = function(t) {
            var e;
            void 0 === t && (t = ""), e = ("" === t ? (this.attackJump = !1, this.needBlock && this.useBlock()) : (this.pointOfThrow = this.body.position.x, this.attackJump = !0, this.canThrow = !0), "fly1"), this.playState(e), this.playerSignal.dispatch("jump" + t, this.SIDE, this.playerNo), this.body.velocity.y = this.velY, this.isGrounded = !1
        }, T.prototype.makeSteal = function() {
            this.opponents && 0 !== this.opponents.length && (this.move(3), this.playerSignal.dispatch("startSteal", this.SIDE, this.playerNo), this.playState("steal"), _.default.getInstance().play(x.Sounds.p_swoosh), this.canAct = !1, this.canTakeInHands = !1)
        }, T.prototype.tryToSteal = function() {
            this.canDoAction = !1, this.playerSignal.dispatch("steal", this.SIDE, this.playerNo), this.gamecore.steal(this.SIDE, this.body.position.x, this.graphic.scale.x, this.isHuman)
        }, T.prototype.useBlock = function() {
            this.canTakeInHands = !1, this.body.shapes.add(this.block)
        }, T.prototype.removeBlock = function() {
            return !!this.body.shapes.has(this.block) && (this.body.shapes.remove(this.block), !0)
        }, T.prototype.checkToBeStolen = function(t, e, i) {
            void 0 === i && (i = !1);
            var s, n = -1;
            return this.isGrounded && (i = s = void 0, i = 1 === e ? (s = t) + this.stealDistance : (s = t - this.stealDistance, t), s <= (s = this.body.position.x) && s <= i && (n = Math.abs(s - t))), n
        }, T.prototype.getBeStolen = function(t, e) {
            void 0 === e && (e = !0);
            var i = this.withBall;
            return this.move(0), this.playState("stun"), _.default.getInstance().play(x.Sounds.p_stunned), this.canAct = !1, this.isBlockedOrPump && this.unBlock(), this.canTakeInHands = !1, this.withBall && (this.withBall = !1, e) && (t = 0 < (e = this.body.position.x - t) ? 1 : -1, this.ball.applySteal(this.body.position, Math.abs(e) / this.stealDistance, t)), this.playerSignal.dispatch("stun", this.SIDE, this.playerNo), i
        }, T.prototype.onGroundCollision = function() {
            this.isRestart ? this.isRestart = !1 : this.isUnderEmotion || "stun" === this.state ? (this.isGrounded = !0, this.canThrow = !0) : this.isSuperDash ? (this.isSuperDash = !1, this.playState("idle"), this.isGrounded = !0, this.canAct = !0) : (this.canAct = !1, this.move(0), this.withBall ? this.attackJump ? (this.makeThrow(), this.canTakeInHands = !0) : (this.canThrow = !0, this.controller.playerOnGround()) : (this.removeBlock(), this.controller.playerOnGround(), this.canTakeInHands = !0, this.canThrow = !0), this.isGrounded = !0, this.body.velocity.y = 0, this.playState("landing"))
        }, T.prototype.move = function(t) {
            var e; - 1 === t || 1 === t ? (this.legs.material.dynamicFriction = this.legs.material.staticFriction = 0, e = this.withBall ? this.velBallX : this.velX, this.body.velocity.x = t * e, this.isGrounded && this.checkRunState() && this.playState("run")) : (this.legs.material.dynamicFriction = this.baseFriction, this.legs.material.staticFriction = this.baseFriction, 0 === t ? this.isGrounded && this.checkIdleState() && this.checkDigState() ? this.playState("idle") : this.body.velocity.x *= .95 : 2 === t ? this.body.velocity.x = 0 : 3 === t ? (this.legs.material.dynamicFriction = .08, this.legs.material.staticFriction = .08) : 4 === t && (this.legs.material.dynamicFriction = this.baseFriction, this.legs.material.staticFriction = this.baseFriction, this.body.velocity.x = 0))
        }, T.prototype.action = function(t) {
            t && this.canDoAction && (this.withBall ? this.canThrow && (this.isGrounded ? this.makeFloorThrow() : this.makeThrow()) : this.isGrounded && this.makeSteal())
        }, T.prototype.makeFloorThrow = function() {
            this.move(2), this.canAct = !1, this.playState("throw_land")
        }, T.prototype.makeThrow = function() {
            this.withBall = !1, this.attackJump = !1, this.canDoAction = !1;
            var t, e = this.body.position.x,
                i = this.body.position.y;
            e >= this.paintStartX && e <= this.paintMiddleX && i <= this.dunkStart1Y ? this.makeDunk(1 + Math.round(2 * Math.random())) : (e - this.paintStartX) * this.SIDE < 0 && i <= this.dunkStart2Y ? this.makeDunk(1) : (t = 35, this.isGrounded ? (this.pointOfThrow = this.body.position.x, t = 20) : this.playState("fly1"), this.canTakeInHands = this.isGrounded, this.ball.shoot(this.SIDE, e - this.SIDE * t, i - 50, this.body.velocity.x, this.accuracy));
            i = 0 <= (this.pointOfThrow - this.threePointDistance) * this.SIDE ? 0 : 6;
            this.matchProcessor.shoot(this.SIDE, this.isHuman, i)
        }, T.prototype.removeFromPhysics = function() {
            this.canAct = !1, this.body.velocity.setxy(0, 0), this.body.space = null
        }, T.prototype.returnToPhysics = function(t) {
            void 0 === t && (t = null), t ? this.body.position.set(t) : this.body.position.setxy(this.dunkX, this.dunkY), this.body.space = this.theSpace, this.canTakeInHands = !1
        }, T.prototype.makeDunk = function(t) {
            this.removeFromPhysics();
            var e = "dunk" + t.toString(),
                i = 520;
            2 == t ? i = 350 : 3 == t && (i = 480), this.playState(e), l.default.game.add.tween(this.graphic).to({
                x: this.dunkX,
                y: this.dunkY
            }, i / 1.3333).start()
        }, T.prototype.endDunk = function() {
            var t = this.ball.dunk(this.SIDE, this.chanceToCompleteDunk),
                e = t ? 1 : 9;
            this.matchProcessor.shoot(this.SIDE, this.isHuman, e), this.isHuman || t || v.Signals.EventSignal.dispatch(!1, 9), this.returnToPhysics()
        }, T.prototype.superShot = function(t) {
            var e = !1;
            return t && this.readyForSuper && !this.gamecore.isSuperShot && (0 === this.superID ? this.withBall && (this.startSuper(), this.makeMegaDunk(), e = !0) : 1 === this.superID ? (this.startSuper(), this.makeShield(), e = !0) : 2 === this.superID ? this.withBall && (this.startSuper(), this.makeAlleyOop(), e = !0) : 3 === this.superID && (this.startSuper(), this.makeSuperDash(), e = !0)), e
        }, T.prototype.startSuper = function() {
            this.readyForSuper = !1, this.isSuperShot = !0, this.energyBar.reset(), this.gamecore.isSuperShot = !0
        }, T.prototype.endSuper = function() {
            this.isSuperShot = !1, this.gamecore.isSuperShot = !1
        }, T.prototype.makeAlleyOop = function() {
            this.controller instanceof u.AIController2 && this.playerID, this.canAct = !1, this.move(4), this.canTakeInHands = !1, this.graphic.scale.x = 0 < this.marker - this.body.position.x ? 1 : -1, this.isGrounded ? this.playState("throw_land") : this.startAlleyOop()
        }, T.prototype.startAlleyOop = function() {
            this.ball.alleyOop(this.SIDE, this.body.position.x - 20 * this.SIDE, this.body.position.y - 30, this), this.withBall = !1, this.isGrounded || this.playState("fly1")
        }, T.prototype.continueAlleyOop = function() {
            this.teleport.startPlay(this.body.position.x, this.body.position.y), _.default.getInstance().play(x.Sounds.p_teleport), this.removeFromPhysics();
            var t = l.default.game.add.tween(this.graphic.scale);
            t.onComplete.addOnce(this.endAlleyOop, this), t.to({
                x: 0,
                y: 0
            }, 400).start()
        }, T.prototype.endAlleyOop = function() {
            this.graphic.x = this.superDunkX, this.graphic.y = this.superDunkY, this.graphic.scale.x = -this.SIDE, this.graphic.scale.y = 1, this.graphic.visible = !0, this.armature.animation.gotoAndStopByFrame("pumpEnd", 0), this.teleport.startPlay(this.superDunkX, this.superDunkY), _.default.getInstance().play(x.Sounds.p_teleport), this.ball.removeFromPhysics();
            var t = l.default.game.add.tween(this.graphic.scale);
            t.onComplete.addOnce(this.continueSuperDunk, this), t.from({
                x: 0,
                y: 0
            }, 400).start()
        }, T.prototype.makeShield = function() {
            this.shield.activate(), this.endSuper()
        }, T.prototype.makeMegaDunk = function() {
            this.canAct = !1, this.graphic.scale.x = -this.SIDE;
            var t = a.default.dist(this.body.position.x, this.body.position.y, this.superDunkX, this.superDunkY);
            this.removeFromPhysics();
            var e = t / 700 / 1.3333;
            e < .3 && (e = .3), this.playState("megadunk"), _.default.getInstance().play(x.Sounds.p_megaStart);
            t = l.default.game.add.tween(this.graphic);
            t.onComplete.addOnce(this.continueSuperDunk, this), t.to({
                x: this.superDunkX,
                y: this.superDunkY
            }, 1e3 * e).start()
        }, T.prototype.continueSuperDunk = function() {
            this.playState("megadunk_end"), l.default.game.add.tween(this.graphic).to({
                x: this.superDunkEndX,
                y: this.superDunkEndY
            }, 100).start()
        }, T.prototype.endSuperDunk = function() {
            this.withBall = !1, this.ball.dunk(this.SIDE, 1);
            var t = 0 === this.superID ? 7 : 8;
            this.matchProcessor.shoot(this.SIDE, this.isHuman, t), this.returnToPhysics(), this.endSuper()
        }, T.prototype.makeSuperDash = function() {
            var t = -1;
            this.opponentsCount = this.opponents ? this.opponents.length : 0;
            for (var e = 0; e < this.opponentsCount; e++) this.opponents[e].withBall && (t = this.opponents[e].getX()), this.dashOpponents[e] = 0;
            t < 0 && (this.ball.isInGame() && (t = this.ball.getX()), this.teamMate ? (this.teamMate.withBall && (t = this.teamMate.getX()), this.dashTeammate = 1) : this.dashTeammate = -1);
            var i = this.body.position.x;
            this.withBall ? this.dashPoint = 0 : this.dashPoint = t < i ? 1 : 0, this.isSuperDash = !0, this.canAct = !1, this.attackJump = !1;
            var s = a.default.dist(i, this.body.position.y, this.superDashX[this.dashPoint], this.superDashY) / 600 / 1.3333;
            this.removeFromPhysics(), this.playState("md_start"), _.default.getInstance().play(x.Sounds.p_superDash), this.toRight = 0 === this.dashPoint;
            i = l.default.game.add.tween(this.graphic);
            i.onComplete.addOnce(this.continueSuperDash, this), i.onUpdateCallback(this.onSuperDashUpdate, this), i.to({
                x: this.superDashX[this.dashPoint],
                y: this.superDashY
            }, 1e3 * s).start()
        }, T.prototype.onSuperDashUpdate = function() {
            for (var t = this.graphic.x, e = 0; e < this.opponentsCount; e++) 0 === this.dashOpponents[e] && (this.toRight && t > this.opponents[e].getX() || !this.toRight && t < this.opponents[e].getX()) && (this.dashOpponents[e] = -1, this.opponents[e].getBeStolen(t, !1) && this.gamecore.ballInHands(this.SIDE, this.playerNo));
            this.withBall || (this.ball.isInGame() ? (this.toRight && t > this.ball.getX() || !this.toRight && t < this.ball.getX()) && (this.ball.takeInHands(this.SIDE, this.playerNo, !0), this.gamecore.ballInHands(this.SIDE, this.playerNo)) : 0 < this.dashTeammate && (this.toRight && t > this.teamMate.getX() || !this.toRight && t < this.teamMate.getX()) && (this.dashTeammate = 0, this.teamMate.withBall && (this.teamMate.freeBall(), this.gamecore.ballInHands(this.SIDE, this.playerNo))))
        }, T.prototype.continueSuperDash = function() {
            this.playState("md_end"), this.canThrow = !0, this.returnToPhysics(g.weak(this.superDashX[this.dashPoint], this.superDashY)), this.endSuper()
        }, T.prototype.takeBallInHands = function() {
            this.withBall = !0;
            var t = this.isUnderGlass();
            this.canThrow = t || this.isGrounded, t && (this.pointOfThrow = this.body.position.x), this.playState(this.state)
        }, T.prototype.freeBall = function() {
            return !!this.withBall && (this.withBall = !1, this.isGrounded ? this.playState("idle") : (this.canAct = !1, this.playState("fly1")), !0)
        }, T.prototype.setEmotion = function(t) {
            this.canTakeInHands = !1, this.isUnderEmotion = !0, this.move(2), this.withBall && (this.withBall = !1, this.ball.fromHands(this.body.position, this.graphic.scale.x)), this.SIDE === t ? this.emotionState = "happiness" : this.SIDE === -t ? this.emotionState = "sad" : this.emotionState = "idle", this.playState(this.emotionState), this.canAct = !1
        }, T.prototype.update = function(t) {
            var e;
            void 0 === t && (t = 0), "steal" === this.state || this.isSuperShot || (e = null === this.mark ? this.marker : this.mark.position.x, this.graphic.scale.x = 0 < e - this.body.position.x ? 1 : -1), this.canDoAction || (this.canDoAction = this.controller.readyForAction()), this.readyForDash || (this.readyForDash = 1 === this.dashDelay.update(t)), this.isUnderEmotion || (this.readyForSuper || this.isSuperShot || (this.readyForSuper = this.energyBar.update(t), this.readyForSuper && this.isHuman && _.default.getInstance().play(x.Sounds.p_energy)), this.canAct && (this.controller.update(t), this.isBlockedOrPump ? this.releaseBlockOrPump(this.controller.releaseBlockOrPump(t)) : (this.move(this.controller.currentMove), this.jump(this.controller.currentJump), this.action(this.controller.currentAction), this.makeDash(this.controller.currentDash), this.makeBlockOrPump(this.controller.currentBlockOrPump), this.superShot(this.controller.currentSuper), "idle" === this.state && "inHands" === this.ball.state ? (this.deltaDig += t, this.deltaDig >= this.delayDig && (this.deltaDig = 0, this.makeDig())) : this.deltaDig = 0)))
        }, T.prototype.makeDash = function(t) {
            0 !== t && this.readyForDash && this.isGrounded && (this.canAct = !1, this.playState("dash"), _.default.getInstance().play(x.Sounds.p_dash), this.playerSignal.dispatch("dash", this.SIDE, this.playerNo), this.legs.material.dynamicFriction = this.legs.material.staticFriction = 0, this.body.velocity.x = 1.7 * this.velX * t)
        }, T.prototype.endDash = function() {
            !this.isHuman && this.withBall && this.controller.playerOnDashEnd(), this.legs.material.dynamicFriction = this.legs.material.staticFriction = this.baseFriction, this.canAct = !0, this.readyForDash = !1, this.dashDelay.activate()
        }, T.prototype.makeBlockOrPump = function(t) {
            t && this.isGrounded && (this.move(2), this.canAct = !1, this.withBall ? (this.playState("pumpStart"), this.playerSignal.dispatch("pump", this.SIDE, this.playerNo)) : (this.canTakeInHands = !1, this.playState("blockStart")))
        }, T.prototype.setBlock = function() {
            this.canAct = !0, this.body.gravMass = this.blockMass, this.isBlockedOrPump = !0, this.body.shapes.add(this.blockBody), this.controller.playerOnBlock()
        }, T.prototype.releaseBlockOrPump = function(t) {
            t && (this.canAct = !1, this.withBall ? this.playState("pumpEnd") : (this.playState("blockEnd"), this.unBlock()))
        }, T.prototype.unBlock = function() {
            this.body.gravMass = this.baseMass, this.body.shapes.remove(this.blockBody), this.isBlockedOrPump = !1, this.canTakeInHands = !0
        }, T.prototype.release = function() {
            l.default.game.tweens.removeFrom(this.graphic), this.gamecore = null, this.matchProcessor = null, this.ball = null, this.opponents = null, this.teamMate = null, this.shadow = null, this.theSpace = null, this.energyBar = null, this.armature.display.removeDBEventListener(dragonBones.EventObject.COMPLETE, this.onAnimationComplete, this), this.armature.display.removeDBEventListener(dragonBones.EventObject.FRAME_EVENT, this.onFrameEvent, this), this.armature = null, this.controller.dispose(), this.controller = null;
            for (var t = this.indents.length, e = 0; e < t; e++) this.indents[e].dispose();
            this.indents.splice(0, t), this.indents = null, this.legs = null, this.block = null, this.blockBody = null, this.mark = null, this.teleport = null, this.shield = null, this.playerSignal = null, this.dashDelay = null, this.superDashX = null, this.dashOpponents = null, this.graphic = null, c.prototype.release.call(this)
        }, T.prototype.onAnimationComplete = function(t) {
            var e = t.animationState.name,
                t = "";
            "throw_land" === e || "blockEnd" === e || 0 <= e.indexOf("landing") ? (this.canAct = !this.isSuperShot, t = "idle") : "steal" === e || "stun" === e ? (this.canAct = !0, this.canTakeInHands = !0, t = "idle") : "megadunk_end" === e ? (this.canTakeInHands = !0, t = "idle") : 0 <= e.indexOf("dash") ? (t = "run", this.endDash()) : "blockStart" === e ? this.setBlock() : "pumpStart" === e ? (this.isBlockedOrPump = !0, this.canAct = !0) : "pumpEnd" === e ? (this.isBlockedOrPump = !1, this.canAct = !0, t = "idle") : 0 <= e.indexOf("dig") ? t = "idle" : 0 <= e.indexOf("md_start") ? t = "md_mid" : 0 <= e.indexOf("md_end") && (t = "idle"), 0 < t.length && this.playState(t)
        }, T.prototype.onFrameEvent = function(t) {
            t = t.name;
            "floor0" === t ? _.default.getInstance().play(x.Sounds.p_floorStand) : "floor" === t ? _.default.getInstance().play(x.Sounds.p_floorRun) : "action" === t ? this.tryToSteal() : "throw" === t ? this.isSuperShot ? this.startAlleyOop() : this.makeThrow() : "mega" === t ? this.endSuperDunk() : "dunk" === t && this.endDunk()
        }, T.prototype.playState = function(t) {
            var e = t,
                i = !1;
            this.withBall && ("idle" === t || "run" === t || "dash" === t || "landing" === t || 0 <= t.indexOf("fly") || 0 <= t.indexOf("md_")) ? (e = t + "_wb", this.wb || (i = !0), this.wb = !0) : this.wb = this.withBall, e !== this.state && (this.prevState = this.state, this.state = e, i ? this.armature.animation.gotoAndPlay(this.state, 0) : this.armature.animation.gotoAndPlay(this.state), !l.default.game.device.desktop && P.Inventory.instance.gameMode <= 2 && this.isHuman && (this.prevState.indexOf("_wb") < 0 && 0 < this.state.indexOf("_wb") && w.default.instance.btnDown.labelState.loadTexture(x.Atlases.Gameplay, "shoot_icon0000"), 0 < this.prevState.indexOf("_wb") && this.state.indexOf("_wb") < 0 && w.default.instance.btnDown.labelState.loadTexture(x.Atlases.Gameplay, "shoot_icon0001")))
        }, T.prototype.checkRunState = function() {
            return this.state.indexOf("run") < 0
        }, T.prototype.checkIdleState = function() {
            return this.state.indexOf("idle") < 0
        }, T.prototype.checkDigState = function() {
            return this.state.indexOf("dig") < 0
        }, T.prototype.isMoving = function() {
            return 200 < Math.abs(this.body.velocity.x)
        }, T.prototype.isReadyToDash = function() {
            return this.state.indexOf("dash") < 0 && this.readyForDash
        }, T.prototype.makeDig = function() {
            var t = 1 + Math.round(2 * Math.random());
            this.playState("dig" + t.toString())
        }, T);

    function T(t, e, i, s, n, a, o, r) {
        void 0 === o && (o = null), void 0 === r && (r = null);
        var h = c.call(this) || this;
        h.opponents = null, h.state = "", h.prevState = "", h.wb = !1, h.objType = u.ObjectsType.PLAYER, h.playerID = e, h.playerNo = n, h.SIDE = 0 === t ? -1 : 1;
        var l = p.default.WIDTH;
        h.velX = u.ObjectsData.PLAYER_MOVE, h.velBallX = u.ObjectsData.PLAYER_MOVE_WITH_BALL, h.velY = u.ObjectsData.PLAYER_JUMP, h.stealDistance = u.ObjectsData.STEAL_DISTANCE, h.delayDig = u.ObjectsData.DIG_TIME + Math.random(), h.gamecore = f.MainGameCore.instance, h.matchProcessor = b.MatchProcessor.instance, h.ball = h.gamecore.ball, h.playerSignal = v.Signals.PlayerSignal, 1 === h.SIDE ? (h.marker = 0, h.threePointDistance = u.ObjectsData.THREE_POINTS_DISTANCE, h.paintStartX = u.ObjectsData.PAINT_START_X, h.paintMiddleX = u.ObjectsData.PAINT_MIDDLE_X, h.dunkX = u.ObjectsData.DUNK_X, h.superDunkX = u.ObjectsData.ALLEY_OOP_X, h.superDashX = [u.ObjectsData.SUPER_DASH_X1, u.ObjectsData.SUPER_DASH_X2]) : (h.marker = l, h.threePointDistance = l - u.ObjectsData.THREE_POINTS_DISTANCE, h.paintStartX = l - u.ObjectsData.PAINT_MIDDLE_X, h.paintMiddleX = l - u.ObjectsData.PAINT_START_X, h.dunkX = l - u.ObjectsData.DUNK_X, h.superDunkX = l - u.ObjectsData.ALLEY_OOP_X, h.superDashX = [u.ObjectsData.SUPER_DASH_X2, u.ObjectsData.SUPER_DASH_X1]), h.dunkStart1Y = u.ObjectsData.DUNK_ZONE1_Y, h.dunkStart2Y = u.ObjectsData.DUNK_ZONE2_Y, h.dunkY = u.ObjectsData.DUNK_Y, h.superDunkY = u.ObjectsData.ALLEY_OOP_Y, h.superDunkEndX = h.dunkX + 20 * h.SIDE, h.superDunkEndY = h.dunkY + 30, h.superDashY = u.ObjectsData.SUPER_DASH_Y, h.superID = i;
        t = 1, l = parseInt(a.substr(1, 1));
        return 0 <= a.indexOf("B") ? (h.isHuman = !1, h.controller = new(0 === l ? u.AIController : u.AIController2)(h, h.superShot), h.controller.init(o)) : (h.isHuman = !0, t = 2, 0 === l ? h.controller = new u.PlayerControllerGeneral(h) : 1 === l ? h.controller = new u.PlayerController(h) : (h.controller = new u.PlayerController2(h), t = 3), e >= u.PlayersData.TEAMS_COUNT && (h.superID += 2)), h.energyBar = new u.EnergyBar(l, h.superID, o.coolDown), 0 === h.superID || 2 === h.superID ? h.teleport = new u.Teleport : 1 === h.superID ? h.shield = new m.ShieldObject(h.SIDE) : h.superID, h.accuracy = o.accuracy, h.chanceToCompleteDunk = o.chanceToCompleteDunk, h.createGraphic(e, i, s, r.armature), h.createBody(), h.indents = [], 0 === n ? (h.indents.push(g.get(p.default.WIDTH2 + h.SIDE * u.ObjectsData.PLAYER_INDENT_X, u.ObjectsData.PLAYER_INDENT_Y)), n = -1 === h.SIDE ? u.ObjectsData.INDENT_GENERAL_X : p.default.WIDTH - u.ObjectsData.INDENT_GENERAL_X, h.indents.push(g.get(n, u.ObjectsData.PLAYER_INDENT_Y))) : h.indents.push(g.get(p.default.WIDTH2 + 200 * h.SIDE, u.ObjectsData.PLAYER_INDENT_Y)), h.baseFriction = u.Materials.PLAYER.dynamicFriction, h.shadow = new d.ShadowObject(h.graphic, t), h.dashDelay = new y.UseDelay(u.ObjectsData.DASH_DELAY), c.prototype.add.call(h), h.theSpace = h.body.space, h
    }
    e.PlayerObject = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = nape.geom.Vec2,
        h = nape.shape.Polygon,
        l = nape.phys.Body,
        c = nape.phys.BodyType,
        u = i(13),
        d = i(3),
        p = i(1),
        f = i(0),
        g = i(5),
        n = (a = o.GameObject, n(m, a), m.prototype.blickComplete = function() {
            this.currentTime = 0, this.anim.visible = !1
        }, m.prototype.addBodyToSpace = function() {
            this.body.space = this.theSpace
        }, m.prototype.activate = function() {
            this.startPlay(), this.basket.hideEar(), g.default.getInstance().play(p.Sounds.shield)
        }, m.prototype.hide = function() {
            this.graphic.visible = !1, this.currentTime = -1
        }, m.prototype.startPlay = function() {
            this.graphic.alpha = 1, this.graphic.visible = !0, this.animBlur.visible = !0, this.animStart.visible = !1;
            var t = d.default.game.add.tween(this.animBlur);
            t.from({
                y: -600
            }, 120, f.Easing.Back.Out, !1), t.start(), (t = d.default.game.add.tween({
                x: 0
            })).onComplete.addOnce(this.blackTween, this), t.to({
                x: 100
            }, 140, f.Easing.Linear.None, !1), t.start()
        }, m.prototype.blackTween = function() {
            this.animStart.visible = !0, this.animBlur.visible = !1, this.anim.visible = !0, this.anim.animations.getAnimation("ShieldMC2").play(30)
        }, m.prototype.update = function(t) {
            void 0 === t && (t = 0), this.graphic.visible && 0 <= this.currentTime && (this.currentTime += t, this.currentTime >= this.showTime) && (this.currentTime = -1, (t = d.default.game.add.tween(this.graphic)).onComplete.addOnce(this.hide, this), t.to({
                alpha: 0
            }, 500).start(), this.body.space = null, this.basket.showEar())
        }, m.prototype.release = function() {
            this.theSpace = null, this.basket = null
        }, m);

    function m(t) {
        var e = a.call(this) || this;
        e.showTime = 3, e.currentTime = 0, e.animBlur = null, e.animStart = null, e.anim = null, e.objType = o.ObjectsType.EFFECTS, e.graphic = new Phaser.Group(d.default.game), e.animBlur = new Phaser.Image(d.default.game, 1, 0, p.Atlases.Gameplay, "ShieldMC0000"), e.animStart = new Phaser.Image(d.default.game, 1, 0, p.Atlases.Gameplay, "ShieldMC0000"), e.animBlur.anchor.set(.5), e.animStart.anchor.set(.5), e.anim = d.default.game.make.sprite(0, 0, p.Atlases.Gameplay, "bg0000"), e.anim.anchor.set(.5), e.anim.animations.add("ShieldMC2", Phaser.Animation.generateFrameNames("ShieldMC2", 0, 20, "", 4)), e.anim.animations.getAnimation("ShieldMC2").play(30), e.anim.animations.getAnimation("ShieldMC2").stop(), e.anim.animations.getAnimation("ShieldMC2").onStart.add(e.addBodyToSpace, e), e.anim.animations.getAnimation("ShieldMC2").onComplete.add(e.blickComplete, e);
        var i, s = -49; - 1 === t ? (i = o.ObjectsData.BASKET_CENTER - 13, e.basket = u.MainGameCore.instance.basket1, s += 26) : (i = o.ObjectsData.BASKET_CENTER2 + 13, e.graphic.scale.set(-1, 1), e.basket = u.MainGameCore.instance.basket2);
        var n = o.ObjectsData.BASKET_HEIGHT - 40;
        e.filterBlur = d.default.game.add.filter("BlurY"), e.body = new l(c.STATIC, r.get(i, n));
        s = new h(h.rect(s, 30, 70, 10));
        return s.filter = o.Filters.ARENA, s.cbTypes.add(o.CbTypes.cbShield), e.body.shapes.add(s), e.body.userData.side = t, a.prototype.add.call(e), e.graphic.addChild(e.animStart), e.graphic.addChild(e.animBlur), e.graphic.addChild(e.anim), e.animBlur.filters = [e.filterBlur], e.theSpace = e.body.space, e.body.space = null, e.hide(), e
    }
    e.ShieldObject = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(21),
        n = (a = i.FullDelay, n(o, a), o.prototype.activate = function() {
            this.delta = 0, this.delay = this.range
        }, o);

    function o(t) {
        return a.call(this, t) || this
    }
    e.UseDelay = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(48),
        n = (a = i.BaseAIController, n(o, a), o.prototype.onJumpBall = function() {
            this.opponent = this.opponents[0], this.jumpBall.activate()
        }, o);

    function o(t, e) {
        return a.call(this, t, e) || this
    }
    e.AIController = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(21),
        n = (a = i.FullDelay, n(o, a), o.prototype.activate = function() {
            a.prototype.activate.call(this);
            var t = Math.random() <= .5 ? -1 : 1;
            this.delay = this.fixed + t * this.dispersion
        }, o);

    function o(t, e) {
        return void 0 === e && (e = 0), a.call(this, t, e) || this
    }
    e.NegativeDelay = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(21),
        n = (a = i.FullDelay, n(o, a), o.prototype.activate = function() {
            this.delta = 0, this.delay = this.range * Math.random()
        }, o);

    function o(t) {
        return a.call(this, t) || this
    }
    e.SimpleDelay = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, i = i(21),
        n = (a = i.FullDelay, n(o, a), o.prototype.activate = function() {
            this.delta = 0, this.delay = Math.random() * this.range
        }, o.prototype.update = function(t) {
            if (0 <= this.delta) return this.result = 0, this.delta += t, this.delta >= this.delay && (this.result = 1, this.delta = -1), this.result;
            if (-1 === this.delta) return -1;
            var e = -2;
            return this.delta += t, -1 <= this.delta && (e = this.delta = -1), e
        }, o.prototype.useIt = function() {
            this.delta = -1 - this.fixed
        }, o.prototype.skipIt = function() {
            this.delta = -1 - this.fixed / 2
        }, o);

    function o(t, e) {
        return void 0 === e && (e = 0), a.call(this, t, e) || this
    }
    e.AIUseDelay = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(48),
        r = i(2),
        n = (a = o.BaseAIController, n(h, a), h.prototype.onJumpBall = function() {
            0 === this.playerNo && this.jumpBall.activate(), this.opponent = this.opponents[this.playerNo]
        }, h.prototype.ballInOwnHands = function(t) {
            void 0 === t && (t = 0), this.opponent = this.opponents[t], this.playerNo === t ? (this.currentNo = 0, a.prototype.ballInOwnHands.call(this)) : (this.currentNo = 1, this.resetBaseDelays(), this.resetCurrents(), this.strategy = 4, this.reboundPoint = this.reboundPointInAttack)
        }, h.prototype.ballInOpponentsHands = function(t) {
            void 0 === t && (t = 0), a.prototype.ballInOpponentsHands.call(this, t), this.opponent = this.opponents[t], this.playerNo != t && (this.strategy = 5)
        }, h.prototype.init = function(t) {
            a.prototype.init.call(this, t), this.chanceForThree *= r.ObjectsData.CHANCE_FOR_THREE2
        }, h.prototype.strategyDefence2 = function(t) {
            this.currentMove = this.moveToo(this.defensePoint);
            var e = this.stealDelay.update(t); - 1 === e && this.tryToSteal(), this.currentAction = 1 === e, this.currentJump = 1 === this.defence.update(t) && this.isOpponentCloseBehind(180)
        }, h);

    function h(t, e) {
        e = a.call(this, t, e) || this;
        return e.defensePoint = -1 === e.SIDE ? r.ObjectsData.DEFENSE_POINT : e.width - r.ObjectsData.DEFENSE_POINT, e
    }
    e.AIController2 = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(14),
        r = i(49),
        h = i(0),
        n = (a = r.PlayerBaseController, n(l, a), l.prototype.update = function() {
            this.currentMove = 0, this.currentDash = 0, o.default.instance.isbtnA && (o.default.instance.isbtnADouble && (this.currentDash = -1), this.currentMove--), o.default.instance.isbtnD && (o.default.instance.isbtnDDouble && (this.currentDash = 1), this.currentMove++), this.currentJump = o.default.instance.isbtnW, this.currentAction = o.default.instance.isbtnB, this.currentSuper = o.default.instance.isbtnV, this.currentBlockOrPump = o.default.instance.isbtnS
        }, l.prototype.readyForAction = function() {
            return !o.default.instance.isbtnV
        }, l.prototype.releaseBlockOrPump = function() {
            return !o.default.instance.isbtnS
        }, l.prototype.getJump = function() {
            return o.default.instance.isbtnW
        }, l.prototype.readyToJump = function() {
            return !o.default.instance.isbtnW
        }, l.prototype.getShoot = function() {
            return o.default.instance.isbtnB
        }, l.prototype.getTackle = function() {
            return o.default.instance.isbtnS
        }, l.prototype.getSuperShot = function() {
            return o.default.instance.isbtnV
        }, l);

    function l(t) {
        t = a.call(this, t) || this;
        return t.moveLeftKey = h.Keyboard.A, t.moveRightKey = h.Keyboard.D, t.jumpKey = h.Keyboard.W, t.downKey = h.Keyboard.S, t.actionKey = h.Keyboard.B, t.superKey = h.Keyboard.V, t
    }
    e.PlayerController = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(14),
        i = i(49),
        n = (a = i.PlayerBaseController, n(r, a), r.prototype.update = function() {
            this.currentMove = 0, this.currentDash = 0, o.default.instance.isbtnLeft && (o.default.instance.isbtnLeftDouble && (this.currentDash = -1), this.currentMove--), o.default.instance.isbtnRight && (o.default.instance.isbtnRightDouble && (this.currentDash = 1), this.currentMove++), this.currentJump = o.default.instance.isbtnUp, this.currentAction = o.default.instance.isbtnL, this.currentSuper = o.default.instance.isbtnK, this.currentBlockOrPump = o.default.instance.isbtnDown
        }, r.prototype.readyForAction = function() {
            return !o.default.instance.isbtnL
        }, r.prototype.releaseBlockOrPump = function() {
            return !o.default.instance.isbtnDown
        }, r.prototype.getJump = function() {
            return o.default.instance.isbtnUp
        }, r.prototype.readyToJump = function() {
            return !o.default.instance.isbtnUp
        }, r.prototype.getShoot = function() {
            return o.default.instance.isbtnL
        }, r.prototype.getTackle = function() {
            return o.default.instance.isbtnDown
        }, r.prototype.getSuperShot = function() {
            return o.default.instance.isbtnK
        }, r);

    function r(t) {
        return a.call(this, t) || this
    }
    e.PlayerController2 = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(25),
        r = i(14),
        n = (a = o.BaseController, n(h, a), h.prototype.update = function(t) {
            this.currentDash = 0, r.default.instance.isbtnLeft || r.default.instance.isbtnA ? (this.currentMove = -1, (r.default.instance.isbtnLeftDouble || r.default.instance.isbtnADouble) && (this.currentDash = -1)) : r.default.instance.isbtnRight || r.default.instance.isbtnD ? (this.currentMove = 1, (r.default.instance.isbtnRightDouble || r.default.instance.isbtnDDouble) && (this.currentDash = 1)) : this.currentMove = 0, this.currentJump = r.default.instance.isbtnUp || r.default.instance.isbtnW, this.currentAction = r.default.instance.isbtnX || r.default.instance.isbtnL, this.currentSuper = r.default.instance.isbtnZ || r.default.instance.isbtnK, this.currentBlockOrPump = r.default.instance.isbtnDown || r.default.instance.isbtnS
        }, h.prototype.readyForAction = function() {
            return !r.default.instance.isbtnL && !r.default.instance.isbtnX
        }, h.prototype.releaseBlockOrPump = function(t) {
            return !r.default.instance.isbtnDown && !r.default.instance.isbtnS
        }, h.prototype.getJump = function() {
            return r.default.instance.isbtnUp || r.default.instance.isbtnW
        }, h.prototype.readyToJump = function() {
            return !0 !== r.default.instance.isbtnUp && !0 !== r.default.instance.isbtnW
        }, h.prototype.getShoot = function() {
            return r.default.instance.isbtnX || r.default.instance.isbtnL
        }, h.prototype.getTackle = function() {
            return r.default.instance.isbtnDown || r.default.instance.isbtnS
        }, h.prototype.getSuperShot = function() {
            return r.default.instance.isbtnZ || r.default.instance.isbtnK
        }, h);

    function h(t) {
        t = a.call(this, t) || this;
        return t.type = 1, t
    }
    e.PlayerControllerGeneral = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = i(19),
        h = i(3),
        l = i(1),
        c = i(0),
        n = (a = o.GameObject, n(u, a), u.prototype.startPlay = function(t, e) {
            this.graphic.x = t, this.graphic.y = e, this.graphic.visible = !0, this.anim.visible = !1, this.whiteBg.visible = !1, this.whiteBg.scale.set(.086, .027), this.blackBg.scale.set(.12);
            e = this.blackBg.game.add.tween(this.blackBg.scale);
            e.onComplete.addOnce(this.blackTween, this), e.to({
                x: 1,
                y: 1
            }, 60, c.Easing.Linear.None, !1), e.start(), (e = this.blackBg.game.add.tween(this.blackBg)).to({
                angle: 180
            }, 60, c.Easing.Linear.None, !1), e.start()
        }, u.prototype.blackTween = function() {
            this.anim.visible = !0;
            var t = this.blackBg.game.add.tween(this.blackBg.scale);
            t.to({
                x: 0,
                y: 0
            }, 80, c.Easing.Back.In, !1), t.start();
            t = this.blackBg.game.add.tween(this.blackBg);
            t.onComplete.addOnce(this.whiteTween, this), t.to({
                angle: 360
            }, 70, c.Easing.Linear.None, !1), t.start(), this.anim.animations.getAnimation("teleport3").play(30)
        }, u.prototype.whiteTween = function() {
            this.whiteBg.visible = !0, this.anim.visible = !1;
            var t = this.blackBg.game.add.tween(this.whiteBg.scale);
            t.onComplete.addOnce(this.endPlay, this), t.to({
                x: .658,
                y: .596
            }, 30, c.Easing.Linear.None).to({
                x: .084,
                y: 1.258
            }, 30, c.Easing.Linear.None).to({
                x: .028,
                y: .072
            }, 24, c.Easing.Linear.None), t.start()
        }, u.prototype.endPlay = function() {
            this.graphic.visible = !1
        }, u);

    function u() {
        var t = a.call(this) || this;
        t.tween = null, t.blackBg = null, t.whiteBg = null, t.anim = null, t.graphic = new Phaser.Group(h.default.game), t.blackBg = h.default.game.make.sprite(0, 0, l.Atlases.Gameplay, "teleport10000"), t.whiteBg = h.default.game.make.sprite(0, 0, l.Atlases.Gameplay, "teleport40000"), t.anim = h.default.game.make.sprite(0, 0, l.Atlases.Gameplay, "bg0000"), t.anim.anchor.set(.5), t.anim.animations.add("teleport3", Phaser.Animation.generateFrameNames("teleport3", 0, 3, "", 4)), t.anim.animations.getAnimation("teleport3").play(30), t.anim.animations.getAnimation("teleport3").stop(), t.blackBg.anchor.set(.5), t.whiteBg.anchor.set(.5);
        var e = h.default.game.make.image(0, 0, l.Atlases.Gameplay, "teleport20000");
        return e.anchor.set(.5), t.graphic.addChild(t.blackBg), t.graphic.addChild(t.anim), t.graphic.addChild(t.whiteBg), t.blackBg.addChild(e), t.objType = r.ObjectsType.EFFECTS, t.endPlay(), a.prototype.add.call(t), t
    }
    e.Teleport = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = i(19),
        h = i(3),
        l = i(8),
        c = i(1),
        u = i(0),
        n = (a = o.GameObject, n(d, a), d.prototype.activate = function() {
            this.graphic.visible = !0, this.msg.setText(""), this.timer = 0, this.curentFrame = 1
        }, d.prototype.tween = function(t) {
            3 <= t ? this.msg.setText(" GO!!!") : this.msg.setText("" + (3 - t)), this.curentFrame = t, this.graphic.scale.set(1), this.graphic.visible = !0, h.default.game.add.tween(this.graphic.scale).from({
                x: .2,
                y: .2
            }, 100, u.Easing.Back.Out, !0)
        }, d.prototype.hide = function() {
            this.graphic.visible = !1
        }, d.prototype.process = function(t) {
            void 0 === t && (t = 0), this.timer += t;
            t = Math.floor(3 * this.timer);
            return 4 === t ? (this.hide(), !0) : (t !== this.curentFrame && this.tween(t), !1)
        }, d.prototype.release = function() {
            a.prototype.release.call(this)
        }, d.prototype.dispose = function() {}, d);

    function d() {
        var t = a.call(this) || this;
        return t.msg = null, t.graphic = h.default.game.add.group(), t.msg = new l.default(h.default.game, "GO!!!", c.Constants.styleMSG, null, null, c.Atlases.Gameplay), t.msg.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.msg.setProp("#000000", 7, "#FFFFFF", 14), t.msg.btn.label.setMaxSize(400, 110), t.graphic.addChild(t.msg), t.graphic.x = 400, t.graphic.y = 170, t.hide(), t.objType = r.ObjectsType.INFO, t.timer = 0, t.curentFrame = 1, a.prototype.add.call(t), t
    }
    e.CountDownObject = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(1),
        h = i(20),
        l = i(7),
        n = (a = Phaser.Group, n(c, a), c.prototype.reset = function() {
            this.curTime = 0, this.energyBarForMask.visible = !0, this.energyBarMask.rotation = 0, this.update(0), this.energyBarForMask.mask = this.energyBarMask
        }, c.prototype.update = function(t) {
            if (void 0 === t && (t = 0), this.curTime += t, this.energyBarMask.clear(), this.curTime >= this.fullTime) return !(this.energyBarForMask.visible = !1);
            this.frame = 36 * this.curTime / this.fullTime >> 0, this.energyBarMask.beginFill(16711680, .5), this.energyBarMask.arc(0, 0, 36.5, 0, h.default.TO_RAD * (10 * this.frame), !0), this.energyBarMask.endFill(), this.energyBarMask.rotation = h.default.TO_RAD * (-90 - 10 * this.frame)
        }, c.prototype.dispose = function() {
            this.energyBar = null, this.energyBarMask = null, this.bg = null, this.curTime = 0, this.hint = null, this.energyBarForMask = null
        }, c);

    function c(t, e, i) {
        var s = a.call(this, o.default.game) || this;
        s.bg = null, s.frame = 0, s.curTime = 0, s.fullTime = i, s.bg = s.game.make.sprite(0, 1, r.Atlases.Gameplay, "btn_bg20000"), s.bg.anchor.set(.5), s.bg.scale.set(1.1), s.addChild(s.bg);
        i = "Z";
        return 0 === t ? s.x = 45 : 1 === t ? (s.x = 185, i = "V") : 2 === t && (s.x = 614, i = "K"), s.energyBar = s.game.make.sprite(0, 0, r.Atlases.Gameplay, "icon_ball000" + e), s.energyBarForMask = s.game.make.sprite(0, 0, r.Atlases.Gameplay, "icon_ball2000" + e), s.hint = new l.default(s.game, i, r.Constants.styleHintSkillKey, null, null, r.Atlases.Gameplay), s.hint.setFrames("key_hint0000", "key_hint0000", "key_hint0000", "key_hint0000"), s.hint.x = -30, s.hint.y = 30, s.y = 45, s.energyBar.anchor.set(.5), s.energyBarForMask.anchor.set(.5), s.addChild(s.energyBar), s.addChild(s.energyBarForMask), s.addChild(s.hint), s.energyBarMask = s.game.add.graphics(0, 0, s), s.energyBarForMask.mask = s.energyBarMask, s
    }
    e.EnergyBar = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(2),
        r = i(19),
        h = i(3),
        l = i(8),
        c = i(1),
        u = i(0),
        d = i(20),
        n = (a = o.GameObject, n(p, a), p.prototype.hide = function() {
            this.graphic.visible = !1
        }, p.prototype.show = function(t) {
            this.msgGraphics.children[0].visible = !1, this.msgGraphics.children[1].visible = !1, h.default.game.tweens.removeFrom(this.graphic.scale), this.msg.setText(" " + t + " "), this.msg2.setText(""), this.msg.y = 0, this.graphic.scale.set(1), this.graphic.visible = !0;
            t = h.default.game.add.tween(this.graphic.scale);
            t.from({
                x: .2,
                y: .2
            }, 270, u.Easing.Back.Out, !1), t.onComplete.addOnce(this.continueTween, this), t.start()
        }, p.prototype.show2 = function(t, e) {
            var i, s;
            if (void 0 === e && (e = 0), this.msgGraphics.children[0].visible = !1, this.msgGraphics.children[1].visible = !1, h.default.game.tweens.removeFrom(this.graphic.scale), 0 === t) s = 2 === (o = Math.random() <= .5 ? 2 : 3) ? (i = "THREE!!!", "PO-O-O-INT!!!") : (i = "FROM", "DOWNTOWN");
            else if (1 === t) {
                switch (o = 4 + 4 * Math.random() >> 0) {
                    case 4:
                        i = "JAM!!!";
                        break;
                    case 5:
                        i = "DUUUNK!!!";
                        break;
                    case 6:
                        i = "FLUSH!!!";
                        break;
                    case 7:
                        i = "STUFF!!!"
                }
                s = ""
            } else if (2 === t) o = 10, i = "FROM", s = "BLOCK!!!";
            else if (3 === t) o = 15, i = "BUZZER", s = "BEATER!!!";
            else if (4 === t) switch (o = 11 + 3 * Math.random() >> 0) {
                    case 11:
                        i = "FROM", s = "BLOCK!!!";
                        break;
                    case 12:
                        i = "BLOCK", s = "SHOT";
                        break;
                    case 13:
                        i = "REJECTED", s = "";
                        break;
                    case 14:
                        i = "DENIED!!!", s = ""
                } else if (6 === t) o = 1, i = "SCORE!!!", s = "";
                else if (7 === t) o = 8, i = "MEGA", s = "DU-U-U-NK!!!";
            else if (8 === t) o = 9, i = "ALLEY-", s = "O-O-OP!!!";
            else if (9 === t) o = 14, i = "BRICK!!!", s = "";
            else {
                if (11 === t) return void this.show("OVERTIME");
                if (10 === t) return void this.show("TIME!!!")
            }
            for (var n = h.default.game.cache.getJSON(c.JSONData.Players)["parts" + o], a = 0; a < 4; a++) n.hasOwnProperty(a) && "BallClipMsg" === n[a].g && (this.msgGraphics.children[0].visible ? (this.msgGraphics.children[1].visible = !0, this.msgGraphics.children[1].x = n[a].x, this.msgGraphics.children[1].y = n[a].y, this.msgGraphics.children[1].rotation = n[a].r * d.default.TO_RAD, this.msgGraphics.children[1].scale.set(n[a].scaleX, n[a].scaleY)) : (this.msgGraphics.children[0].visible = !0, this.msgGraphics.children[0].x = n[a].x, this.msgGraphics.children[0].y = n[a].y, this.msgGraphics.children[0].rotation = n[a].r * d.default.TO_RAD, this.msgGraphics.children[0].scale.set(n[a].scaleX, n[a].scaleY)));
            this.msg.setText(" " + i + " "), this.msg2.setText(" " + s + " "), 0 < s.length ? (this.msg.y = -40, this.msg2.y = 40) : this.msg.y = 0, this.graphic.scale.set(1), this.graphic.visible = !0;
            var o = h.default.game.add.tween(this.graphic.scale);
            o.from({
                x: .2,
                y: .2
            }, 270, u.Easing.Back.Out, !1), o.onComplete.addOnce(this.continueTween, this), o.start()
        }, p.prototype.continueTween = function() {
            var t = h.default.game.add.tween(this.graphic.scale);
            t.to({
                x: .9,
                y: .9
            }, 450, u.Easing.Back.Out, !1), t.onComplete.addOnce(this.hide, this), t.start()
        }, p.prototype.release = function() {
            a.prototype.release.call(this)
        }, p);

    function p() {
        var t = a.call(this) || this;
        t.msg = null, t.msg2 = null, t.msgGraphics = null, t.graphic = h.default.game.add.group(), t.msgGraphics = h.default.game.add.group(), t.msg = new l.default(h.default.game, "111111111111", c.Constants.styleMSG, null, null, c.Atlases.Gameplay), t.msg.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.msg.setProp("#000000", 7, "#FFFFFF", 14), t.msg.btn.label.setMaxSize(640, 110), t.graphic.addChild(t.msgGraphics), t.graphic.addChild(t.msg), t.msg2 = new l.default(h.default.game, "111111111111", c.Constants.styleMSG, null, null, c.Atlases.Gameplay), t.msg2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.msg2.setProp("#000000", 7, "#FFFFFF", 14), t.msg2.btn.label.setMaxSize(640, 110), t.graphic.addChild(t.msg2), t.graphic.x = 400, t.graphic.y = 240, t.hide(), t.objType = r.ObjectsType.INFO;
        var e = h.default.game.make.image(0, 0, c.Atlases.Gameplay, "BallClipMsg0000");
        e.anchor.set(.5);
        var i = h.default.game.make.image(0, 0, c.Atlases.Gameplay, "BallClipMsg0000");
        return i.anchor.set(.5), t.msgGraphics.addChild(e), t.msgGraphics.addChild(i), a.prototype.add.call(t), t
    }
    e.MessageInfo = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = (n.prototype.init = function(t) {
        this.setupParticles()
    }, n.prototype.setupParticles = function() {}, n.prototype.step = function() {}, n.prototype.activate = function(t, e, i) {}, n.prototype.update = function(t, e) {}, n.prototype.dispose = function() {}, n.prototype.stop = function() {}, n.prototype.hide = function() {}, n.prototype.show = function() {}, n.prototype.getActive = function() {
        return !1
    }, n);

    function n() {}
    e.BallTrail = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(4),
        n = i(47),
        a = i(3),
        o = i(12),
        i = (r.setupPlayers = function() {
            n.AISkillsData.create();
            for (var t = 0; t < r.PLAYERS_COUNT; t++) r.heads[t] = "head" + (t + 1).toString(), r.bodies[t] = "body" + (t + 1).toString(), r.legs[t] = "leg" + (1 + (5 * Math.random() >> 0)).toString();
            r.legs[32] = r.legs[33] = "leg6"
        }, r.switchPlayer = function(t, e, i) {
            void 0 === i && (i = 1);
            t.getBone("head").slot.childArmature.animation.gotoAndPlay(r.heads[e]), t.getBone("body").slot.childArmature.animation.gotoAndPlay(r.bodies[i]), t.getBone("left hand").slot.childArmature.animation.gotoAndPlay("hand" + r.hands[e]), t.getBone("right hand").slot.childArmature.animation.gotoAndPlay("hand" + r.hands[e]), t.getBone("left leg").slot.childArmature.animation.gotoAndPlay(r.legs[e]), t.getBone("right leg").slot.childArmature.animation.gotoAndPlay(r.legs[e]), a.default.game.state.current === o.Gameplay.Name && (t.getBone("dighand").slot.childArmature.animation.gotoAndPlay("hand" + r.hands[e]), t.getBone("digleg").slot.childArmature.animation.gotoAndPlay(r.legs[e])), t.animation.gotoAndPlay("idle"), t.advanceTime(s.default.STEP)
        }, r.setPoint = function(t, e) {
            r.POINTS[t] = e
        }, r.getPoint = function(t) {
            return r.POINTS[t]
        }, r.PLAYERS_COUNT = 34, r.POINTS = [0, 0, 0, 0, 0, 0], r.heads = [], r.bodies = [], r.legs = [], r.hands = [2, 3, 1, 2, 2, 1, 2, 1, 2, 1, 1, 3, 3, 2, 1, 2, 3, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1, 2, 1], r.TEAMS_COUNT = 16, r);

    function r() {}
    e.PlayersData = i
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(2),
        h = i(0),
        l = i(1),
        c = i(7),
        u = i(5),
        n = (a = Phaser.Group, n(d, a), d.prototype.updateEmblems = function() {
            this.emblems.loadTexture(l.Atlases.Interface, "Emblems00" + (this.emblem <= 10 ? "0" : "") + (this.emblem - 1))
        }, d.prototype.setSuperHint = function() {
            this.emblem < 16 ? (this.superHint1.setText("Mega Dunk"), this.superHint2.setText("Defence"), this.superHint1Img.loadTexture(l.Atlases.Gameplay, "icon_ball0000"), this.superHint2Img.loadTexture(l.Atlases.Gameplay, "icon_ball0001")) : (this.superHint1.setText("Alley-Oop"), this.superHint2.setText("Fast Break"), this.superHint1Img.loadTexture(l.Atlases.Gameplay, "icon_ball0002"), this.superHint2Img.loadTexture(l.Atlases.Gameplay, "icon_ball0003"))
        }, d.prototype.setUp = function(t) {
            void 0 === t && (t = 0), 0 === t ? (this.label1.setText("Player " + (this.id + 1).toString()), this.label1.visible = !0, this.label2.visible = !1, this.shadow1.visible = !0, this.shadow2.visible = !1) : 1 === t ? (this.label1.visible = !0, this.label2.visible = !0, this.label1.setText("Player 1"), this.label2.setText("Player 2"), this.shadow1.visible = !0, this.shadow2.visible = !0) : 2 === t && (this.label1.visible = !1, this.label2.visible = !1, this.shadow1.visible = !0, this.shadow2.visible = !1)
        }, d.prototype.initPlayers = function() {
            this.player1 = new h.Sprite(this.game, 0, 0, l.Atlases.Interface, "bg0000"), this.player2 = new h.Sprite(this.game, 0, 0, l.Atlases.Interface, "bg0000"), this.player1.x = -40, this.player2.x = 55, this.player1.y = this.player2.y = 179, this.player1.scale.set(.65), this.player1.anchor.set(.5), this.player2.scale.set(.65), this.player2.anchor.set(.5), this.addChild(this.player1), this.addChild(this.player2), this.showPlayers(), this.player1.addChild(this.armature1.display), this.player2.addChild(this.armature2.display), this.player1.inputEnabled = !0, this.player2.inputEnabled = !0, this.player1.events.onInputDown.add(this.onArmature1Click, this), this.player2.events.onInputDown.add(this.onArmature2Click, this)
        }, d.prototype.showPlayers = function() {
            var t = 2 * this.emblem - 2,
                e = 2 * this.emblem - 1;
            this.armature1 && (r.PlayersData.switchPlayer(this.armature1, t, t + this.id), r.PlayersData.switchPlayer(this.armature2, e, t + this.id)), this.p1Name.setText(""), this.p2Name.setText(""), 0 === r.Inventory.instance.matchData.players[this.id][0] ? this.onArmature1Click(null, !0) : this.onArmature2Click(null, !0)
        }, d.prototype.onArmature1Click = function(t, e) {
            void 0 === t && (t = null), void 0 === e && (e = !1), 1 !== r.Inventory.instance.matchData.players[this.id][0] && !e || (this.armature1.animation.play("idle", -1), this.armature2.animation.gotoAndStopByTime("idle", 0), this.shadow1.x = -75, this.shadow2.x = 80, this.label1.x = -78, this.label2.x = 78, r.Inventory.instance.matchData.players[this.id][0] = 0)
        }, d.prototype.onArmature2Click = function(t, e) {
            void 0 === t && (t = null), void 0 === e && (e = !1), 0 !== r.Inventory.instance.matchData.players[this.id][0] && !e || (this.armature2.animation.play("idle", -1), this.armature1.animation.gotoAndStopByTime("idle", 0), this.shadow1.x = 80, this.shadow2.x = -75, this.label1.x = 78, this.label2.x = -78, r.Inventory.instance.matchData.players[this.id][0] = 1)
        }, d.prototype.changeTeam1 = function(t) {
            u.default.getInstance().play(l.Sounds.button), this.team = -1, this.checkEmblem(), this.emblem === r.Inventory.instance.matchData.teams[(this.id + 1) % 2] && this.checkEmblem(), this.updateClub()
        }, d.prototype.changeTeam2 = function(t) {
            u.default.getInstance().play(l.Sounds.button), this.team = 1, this.checkEmblem(), this.emblem === r.Inventory.instance.matchData.teams[(this.id + 1) % 2] && this.checkEmblem(), this.updateClub()
        }, d.prototype.updateClub = function() {
            r.Inventory.instance.matchData.teams[this.id] = this.emblem, this.updateEmblems(), this.setSuperHint(), this.showPlayers()
        }, d.prototype.checkEmblem = function() {
            this.emblem += this.team, 0 === this.emblem ? this.emblem = 17 : 18 === this.emblem && (this.emblem = 1)
        }, d.prototype.destroy = function() {
            this.armature1 = null, this.armature2 = null, this.player1 = null, this.player2 = null, this.manager = null, a.prototype.destroy.call(this)
        }, d);

    function d(t, e, i, s) {
        void 0 === s && (s = !0);
        var n = a.call(this, o.default.game) || this;
        return n.team = 0, n.id = t, n.manager = r.Inventory.instance, n.armature1 = e, n.armature2 = i, n.bg = n.game.add.sprite(0, 15, l.Atlases.Interface, "0bg100000"), n.bg.anchor.set(.5, .22), n.addChild(n.bg), 0 === t ? n.bg.scale.set(-.85, .9) : n.bg.scale.set(.85, .9), n.isLocal = n.manager.isLocal, n.btnLeft = new c.default(n.game, "", {}, n.changeTeam1, n, l.Atlases.Interface), n.btnRight = new c.default(n.game, "", {}, n.changeTeam2, n, l.Atlases.Interface), n.superHint1 = new c.default(n.game, "", l.Constants.styleSkillName, null, null, l.Atlases.Interface), n.superHint2 = new c.default(n.game, "", l.Constants.styleSkillName, null, null, l.Atlases.Interface), n.p1Name = new c.default(n.game, "", l.Constants.stylePlayerName, null, null, l.Atlases.Interface), n.p2Name = new c.default(n.game, "", l.Constants.stylePlayerName, null, null, l.Atlases.Interface), n.label1 = new c.default(n.game, "", l.Constants.stylePlayer, null, null, l.Atlases.Interface), n.label2 = new c.default(n.game, "", l.Constants.stylePlayer, null, null, l.Atlases.Interface), n.p1Name.label.setMaxSize(150, 60), n.p2Name.label.setMaxSize(150, 60), n.p1Name.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.p2Name.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.label1.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.label2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.superHint1.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.superHint2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.btnLeft.setFrames("BtnLeft0000", "BtnLeft0000", "BtnLeft0000", "BtnLeft0000"), n.btnRight.setFrames("BtnLeft0000", "BtnLeft0000", "BtnLeft0000", "BtnLeft0000"), n.btnLeft.x = -89, n.btnLeft.y = 10, n.btnRight.x = 89, n.btnRight.y = 10, n.btnRight.scale.set(-1, 1), s || (n.btnLeft.visible = !1, n.btnRight.visible = !1), n.shadow1 = n.game.add.image(-75, 160, l.Atlases.Interface, "loginSelect0000"), n.shadow1.anchor.set(.5), n.shadow1.scale.set(1.2), n.addChild(n.shadow1), n.shadow2 = n.game.add.image(80, 160, l.Atlases.Interface, "loginSelect0000"), n.shadow2.anchor.set(.5), n.shadow2.scale.set(1.2), n.addChild(n.shadow2), n.addChild(n.btnLeft), n.addChild(n.btnRight), (s = n.game.add.image(-110, 250, l.Atlases.Gameplay, "btn_bg0000")).anchor.set(.5), s.scale.set(.258), n.addChild(s), (s = n.game.add.image(49, 250, l.Atlases.Gameplay, "btn_bg0000")).anchor.set(.5), s.scale.set(.258), n.addChild(s), n.superHint1Img = n.game.add.image(-110, 250, l.Atlases.Gameplay, "icon_ball0000"), n.superHint1Img.anchor.set(.5), n.superHint1Img.scale.set(.3), n.addChild(n.superHint1Img), n.superHint2Img = n.game.add.image(49, 250, l.Atlases.Gameplay, "icon_ball0001"), n.superHint2Img.anchor.set(.5), n.superHint2Img.scale.set(.3), n.addChild(n.superHint2Img), 0 === r.Inventory.instance.matchData.teams[t] ? (1 === t && 2 === r.Inventory.instance.matchData.teams[0] ? n.emblem = 1 : 0 !== t || n.isLocal ? n.emblem = t + 1 : n.emblem = 17, r.Inventory.instance.matchData.teams[t] = n.emblem) : n.emblem = r.Inventory.instance.matchData.teams[t], n.emblems = n.game.add.image(0, 0, l.Atlases.Interface, "Emblems00" + (n.emblem <= 10 ? "0" : "") + (n.emblem - 1)), n.setSuperHint(), n.emblems.anchor.set(.5), n.emblems.scale.set(.35), n.addChild(n.emblems), n.addChild(n.p1Name), n.addChild(n.p2Name), n.addChild(n.label1), n.addChild(n.label2), n.addChild(n.superHint1), n.addChild(n.superHint2), n.label1.x = -80, n.label2.x = 80, n.label1.y = 70, n.label2.y = 70, n.p1Name.x = -78, n.p1Name.y = 90, n.p2Name.x = 78, n.p2Name.y = 90, n.superHint1.x = -63, n.superHint1.y = 250, n.superHint2.x = 98, n.superHint2.y = 250, n.initPlayers(), n.game.add.existing(n), n
    }
    e.SelectPlayer = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var r, h = i(3),
        l = i(1),
        c = i(8),
        u = i(2),
        a = i(51),
        n = (r = Phaser.Group, n(o, r), o.prototype.createTitle = function() {
            this.title = new c.default(this.game, this.defineLeg(), l.Constants.stylePreMatchTop, null, null, l.Atlases.Interface), this.title.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.title.setProp("#000000", 6, "#FFFFFF", 12), this.addChild(this.title)
        }, o.prototype.createMode = function() {
            this.matchModePanel = new a.MatchModePanel(null), this.matchModePanel.y = 220, this.matchModePanel.hideBG(), this.matchModePanel.showCurrentMode(), this.addChild(this.matchModePanel)
        }, o.prototype.createTitleState = function(t, e) {
            this.title_state = new c.default(this.game, t, e, null, null, l.Atlases.Interface), this.title_state.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.title_state.setProp("#000000", 5, "#FFFFFF", 10), 2 === this.id ? (this.title_state.setProp("#000000", 10, "#FFFFFF", 22), this.title_state.y = -50) : (this.title_state.setProp("#000000", 5, "#FFFFFF", 10), this.title_state.y = 55), this.addChild(this.title_state)
        }, o.prototype.defineLeg = function() {
            var t, e = u.Inventory.instance.tournament.state;
            return 0 === e ? t = "ROUND OF 16" : 1 === e ? t = "QUARTERFINAL" : 2 === e ? t = "SEMIFINAL" : 3 === e && (t = u.Inventory.instance.isFinal() ? "FINAL" : "3rd PLACE MATCH"), t
        }, o);

    function o(t) {
        var e = r.call(this, h.default.game) || this;
        e.id = t;
        var i = u.Inventory.instance.matchData.teams[0] - 1,
            s = u.Inventory.instance.matchData.teams[1] - 1,
            n = "",
            a = "",
            o = 1;
        return 0 === t ? (n = "MATCH PREVIEW", e.createTitle(), e.createTitleState(n, l.Constants.stylePreMatchState), a = "0 : 0", e.createMode()) : (o = 2, n = u.Inventory.instance.matchData.matchScore[0] > u.Inventory.instance.matchData.matchScore[1] ? "YOU WON!!!" : "YOU LOST", e.createTitleState(n, l.Constants.styleEndMatchTop), a = u.Inventory.instance.matchData.matchScore[0].toString() + " : " + u.Inventory.instance.matchData.matchScore[1].toString()), e.score = new c.default(e.game, a, 2 === e.id ? l.Constants.styleEndMatchScore : l.Constants.stylePreMatchScore, null, null, l.Atlases.Interface), e.score.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.score.setProp("#000000", 7, "#FFFFFF", 15), 2 === e.id ? e.score.y = 60 : e.score.y = 140, e.addChild(e.score), e.ccc = new c.default(e.game, "", l.Constants.stylePreMatchNames, null, null, l.Atlases.Interface), e.ccc.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.ccc.setProp("#000000", 4, "#FFFFFF", 8), e.ccc.y = 220, e.ccc.x = -150 * o, e.addChild(e.ccc), e.ccc2 = new c.default(e.game, "", l.Constants.stylePreMatchNames, null, null, l.Atlases.Interface), e.ccc2.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.ccc2.setProp("#000000", 4, "#FFFFFF", 8), e.ccc2.y = 220, e.ccc2.x = 150 * o, e.addChild(e.ccc2), e.ccc.visible = !1, e.ccc2.visible = !1, e.team1 = e.game.add.image(-270, 0, l.Atlases.Interface, "emptyBg0000"), e.team1.anchor.set(.5), e.team1.scale.set(.75), e.team1.y = 50, e.addChild(e.team1), e.team2 = e.game.add.image(270, 0, l.Atlases.Interface, "emptyBg0000"), e.team2.anchor.set(.5), e.team2.scale.set(.75), e.team2.y = 50, e.addChild(e.team2), e.team1.loadTexture(l.Atlases.Interface, "Emblems00" + (i < 10 ? "0" : "") + i), e.team2.loadTexture(l.Atlases.Interface, "Emblems00" + (s < 10 ? "0" : "") + s), e
    }
    e.PreMatchPanelResult = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(1),
        h = i(8),
        l = i(7),
        n = (a = Phaser.Group, n(c, a), c.prototype.createGraphics = function() {
            this.createPopup();
            var t, e = null,
                i = null,
                s = null,
                n = null,
                a = null,
                o = null;
            this.isRegister ? (this.title = new h.default(this.game, "REGISTER  to          ", r.Constants.styleCredits5, null, null, r.Atlases.Interface), this.title.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.title.setProp("#000000", 5, "#FFFFFF", 11), this.title.y = -180, this.popup.getChildAt(1).addChild(this.title), (t = this.game.add.image(this.title.x + 100, this.title.y, r.Atlases.Preloader, "branding_l20000")).anchor.set(.5), t.scale.set(.46), this.popup.getChildAt(1).addChild(t), this.buildText(this.linesRegister, -30), this.buildText(this.linesRegisterYellow, -30, r.Constants.stylePopupContentYellow), (e = new Phaser.Image(this.game, 0, -155, r.Atlases.Interface, "line0000")).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (e = new Phaser.Image(this.game, 0, -55, r.Atlases.Interface, "line0000")).anchor.set(.5), this.popup.getChildAt(1).addChild(e), (n = new h.default(this.game, "REGISTER", r.Constants.stylePopupPlay, this.onRegister, this, r.Atlases.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), n.setProp("#000000", 5, "#FFFFFF", 11), n.x = -70, n.y = 145, n.scale.set(.65, 1), this.popup.getChildAt(1).addChild(n), (a = new h.default(this.game, "CANCEL", r.Constants.stylePopupCancel, this.onCancel, this, r.Atlases.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), a.setProp("#000000", 5, "#FFFFFF", 11), a.x = 100, a.y = 145, a.scale.set(.65, 1), this.popup.getChildAt(1).addChild(a)) : (this.title = new h.default(this.game, "CHECK OUT!", r.Constants.styleCredits33, null, null, r.Atlases.Interface), this.title.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.title.setProp("#000000", 6, "#FFFFFF", 13), this.title.y = -135, this.popup.getChildAt(1).addChild(this.title), this.buildText(this.linesForum, 30), (e = new Phaser.Image(this.game, 0, -100, r.Atlases.Interface, "line0000")).anchor.set(.5), e.scale.set(1.5, 1), this.popup.getChildAt(1).addChild(e), (e = new Phaser.Image(this.game, 0, -40, r.Atlases.Interface, "line0000")).anchor.set(.5), e.scale.set(1.5, 1), this.popup.getChildAt(1).addChild(e), (e = new Phaser.Image(this.game, 0, 70, r.Atlases.Interface, "line0000")).anchor.set(.5), e.scale.set(1.5, 1), this.popup.getChildAt(1).addChild(e), (i = new h.default(this.game, "OK", r.Constants.stylePlayGreen, this.onOk, this, r.Atlases.Interface)).setFrames("bg0000", "bg0000", "bg0000", "bg0000"), i.setProp("#000000", 7, "#FFFFFF", 15), i.x = 0, i.y = 125, this.popup.getChildAt(1).addChild(i), (s = new l.default(this.game, "forum", r.Constants.stylePopupContent2, this.onOk, this, r.Atlases.Preloader)).setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), s.x = 0, s.y = -70, s.label.x = 75, s.btn.x = -65, s.btn.scale.set(.75), s.label.stroke = "#FFFFFF", s.label.strokeThickness = 4, this.popup.getChildAt(1).addChild(s), (o = new l.default(this.game, "", r.Constants.stylePlayGreen, this.onClose, this, r.Atlases.Interface)).setFrames("close0000", "close0000", "close0000", "close0000"), o.x = 156, o.y = -179, this.popup.getChildAt(1).addChild(o)), this.resize(1)
        }, c.prototype.onOk = function() {
            this.signalOk.dispatch(), this.closePopup()
        }, c.prototype.onRegister = function() {
            this.signalRegister.dispatch(), this.closePopup()
        }, c.prototype.onCancel = function() {
            this.signalCancel.dispatch(), this.closePopup()
        }, c.prototype.onClose = function() {
            this.signalClose.dispatch(), this.closePopup()
        }, c.prototype.closePopup = function() {
            this.popup.destroy()
        }, c.prototype.buildText = function(t, e, i) {
            var s;
            void 0 === t && (t = null), void 0 === e && (e = 30), void 0 === i && (i = r.Constants.stylePopupContent), null === t && (t = [" ", " ", " ", " ", " ", "Ported by iriysoft.com"]);
            for (var n = 0; n < t.length; n++)(s = new l.default(this.game, t[n], i, null, null, r.Atlases.Interface)).y = n * e - 75, s.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), s.btn.inputEnabled = !1, this.popup.getChildAt(1).addChild(s)
        }, c.prototype.disposePopup = function() {
            this.popup.destroy(), this.popup = null
        }, c.prototype.backgroundPopup = function() {
            this.popup = this.game.add.sprite(350, 280, r.Atlases.Interface, "bg0000"), this.popup.anchor.set(.5), this.popup.scale.set(1.33333);
            var t = this.game.add.sprite(0, 0, r.Atlases.Interface, "black0000");
            t.width = this.game.width + 500, t.height = this.game.height + 500, t.inputEnabled = !0, t.anchor.set(.5), t.alpha = .5, this.popup.addChild(t)
        }, c.prototype.createPopup = function(t) {
            void 0 === t && (t = "0bg100000"), null !== this.popup && this.disposePopup(), this.backgroundPopup();
            var e = this.game.add.sprite(0, 0, r.Atlases.Interface, "bg0000");
            e.anchor.set(.5), e.inputEnabled = !0, this.popup.addChild(e);
            var i = this.game.add.sprite(0, 0, r.Atlases.Interface, t);
            i.anchor.set(.5), e.addChild(i), "0bg100000" === t || (i.scale.set(1.5, 1.3), i.y = -30)
        }, c.prototype.resize = function(t) {
            var e = this.popup.removeChildAt(0);
            e.width = this.game.width + 500, e.height = this.game.height + 500, this.popup.x = this.game.world.bounds.centerX, this.popup.y = 260 * t, this.popup.addChildAt(e, 0), this.popup.scale.set(t)
        }, c);

    function c(t) {
        void 0 === t && (t = !0);
        var e = a.call(this, o.default.game) || this;
        return e.popup = null, e.isRegister = !1, e.title = null, e.signalOk = new Phaser.Signal, e.signalRegister = new Phaser.Signal, e.signalCancel = new Phaser.Signal, e.signalClose = new Phaser.Signal, e.linesRegister = ["use                            ", " with                  skills and", " to get                    team"], e.linesRegisterYellow = ["           ONLINE SAVE", "SUPER          ", "  Y8.COM"], e.linesForum = [" ", " ", "Discuss the game,", "chat with players,", "get useful tips"], e.isRegister = t, e.createGraphics(), e
    }
    e.PopupGUI = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0, i(6), i(0);
    var a, o = i(5),
        r = i(1),
        h = i(17),
        l = i(9),
        c = i(8),
        u = i(18),
        d = i(106),
        p = i(2),
        f = i(4),
        g = i(0),
        m = i(12),
        n = (a = Phaser.State, n(y, a), y.prototype.init = function() {
            this.game.world.removeAll(), this.manager = p.Inventory.instance, this.table = []
        }, y.prototype.create = function() {
            a.prototype.create.call(this), this.backgroundBase = this.game.add.sprite(0, 0, r.Atlases.Preloader, l.default.getBG()), this.backgroundBase2 = this.game.add.sprite(299, 0, r.Atlases.Interface, "bg0000"), this.backgroundBase.addChild(this.backgroundBase2), this.backgroundBaseMask = this.game.add.graphics(0, 0), this.backgroundBaseMask.beginFill(65280, 0), this.backgroundBaseMask.drawRect(0, 0, 1398, 480), this.backgroundBaseMask.endFill(), this.background4 = this.game.add.sprite(200, 240, r.Atlases.Interface, "bg0000"), this.background4.anchor.set(.5), this.createButtons(), this.setUp(), this.backgroundBase2.addChild(this.background4), this.logo = this.game.add.sprite(400, 25, r.Atlases.Interface, "bg0000"), this.logo.anchor.set(.5);
            var t = new c.default(this.game, "TOURNAMENT GRID", r.Constants.styleTitle2, null, null, r.Atlases.Interface);
            t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#000000", 7, "#FFFFFF", 15), this.logo.addChild(t), this.logo.x = 400, this.backgroundBase2.addChild(this.logo), this.playBtn = new c.default(this.game, "NEXT", r.Constants.stylePlayGreen, this.onPlay, this, r.Atlases.Interface), this.playBtn.setFrames("arrow20000", "arrow20000", "arrow20000", "arrow20000"), this.playBtn.btn.btn.x = 110, this.playBtn.x = 646, this.playBtn.y = 450, this.playBtn.setProp("#000000", 7, "#FFFFFF", 15), this.backBtn = new c.default(this.game, "BACK", r.Constants.styleBackArrow, this.onBack, this, r.Atlases.Interface), this.backBtn.setFrames("arrow0000", "arrow0000", "arrow0000", "arrow0000"), this.backBtn.btn.btn.x = -110, this.backBtn.setProp("#330099", 7, "#FF99FF", 15), this.backBtn.x = 160, this.backBtn.y = 450, this.backgroundBase2.addChild(this.backBtn), this.backgroundBase2.addChild(this.playBtn), this.resize(), new h.default(this.game, this, this.show)
        }, y.prototype.show = function() {
            var t = this.game.add.tween(this.logo);
            t.from({
                alpha: .001
            }, f.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.playBtn)).from({
                y: 520
            }, f.default.PRELOADER_TIME, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.backBtn)).from({
                y: 520
            }, f.default.PRELOADER_TIME, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[0])).from({
                x: -70
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[1])).from({
                x: -70
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[2])).from({
                x: -70
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[3])).from({
                x: -70
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[4])).from({
                x: 870
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[5])).from({
                x: 870
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[6])).from({
                x: 870
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[7])).from({
                x: 870
            }, 300, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.textQuarter1)).from({
                x: -70
            }, f.default.PRELOADER_TIME - 50, g.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.table[8])).from({
                x: -70
            }, 400, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[9])).from({
                x: -70
            }, 400, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.textQuarter2)).from({
                x: 870
            }, f.default.PRELOADER_TIME - 50, g.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.table[10])).from({
                x: 870
            }, 400, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.table[11])).from({
                x: 870
            }, 400, g.Easing.Back.Out), t.start(), (t = this.game.add.tween(this.textSemi1)).from({
                x: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.table[12])).from({
                x: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.textSemi2)).from({
                x: 870
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.table[13])).from({
                x: 870
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.textFinal)).from({
                y: -70
            }, f.default.PRELOADER_TIME - 150, g.Easing.Back.Out, !1, 150), t.start(), (t = this.game.add.tween(this.table[14])).from({
                y: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start(), (t = this.game.add.tween(this.text3rdPlace)).from({
                y: 550
            }, f.default.PRELOADER_TIME - 50, g.Easing.Back.Out, !1, 50), t.start(), (t = this.game.add.tween(this.table[15])).from({
                y: 550
            }, f.default.PRELOADER_TIME - 100, g.Easing.Back.Out, !1, 100), t.start()
        }, y.prototype.hide = function() {
            var t = this.game.add.tween(this.logo);
            t.to({
                alpha: .001
            }, f.default.PRELOADER_TIME), t.start(), (t = this.game.add.tween(this.logo)).to({
                y: -60
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.playBtn)).to({
                y: 520
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.backBtn)).to({
                y: 520
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[0])).to({
                x: -70
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[1])).to({
                x: -70
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[2])).to({
                x: -70
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[3])).to({
                x: -70
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[4])).to({
                x: 870
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[5])).to({
                x: 870
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[6])).to({
                x: 870
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[7])).to({
                x: 870
            }, 300, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.textQuarter1)).to({
                x: -70
            }, f.default.PRELOADER_TIME - 50, g.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.table[8])).to({
                x: -70
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[9])).to({
                x: -70
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.textQuarter2)).to({
                x: 870
            }, f.default.PRELOADER_TIME - 50, g.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.table[10])).to({
                x: 870
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.table[11])).to({
                x: 870
            }, f.default.PRELOADER_TIME, g.Easing.Linear.None), t.start(), (t = this.game.add.tween(this.textSemi1)).to({
                x: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.table[12])).to({
                x: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.textSemi2)).to({
                x: 870
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.table[13])).to({
                x: 870
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.textFinal)).to({
                y: -70
            }, f.default.PRELOADER_TIME - 50, g.Easing.Linear.None, !1, 50), t.start(), (t = this.game.add.tween(this.table[14])).to({
                y: -70
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start(), (t = this.game.add.tween(this.text3rdPlace)).to({
                y: 550
            }, f.default.PRELOADER_TIME - 150, g.Easing.Linear.None, !1, 150), t.start(), (t = this.game.add.tween(this.table[15])).to({
                y: 550
            }, f.default.PRELOADER_TIME - 100, g.Easing.Linear.None, !1, 100), t.start()
        }, y.prototype.createButtons = function() {
            for (var t, e = this.game.cache.getJSON(r.JSONData.Players), i = 1; i < 17; i++) {
                var s = e["match" + i].x,
                    n = e["match" + i].y,
                    a = "",
                    o = {
                        font: "12px Impact",
                        fill: "#FFFFFF"
                    };
                if (this.createButton(s, n), 9 === i || 11 === i ? (a = "QUARTERFINAL", 11 === i ? s += -2 : s -= 5) : 13 === i || 14 === i ? (a = "SEMIFINAL", 13 === i ? s += 22 : s -= 25) : 16 === i ? a = "3rd PLACE MATCH" : 15 === i && (a = "FINAL", o = {
                        font: "14px Impact",
                        fill: "#FF9900"
                    }), "" !== a) switch (t = new c.default(this.game, a, o, null, null, r.Atlases.Interface), t.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.setProp("#000000", 3, "#FFFFFF", 5), t.x = s, t.y = n - 58, this.backgroundBase2.addChild(t), i) {
                    case 9:
                        this.textQuarter1 = t;
                        break;
                    case 11:
                        this.textQuarter2 = t;
                        break;
                    case 13:
                        this.textSemi1 = t;
                        break;
                    case 14:
                        this.textSemi2 = t;
                        break;
                    case 15:
                        this.textFinal = t;
                        break;
                    case 16:
                        this.text3rdPlace = t
                }
            }
        }, y.prototype.createButton = function(t, e) {
            var i = new d.MatchPanelResult;
            i.x = t, i.y = e, this.backgroundBase2.addChild(i), this.table.push(i)
        }, y.prototype.setUp = function() {
            var t = p.Inventory.instance.tournament.state;
            0 === t ? this.fillStandings(8, 0) : 1 === t ? this.fillStandings(12, 8) : 2 === t ? this.fillStandings(14, 12) : this.fillStandings(16, 14)
        }, y.prototype.fillStandings = function(t, e) {
            for (var i = this.manager.tournament.rounds, s = this.manager.tournament.results, n = this.manager.tournament.team, a = this.manager.tournament.teamRound + 1, o = 0; o < this.table.length; o++) {
                var r, h, l = this.table[o],
                    c = o + 1;
                c <= t && (r = i[c - 1][0], h = i[c - 1][1], l.setEmblems(r, h), n !== r && n !== h || l.setBG(2), c === a && l.setBG(3), c <= e && (l.ccc.text = "" + s[c - 1][0], l.ccc2.text = "" + s[c - 1][1]))
            }
        }, y.prototype.onBack = function() {
            o.default.getInstance().play(r.Sounds.Click), new l.default(this.game, this, u.default.Name)
        }, y.prototype.onPlay = function() {
            o.default.getInstance().play(r.Sounds.Click), new l.default(this.game, this, m.Gameplay.Name)
        }, y.prototype.resize = function() {
            var t = 1;
            t = 1 < (t = this.game.width / r.Constants.WIDTH) ? 1 : t, t *= 1.33333, this.backgroundBase.scale.set(t), this.backgroundBase.alignIn(this.world.bounds, Phaser.TOP_CENTER), this.backgroundBaseMask.scale.set(t, t), this.backgroundBaseMask.x = this.backgroundBase.x, this.backgroundBaseMask.y = this.backgroundBase.y, a.prototype.resize.call(this)
        }, y.prototype.shutdown = function() {
            this.backgroundBase2 = null, this.backgroundBaseMask = null, this.backBtn = null, this.playBtn = null, a.prototype.shutdown.call(this)
        }, y.Name = "tournamentstate", y);

    function y() {
        var t = a.call(this) || this;
        return t.name = y.Name, t.table = [], t.manager = null, t
    }
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    e.__esModule = !0;
    var a, o = i(3),
        r = i(1),
        h = i(10),
        n = (a = Phaser.Group, n(l, a), l.prototype.setEmblems = function(t, e) {
            t = this.game.add.image(-30, -21, r.Atlases.Interface, "Emblems00" + (t - 1 < 10 ? "0" : "") + (t - 1)), e = this.game.add.image(-30, 17, r.Atlases.Interface, "Emblems00" + (e - 1 < 10 ? "0" : "") + (e - 1));
            t.anchor.set(.5), e.anchor.set(.5), t.scale.set(.15), e.scale.set(.15), this.addChild(t), this.addChild(e)
        }, l.prototype.setBG = function(t) {
            this.bg.loadTexture(r.Atlases.Interface, "MatchBack000" + (t - 1))
        }, l);

    function l() {
        var t = a.call(this, o.default.game) || this;
        t.bg = t.game.add.sprite(0, 0, r.Atlases.Interface, "MatchBack0000"), t.bg.anchor.set(.5), t.addChild(t.bg);
        var e = {
            font: "bold 24px Impact2",
            fill: "#FFFFFF"
        };
        return t.ccc = new h.default(t.game, 30, -22, "-", e), t.ccc.anchor.set(.5), t.addChild(t.ccc), t.ccc2 = new h.default(t.game, 30, 22, "-", e), t.ccc2.anchor.set(.5), t.addChild(t.ccc2), t.team1 = t.game.add.image(-30, -21, r.Atlases.Interface, "emptyBg0000"), t.team1.anchor.set(.5), t.team1.scale.set(.65), t.addChild(t.team1), t.team2 = t.game.add.image(-30, 17, r.Atlases.Interface, "emptyBg0000"), t.team2.anchor.set(.5), t.team2.scale.set(.65), t.addChild(t.team2), t
    }
    e.MatchPanelResult = n
}]);